; Williams Defender arcade game disassembly, created by Aaron Bottegal.
; This disassembly is a work in progress.


;PCB Registers

PALETTE_ENTRY_0x0                        = 0xC000
PALETTE_ENTRY_0x1                        = 0xC001
PALETTE_ENTRY_0x2                        = 0xC002
PALETTE_ENTRY_0x3                        = 0xC003
PALETTE_ENTRY_0x4                        = 0xC004
PALETTE_ENTRY_0x5                        = 0xC005
PALETTE_ENTRY_0x6                        = 0xC006
PALETTE_ENTRY_0x7                        = 0xC007
PALETTE_ENTRY_0x8                        = 0xC008
PALETTE_ENTRY_0x9                        = 0xC009
PALETTE_ENTRY_0xA                        = 0xC00A
PALETTE_ENTRY_0xB                        = 0xC00B
PALETTE_ENTRY_0xC                        = 0xC00C
PALETTE_ENTRY_0xD                        = 0xC00D
PALETTE_ENTRY_0xE                        = 0xC00E
PALETTE_ENTRY_0xF                        = 0xC00F
SCREEN_CONTROL                           = 0xC010
WATCHDOG                                 = 0xC3FC ;to 0xC3FF
VIDEO_COUNTER_BITS                       = 0xC800 ;to 0xCBFF
PIA_ROM_DATA_A                           = 0xCC00
PIA_ROM_CTRL_A                           = 0xCC01
PIA_ROM_DATA_B                           = 0xCC02
PIA_ROM_CTRL_B                           = 0xCC03
PIA_WGT_DATA_A                           = 0xCC04
PIA_WGT_CTRL_A                           = 0xCC05
PIA_WGT_DATA_B                           = 0xCC06
PIA_WGT_CTRL_B                           = 0xCC07
BANKSWITCH                               = 0xD000


;RAM Variables

	.org $A000
R_A000_CURR_PLANET_GEN_SHIFT_DELTA:      .rs 0x01 ;0xA000
A001_CURR_PLANET_GEN_HEIGHT_CHANGES:     .rs 0x01 ;0xA001
R_A002_CURR_PLANET_GEN_HEIGHT:           .rs 0x01 ;0xA002
A003_CURR_PLANET_GEN_DATA_PTR:           .rs 0x02 ;0xA003 to A004
R_A005_PLANET_DATA_PTR_LOWER:            .rs 0x02 ;0xA005 to A006

	.org $A006
R_A006_SCORE_POS_CHAR:                   .rs 0x01 ;0xA006
R_A007_PLANET_DATA_PTR_HIGHER:           .rs 0x02 ;0xA007 to A008

	.org $A008
HIGHSCORE_INITIALS_ADDR:                 .rs 0x01 ;0xA008
A009_WORLD_HEIGHT_POS_LEFT?:             .rs 0x02 ;0xA009 to A00A
A00B_PLANET_GEN_DATA_PTR:                .rs 0x02 ;0xA00B to A00C
A00D_WORLD_DATA_COPY_L:                  .rs 0x01 ;0xA00D
A00B_PLANET_GEN_HEIGHT_CHANGES:          .rs 0x01 ;0xA00E
A00F_SHIFTS_COUNTER_UNK:                 .rs 0x01 ;0xA00F
A010_PLANET_GEN_SHIFTS_DELTA:            .rs 0x01 ;0xA010
A011_WORLD_HEIGHT_UNK:                   .rs 0x01 ;0xA011
A012_PLANET_GEN_HEIGHT:                  .rs 0x01 ;0xA012
R_A013_STACK_SAVE_IRQ_RTN_B7:            .rs 0x02 ;0xA013 to A014
A015_WORLD_UPDATE_COUNT?:                .rs 0x02 ;0xA015 to A016
A017_WORLD_MOVEMENT_MASKED:              .rs 0x02 ;0xA017 to A018

	.org $A020
R_A020_SCREEN_POS_HORIZ_1_CURR?:         .rs 0x02 ;0xA020 to A021
R_A022_SCREEN_POS_HORIZ_2_TRGT?:         .rs 0x02 ;0xA022 to A023
A024_TIME_PLAYED?:                       .rs 0x01 ;0xA024
SHOW_PLAYER_TEXT_FLAG?:                  .rs 0x01 ;0xA025
COLOR_PALETTE_RAM_COPY:                  .rs 0x10 ;0xA026 to A035
CURRENT_BANK:                            .rs 0x01 ;0xA036
SRAM_C495-C496_PLAY_CREDITS:             .rs 0x01 ;0xA037
R_A038_BOOKKEEP_SUB_SUB_CREDITS?:        .rs 0x01 ;0xA038
R_A039_BOOKKEEP_SUB_CREDITS?:            .rs 0x01 ;0xA039
R_A03A_MENU_UNK:                         .rs 0x01 ;0xA03A
R_AO3B_UPDATE_SCREEN?:                   .rs 0x01 ;0xA03B
R_A03C_OPTION_ON:                        .rs 0x01 ;0xA03C
TEXT_PTR_TO_CODE_JSR:                    .rs 0x02 ;0xA03D to A03E
TEXT_PTR_TO_CODE_JMP:                    .rs 0x02 ;0xA03F to A040
R_A041_TEST_TEMP/RUG_MISMATCH_BITS:      .rs 0x02 ;0xA041 to A042
R_A043_TEST_TEMP/RUG_MISMATCH_ADDR:      .rs 0x02 ;0xA043 to A044
R_A045_LINE_DRAW_CR_XXYY:                .rs 0x02 ;0xA045 to A046
UNK_$47_AUTO+ADV:                        .rs 0x01 ;0xA047
UNK_$48_AUTO+ADV:                        .rs 0x01 ;0xA048
UNK_$49_SYS_MENU_FLAG?:                  .rs 0x01 ;0xA049
R_A04A_ROM_FAIL_POS_XXYY:                .rs 0x02 ;0xA04A to A04B
TEXT_DATA_SPACING_XXYY?:                 .rs 0x02 ;0xA04C to A04D
SENTENCE_CURR_SCR_LOC_CR_XXYY?:          .rs 0x02 ;0xA04E to A04F
SENTENCE_CURR_SCR_LOC_XXYY:              .rs 0x02 ;0xA050 to A051
SENTENCE_PTR_WORD_ON:                    .rs 0x02 ;0xA052 to A053
SENTENCE_PTR_TO_WORD:                    .rs 0x02 ;0xA054 to A055
SENTENCE_END_PTR:                        .rs 0x02 ;0xA056 to A057
SENTENCE_FLAG_58:                        .rs 0x01 ;0xA058
TEXT_PTR_UNK:                            .rs 0x02 ;0xA059 to A05A
R_A05B_ROM_CHECK_UNK:                    .rs 0x02 ;0xA05B to A05C
TICKS_HAPPENED_COUNTER?:                 .rs 0x01 ;0xA05D
R_A05E_SLOWDOWN_FLAG?:                   .rs 0x01 ;0xA05E
LIST_CALLBACKS_GENERIC?:                 .rs 0x02 ;0xA05F to A060
LIST_15B_CALLBACKS_AVAILABLE:            .rs 0x02 ;0xA061 to A062
R_A063_CALLBACK_LIST/CURRENT:            .rs 0x02 ;0xA063 to A064 - Current task ptr.
LIST_IN_WORLD:                           .rs 0x02 ;0xA065 to A066
LIST_23B_LARGE_POOL:                     .rs 0x02 ;0xA067 to A068
LIST_23B_CALLBACKS_AVAILABLE_SMALL:      .rs 0x02 ;0xA069 to A06A
LIST_OFFSCREEN:                          .rs 0x02 ;0xA06B to A06C
LIST_BULLETS?:                           .rs 0x02 ;0xA06D to A06E
STAR_SCREEN_DELTA:                       .rs 0x02 ;0xA06F to A070
STAR_DISPLAY_MASK:                       .rs 0x01 ;0xA071

	.org $A073
A073_SCRATCHPAD_ADDR:                    .rs 0x02 ;0xA073 to A074
R_A075_ABDUCT_POS_TEST?:                 .rs 0x02 ;0xA075 to A076
SMASH_S_SAVE_AND_TEMP:                   .rs 0x02 ;0xA077 to A078
PIA_ROM_DATA_A_RAM_COPY:                 .rs 0x01 ;0xA079
PIA_ROM_DATA_A_RAM_COPY_OLD:             .rs 0x01 ;0xA07A
WGT_DATA_A_RAM_COPY:                     .rs 0x01 ;0xA07B
WGT_DATA_A_RAM_COPY_OLD:                 .rs 0x01 ;0xA07C
WGT_DATA_B_RAM_COPY:                     .rs 0x01 ;0xA07D
SLAM_TIMER:                              .rs 0x01 ;0xA07E
COIN_ACCEPT_BLOCK_7F:                    .rs 0x01 ;0xA07F
COIN_ACCEPT_BLOCK_80:                    .rs 0x01 ;0xA080
COIN_ACCEPT_BLOCK_81:                    .rs 0x01 ;0xA081
R_A082_BUTTON_PRESSED_PTR_A1:            .rs 0x02 ;0xA082 to A083
R_A084_BUTTON_PRESSED_PTR_A2:            .rs 0x02 ;0xA084 to A085
R_A086_BUTTON_PRESSED_PTR_B1:            .rs 0x02 ;0xA086 to A087
R_A088_BUTTON_PRESSED_PTR_B2:            .rs 0x02 ;0xA088 to A089
R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT?: .rs 0x01 ;0xA08A
A08B_CURRENT_PLAYER:                     .rs 0x01 ;0xA08B
A08C_CURRENT_PLAYER_COUNT_1/2:           .rs 0x01 ;0xA08C
A08D_CURRENT_PLAYER_PTR?:                .rs 0x02 ;0xA08D to A08E
IRQ_CMD_LOC:                             .rs 0x03 ;0xA08F to A091
IRQ_NEXT_STEP_TODO:                      .rs 0x01 ;0xA092
R_A093_SHIP_SUCTION_TO:                  .rs 0x01 ;0xA093
R_A094_THRUST_UNK_A2:                    .rs 0x01 ;0xA094
R_A095_CAM_HMOD:                         .rs 0x02 ;0xA095 to A096
R_A097_SCANNER_DOTS_END_PTR:             .rs 0x02 ;0xA097 to A098
BULLET/MINE_SPAWNED_COUNT:               .rs 0x01 ;0xA099
R_A09A_SMARTBOMB_DISABLED:               .rs 0x01 ;0xA09A
HUMANOID_LAST_MARKED_PTR:                .rs 0x02 ;0xA09B to A09C
R_A09D_BULLET_HPOS_IDK:                  .rs 0x02 ;0xA09D to A09E
PTR_TO_A162_POOL:                        .rs 0x02 ;0xA09F to A0A0
SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG:  .rs 0x03 ;0xA0A1 to A0A3
LASER_HOLES_POINTER_ADDR:                .rs 0x02 ;0xA0A4 to A0A5
RANDOM_PALETTE_ROTATION_DEFENDER_LOGO:   .rs 0x02 ;0xA0A6 to A0A7
POOL_A1A2_PTR_MINE_RELATED:              .rs 0x02 ;0xA0A8 to A0A9
R_A0AA_BOMBERS_GROUP_DIR:                .rs 0x01 ;0xA0AA
SRAM_C481_BONUS_SHIP_ADD:                .rs 0x02 ;0xA0AB to A0AC
SOUND_NOT_PLAYING_FLAG:                  .rs 0x01 ;0xA0AD
STARS_NUM_TO_CHANGE?:                    .rs 0x01 ;0xA0AE
REVERSE_BLOCK_FLAG:                      .rs 0x01 ;0xA0AF
SOUND_PLAYING_DATA_PTR:                  .rs 0x02 ;0xA0B0 to A0B1
SOUND_PRIORITY_PLAYING:                  .rs 0x01 ;0xA0B2
SOUND_TIMER_BLOCK_UPDATE:                .rs 0x01 ;0xA0B3
SOUND_TIMER_NEXT_DATA:                   .rs 0x01 ;0xA0B4
LASERS_ONSCREEN_COUNT:                   .rs 0x01 ;0xA0B5
ROTATING_COLOR_INDEX:                    .rs 0x01 ;0xA0B6
GAME_START_ENABLED_FLAG:                 .rs 0x01 ;0xA0B7

	.org $A0BA
A0BA_PLAYER_GAME_STATE:                  .rs 0x01 ;0xA0BA
SHIP_DIRECTION_300/FD00:                 .rs 0x02 ;0xA0BB to A0BC
R_A0BD_UNK_DIR_UNK:                      .rs 0x02 ;0xA0BD to A0BE
SHIP_SCR_POS_XXYY:                       .rs 0x02 ;0xA0BF to A0C0
R_A0C1_SHIP_UNK:                         .rs 0x02 ;0xA0C1 to A0C2
R_A0C3_SHIP_SCR_HPOS?:                   .rs 0x02 ;0xA0C3 to A0C4
SHIP_VPOS:                               .rs 0x02 ;0xA0C5 to A0C6
SCREEN_H_DELTA:                          .rs 0x02 ;0xA0C7 to A0C8
R_A0C9_UNUSED?ONLY_CLEARED:              .rs 0x01 ;0xA0C9
PLAYER_V_MOMENTUM:                       .rs 0x02 ;0xA0CA to A0CB
R_A0CC_SHIP_W_POS?:                      .rs 0x02 ;0xA0CC to A0CD
IDFK_HIT_DETECTED_WRD:                   .rs 0x02 ;0xA0CE to A0CF
R_A0D0_HIT_DETECTED_UNK_1:               .rs 0x02 ;0xA0D0 to A0D1
R_A0D2_HIT_DETECTED_UNK_2:               .rs 0x02 ;0xA0D2 to A0D3
OBJ_HIT_BMP_UNK:                         .rs 0x02 ;0xA0D4 to A0D5
HIT_DETECT_UPPER_LEFT_XXYY:              .rs 0x02 ;0xA0D6 to A0D7
HIT_DETECT_BOTTOM_RIGHT_XXYY:            .rs 0x02 ;0xA0D8 to A0D9
R_A0DA_HIT_DTCT_UNK:                     .rs 0x02 ;0xA0DA to A0DB
R_A0DC_OBJ_DETECTING_HITS_AGAINST_THIS_GFX: .rs 0x02 ;0xA0DC to A0DD
R_A0DE_HUMANOID_KILL_FLAG:               .rs 0x01 ;0xA0DE
A0DF_RAND_BYTE:                          .rs 0x01 ;0xA0DF
A0E0_RAND_WORD:                          .rs 0x02 ;0xA0E0 to A0E1
PARTICLE_SLOT_POINTER:                   .rs 0x02 ;0xA0E2 to A0E3
R_A0E4_PARTICLE_WIDTH_CALC:              .rs 0x01 ;0xA0E4
R_A0E5_PARTICLE_HEIGHT_GROUPS?/2?:       .rs 0x01 ;0xA0E5
R_A0E6_PARTICLE_EXP_DIR?UNK?:            .rs 0x01 ;0xA0E6
R_A0E7_PARTICLE_SETTING?MULTIPLIER?:     .rs 0x01 ;0xA0E7
R_A0E8_PARTICLE_SETTINGS_DOUBLED:        .rs 0x01 ;0xA0E8
R_A0E9_PARTICLE_FOCUS/MULTIUSE?:         .rs 0x01 ;0xA0E9
R_A0EA_PARTICLE_UNK:                     .rs 0x01 ;0xA0EA
R_A0EB_PARTICLE_VMOD:                    .rs 0x01 ;0xA0EB
R_A0EC_PARTICLE_UNK:                     .rs 0x01 ;0xA0EC
R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL:   .rs 0x02 ;0xA0ED to A0EE
R_A0EF_PARTICLE_CODE_PTR:                .rs 0x02 ;0xA0EF to A0F0
R_A0F1_PARTICLE_WIDTH_TODO:              .rs 0x01 ;0xA0F1
R_A0F2_PARTICLE_HEIGHT_TODO:             .rs 0x01 ;0xA0F2
R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP:     .rs 0x02 ;0xA0F3 to A0F4
R_A0F5_PARTICLE_ADDED_TO_BMP_PTR?:       .rs 0x01 ;0xA0F5
R_A0F6_PARTICLE_PTR_STORE?:              .rs 0x02 ;0xA0F6 to A0F7
R_A0F8_PARTICLE_CENTRAL_POINT:           .rs 0x02 ;0xA0F8 to A0F9
A0FA_HUMANOID_COUNT:                     .rs 0x01 ;0xA0FA
R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT?:     .rs 0x01 ;0xA0FB
R_A0FC_BOMBERS_TO_MAKE:                  .rs 0x01 ;0xA0FC
R_A0FD_PODS_TO_MAKE:                     .rs 0x01 ;0xA0FD
R_A0FE_ENEMY_MUTANT_COUNT?:              .rs 0x01 ;0xA0FE
R_A0FF_SWARMERS_IN_POD_IDK:              .rs 0x01 ;0xA0FF
EXTRA_WAVE_SPAWN_REFRESH:                .rs 0x01 ;0xA100
R_A101_MUTANT_RELATED?_UNK:              .rs 0x01 ;0xA101
R_A102_LANDER_ATTR_SPEED:                .rs 0x01 ;0xA102
R_A103_LANDER_VSPEED:                    .rs 0x02 ;0xA103 to A104
R_A105_MAX_BULLET_TIMER_LANDER:          .rs 0x01 ;0xA105
R_A106_BOMBERS_SPEED:                    .rs 0x01 ;0xA106
R_A107_UNK_ENEMY_VSPEED_MODIFY_BAITER?:  .rs 0x01 ;0xA107
R_A108_BAITER_VSPEED_BASE?:              .rs 0x02 ;0xA108 to A109
R_A10A_MUTANT_HSPEED?:                   .rs 0x01 ;0xA10A
R_A10B_BAITER|MUTANT_SHOOT_TIMER:        .rs 0x01 ;0xA10B
R_A10C_SWARMER_HSPEED_BASE:              .rs 0x01 ;0xA10C
R_A10D_SWARMER_CALLBACK[11]_UNK:         .rs 0x01 ;0xA10D
R_A10E_SWARMER[9]AND_VAL:                .rs 0x01 ;0xA10E
BAITER_SPAWN_RELOAD:                     .rs 0x01 ;0xA10F
R_A110_BAITER_SHOOT_COUNTDOWN_MAX?:      .rs 0x01 ;0xA110
R_A111_BAITER_MOVE_ODDS?:                .rs 0x01 ;0xA111
R_A112_LANDER_COUNT?:                    .rs 0x01 ;0xA112
R_A113_BOMBER_ALIVE_COUNT?:              .rs 0x01 ;0xA113
R_A114_PODS_ALIVE_COUNT?:                .rs 0x01 ;0xA114
R_A115_MUTANT_ALIVE_COUNT?:              .rs 0x01 ;0xA115
R_A116_SWARMERS_ALIVE_COUNT?:            .rs 0x01 ;0xA116
EXTRA_WAVE_SPAWN_TIMER:                  .rs 0x01 ;0xA117
BAITER_TIMER:                            .rs 0x01 ;0xA118
R_A119_BAITER_ALIVE_COUNT:               .rs 0x01 ;0xA119

	.org $A162
POOL_A162_TO_A182/DRAW_CMD_TMP?:         .rs 0x21 ;0xA162 to A182

	.org $A163
DRAW_COUNTER_ACTUAL:                     .rs 0x01 ;0xA163
R_A164_HIGHSCORE_DATA_POS:               .rs 0x02 ;0xA164 to A165
DRAW_PIXEL_POS_XXYY:                     .rs 0x02 ;0xA166 to A167
R_A168_COPY_PROTECTION_6245_VAL:         .rs 0x02 ;0xA168 to A169
HANDWRITING_DRAW_STEPS:                  .rs 0x01 ;0xA16A
HANDWRITING_WILLIAMS_DATA_PTR:           .rs 0x02 ;0xA16B to A16C
LOGO_PARTICLES_PTR_A:                    .rs 0x02 ;0xA16D to A16E
LOGO_PARTICLES_PTR_B:                    .rs 0x02 ;0xA16F to A170
LOGO_PARTICLES_VAL_UNK:                  .rs 0x02 ;0xA171 to A172
LOGO_PARTICLES_PTR_C:                    .rs 0x02 ;0xA173 to A174
DEFENDER_LOGO_USED_TO_STORE_VAR:         .rs 0x01 ;0xA175
R_LOGO_PAIR_UPPER:                       .rs 0x01 ;0xA176
R_LOGO_PAIR_LOWER:                       .rs 0x01 ;0xA177
R_A178_LEAVE_INITIAL_FLAG?:              .rs 0x01 ;0xA178
PREV_CHAR_MOVEMENT:                      .rs 0x01 ;0xA179
INITIAL_POS_INDEX:                       .rs 0x01 ;0xA17A
R_A17B_PLAYER_DATA_PTR_SCR+INITIALS:     .rs 0x02 ;0xA17B to A17C
INITIAL_ENTER_TIMER?:                    .rs 0x01 ;0xA17D
R_A17E_INITIAL_TIMER_RELATED?UNK:        .rs 0x01 ;0xA17E
R_A17F_INITIAL_TIMER?:                   .rs 0x01 ;0xA17F

	.org $A181
R_A181_HIGHSCORE_SCR_POS:                .rs 0x02 ;0xA181 to A182
PLAY_CREDITS_ATTRACT_START_VALUE_COPY:   .rs 0x01 ;0xA183
ATTRACT_GOTO_DEMO_FLAG:                  .rs 0x01 ;0xA184
R_A185_INITIAL_TIMER_LARGE:              .rs 0x01 ;0xA185
R_A186_INITIAL_TIMER_FINE:               .rs 0x01 ;0xA186
R_A187_OBJ_TMP_LASER_PTR?:               .rs 0x02 ;0xA187 to A188
R_A189_OBJ_PTR_HUMANOID?:                .rs 0x02 ;0xA189 to A18A
R_A18B_OBJ_PTR_SHIP?:                    .rs 0x02 ;0xA18B to A18C
R_A18D_OBJ_PTR_ENEMY?:                   .rs 0x02 ;0xA18D to A18E
R_A18F_HUMANOID_LOOP_COUNTER:            .rs 0x01 ;0xA18F
R_A190_OBJ_PTR_INIT_LANDER/SCORE?:       .rs 0x02 ;0xA190 to A191
R_A192_OBJ_PTR_SCRATCH:                  .rs 0x02 ;0xA192 to A193
DEMO_LASER_START_POS:                    .rs 0x02 ;0xA194 to A195
R_A196_ATTRACT_TEXT_CURRENT:             .rs 0x02 ;0xA196 to A197
R_A198_ATTRACT_NEXT_PTR:                 .rs 0x02 ;0xA198 to A199

	.org $A1C6
R_A1C6_SRAM_C481_P1_NEXT_SHIP:           .rs 0x02 ;0xA1C6 to A1C7
R_A1C8_ONLY_EVER_CLEARED?UNK:            .rs 0x01 ;0xA1C8
R_A1C9_P1_SHIPS:                         .rs 0x01 ;0xA1C9

	.org $A1CB
R_A1CB_P1_SMARTBOMBS:                    .rs 0x01 ;0xA1CB

	.org $A206
R_A206_P2_SHIPS:                         .rs 0x01 ;0xA206

	.org $A208
R_A208_P2_SMARTBOMBS:                    .rs 0x01 ;0xA208


;Program ROM code

;Laid out as:
;	0xD000-0xFFFF
;	0xC000 Bank 1
;	0xC000 Bank 2
;	0xC000 Bank 3
;	0xC000 Bank 7

	.org $D000

    DECA ; ROM check adjust bte?
SET_UP_CALLBACK_IN_CURRENT_CALLBACK: ; 0x000001, $D001
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load U from
    STA   4,U ; OBJ[4], Countdown to handler, ticks.
    STX   2,U ; OBJ[2], Handler
    JMP   U=U.NEXT,HANDLE_CALLBACK
CALLBACK_TASK_REMOVE: ; 0x00000A, $D00A
    LDX   R_A063_CALLBACK_LIST/CURRENT ; X from callback list.
    BSR   XOBJ_REMOVED_FROM_CALLBACKS ; Remove from all obj list.
    LEAU  X ; U is X obj, A05F->next.next?
    JMP   U=U.NEXT,HANDLE_CALLBACK ; Goto U handle.
REMOVE_CALLBACK_ATTACHED_TO_XOBJ: ; 0x000013, $D013
    LDX   6,X ; X from OBJ[6]
XOBJ_REMOVED_FROM_CALLBACKS: ; 0x000015, $D015
    PSHS  U,B,A ; Save what we clobber.
    LDU   #$A05F ; Load list callbacks.
OBJX_REMOVE_FROM_ULIST_TO_AVAILABLE: ; 0x00001A, $D01A
    CMPX  U ; If X _ U.Next
    BNE   U_TO_NEXT ; !=, goto. Order: U -> X -> U->next.next/X.next
    LDD   X ; D = X.next
    STD   U ; Move to U.next. X now removed from order
    LDA   6,X ; Get data in OBJ[6]
    BEQ   OBJ_SIZE_15B ; If OBJ[6] = 0, put back to 15B list.
    LDD   LIST_23B_CALLBACKS_AVAILABLE_SMALL ; D = List obj
    STX   LIST_23B_CALLBACKS_AVAILABLE_SMALL ; Replace OBJ with X
    BRA   X.NEXT_FROM_REPLACED ; goto
OBJ_SIZE_15B: ; 0x00002C, $D02C
    LDD   LIST_15B_CALLBACKS_AVAILABLE ; Load list obj
    STX   LIST_15B_CALLBACKS_AVAILABLE ; Replace OBJ with X
X.NEXT_FROM_REPLACED: ; 0x000030, $D030
    STD   X ; Replaced obj is new head's .next
    LEAX  U ; X is original U->next.next, continuing passed list.
    PULS  A,B,U,PC ; RTS
U_TO_NEXT: ; 0x000036, $D036
    LDU   U ; U=U.next, next list item.
    BNE   OBJX_REMOVE_FROM_ULIST_TO_AVAILABLE ; if U != NULL, continue search.
SYSTEM_PANIC: ; 0x00003A, $D03A
    NOP ; Weird NOP.
    JMP   DEFENDER_GAME_INIT,ATTRACT ; Assume crash?
SCHEDULE_23B_CALLBACK_TYPE=A_CB=X_NEXT_TICK: ; 0x00003E, $D03E
    PSHS  U,Y,A ; Save
    LDU   LIST_23B_CALLBACKS_AVAILABLE_SMALL ; Get head obj.
    BNE   U_!NULL ; If list has obj. Unintentional jump into inst? Mistake.
    .db $BD ; JSR SYSTEM_PANIC
U_!NULL: ; 0x000045, $D045
    SUBB  R_A03A_MENU_UNK ; SUBB $DP3A
    LDY   U ; Get Y from U.next
    STY   LIST_23B_CALLBACKS_AVAILABLE_SMALL ; New head, U is detatched from list.
    LDA   #$01
    STA   6,U ; OBJ[6] flag.
    LDA   S ; Get A from stack.
    BRA   SCHEDULE_OBJ@U_TO_A063_PTR ; Goto
SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X: ; 0x000055, $D055
    PSHS  U,Y,A ; Save
    LDU   LIST_15B_CALLBACKS_AVAILABLE ; Load PTR
    BNE   PTR_NOT_NULL ; If valid, go here. Should have done BEQ PANIC instead.
    JSR   SYSTEM_PANIC ; Reboot.
PTR_NOT_NULL: ; 0x00005E, $D05E
    LDY   U ; Y = U.next
    STY   LIST_15B_CALLBACKS_AVAILABLE ; Store. U is now removed from this list.
    CLR   6,U ; Clear OBJ[6], 15B.
SCHEDULE_OBJ@U_TO_A063_PTR: ; 0x000066, $D066
    STX   2,U ; X passed to OBJ[2], handler.
    STA   5,U ; A passed to OBJ[5], type.
    LDA   #$01
    STA   4,U ; To OBJ[4], run next tick.
    LDX   [R_A063_CALLBACK_LIST/CURRENT] ; X = $A063->ROOT.next
    STU   [R_A063_CALLBACK_LIST/CURRENT] ; Attach new $A063->LIST_ROOT_OBJ
    STX   U ; Link original list entry to new ROOT.next
    LEAX  U ; X is now our new obj. Circular insert complete.
    PULS  A,Y,U,PC ; RTS
DESCHEDULE_CALLBACKS_NOT_TYPE_2: ; 0x00007C, $D07C
    PSHS  X,A ; Save
    LDX   #$A05F ; List start.
X_TO_X.NEXT: ; 0x000081, $D081
    LDX   X ; Get .next
    BEQ   RTS ; If NULL, leave.
    CMPX  R_A063_CALLBACK_LIST/CURRENT ; CMP X to this ptr.
    BEQ   X_TO_X.NEXT ; If match, don't want to sort, this is what is being used/called already.
    LDA   5,X ; Load OBJ[5]
    CMPA  #$02 ; If OBJ[5] _ #$02
    BEQ   X_TO_X.NEXT ; ==, keep going.
    BSR   XOBJ_REMOVED_FROM_CALLBACKS ; Delete
    BRA   X_TO_X.NEXT ; Always traverse again.
RTS: ; 0x000093, $D093
    PULS  A,X,PC ; RTS
23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS: ; 0x000095, $D095
    BSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get obj in X
    PSHS  U,Y,B,A ; Save to sys
    STU   6,X ; U to OBJ[6], callback?
    LDU   6,S ; Load JSR location.
    PULU  A,B,Y ; Pull from loaded ptr
    STD   2,X ; JSR[0] TO XOBJ[2], GFX_DATA_PTR
    STY   8,X ; JSR[2] to XOBJ[8], HIT_HANDLER
    PULU  A,B ; Pull from U
    STD   18,X ; JSR[4] to XOBJ[18], SCANNER_PIXELS
    STU   6,S ; Store next instruction for RST past table.
    PULS  A,B,Y,U,PC ; RTS, restore.
LIST_GET_23B_ADDED_TO_INWORLD: ; 0x0000AD, $D0AD
    PSHS  U,B,A ; Save
    LDX   LIST_23B_LARGE_POOL ; Get obj
    BNE   VALID_OBJ ; If valid, goto.
    JSR   SYSTEM_PANIC ; Reboot.
VALID_OBJ: ; 0x0000B6, $D0B6
    LDD   X ; Get X.next
    STD   LIST_23B_LARGE_POOL ; Store to list. X now not in list.
    LDD   LIST_IN_WORLD ; Get other list obj
    STD   X ; Store LIST_$65 to X.next
    CLRA ; CLRD
    CLRB
    STD   4,X ; OBJ[4] cleared
    STA   20,X ; OBJ[20] cleared
    PULS  A,B,U,PC ; RTS
REMOVE_X_FROM_LIST_ONSCREEN/OFFSCREEN: ; 0x0000C7, $D0C7
    PSHS  U,Y,X ; Save
    LDU   #$A065 ; Onscreen list.
CMP_NEXT_LOOP_ON/OFF_SCREEN: ; 0x0000CC, $D0CC
    CMPX  U ; CMP X to U.next
    BNE   X_NOT_NEXT ; X not next
REMOVE_U.NEXT: ; 0x0000D0, $D0D0
    LDY   [U] ; Get Obj->Obj.next
    STY   U ; Store to U.next, removing X.
    LDY   LIST_23B_LARGE_POOL ; Remember old head
    STX   LIST_23B_LARGE_POOL ; store removed to loc
    STY   X ; Store remembered to new.next
    PULS  X,Y,U,PC ; RTS
X_NOT_NEXT: ; 0x0000E0, $D0E0
    LDU   U ; U = U.next
    BNE   CMP_NEXT_LOOP_ON/OFF_SCREEN ; If valid, try.
    LDU   #$A06B ; Try other list, LIST_OFFSCREEN
CMP_NEXT_LOOP_GENERIC: ; 0x0000E7, $D0E7
    CMPX  U ; Is X _ U.next
    BEQ   REMOVE_U.NEXT ; If =, remove.
    LDU   U ; U = U.next
    BNE   CMP_NEXT_LOOP_GENERIC ; loop
    JSR   SYSTEM_PANIC ; Do this
REMOVE_X_FROM_LIST_BULLETS: ; 0x0000F2, $D0F2
    PSHS  U,Y,X ; Save
    LDU   #$A06D ; List ptr, bullets.
    BRA   CMP_NEXT_LOOP_GENERIC ; Goto
    PSHS  X,DP ; Save...
    STS   SMASH_S_SAVE_AND_TEMP ; Store stack
    BCC   EVEN_BITMAP
    LEAY  2,Y ; Odd ptr.
EVEN_BITMAP: ; 0x000102, $D102
    LDS   2,Y ; Get S from Y+2, BMP_DATA PTR
    ADDB  #$08 ; Add height
    TFR   D>U ; D is location?
    BRA   GFX_MOVE_4X8
    PSHS  X,DP ; Save
    ADDB  #$08 ; Height
    TFR   D>U ; Pos to U
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear Y
    TFR   A>DP ; Clear
    ANDCC #$00 ; Clear
    BRA   GFX_SET_4X8 ; Set to clear
    PSHS  X,DP ; Save
    ADDB  #$08 ; Add height
    TFR   D>U ; Pos to U
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    TFR   A>DP ; Clear
    ANDCC #$00 ; Clear
    PSHU  Y,X,DP,B,A,CC ; Clear, 10X8?
    LEAU  264,U ; POSX++
    BRA   GFX_SET_8X8 ; Do rest
    PSHS  X,DP ; Save
    STS   SMASH_S_SAVE_AND_TEMP ; Save
    BCC   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000142, $D142
    LDS   2,Y ; Stack from Y+2
    ADDB  #$08 ; Height
    TFR   D>U ; Pos to U
GFX_MOVE_8X8: ; 0x000149, $D149
    PULS  CC,A,B,DP,X,Y
    PSHU  Y,X,DP,B,A,CC
    LEAU  264,U ; POSX++
    PULS  CC,A,B,DP,X,Y
    PSHU  Y,X,DP,B,A,CC
    LEAU  264,U ; POSX++
GFX_MOVE_4X8: ; 0x000159, $D159
    PULS  CC,A,B,DP,X,Y ; Pull 8 bytes. Stack goes up
    PSHU  Y,X,DP,B,A,CC ; Push 8 bytes. 8 vertical, 2 wide. Goes down, hence add >256.
    LEAU  264,U ; Next column, same pos.
    PULS  CC,A,B,DP,X,Y ; Pull 8 bytes.
    PSHU  Y,X,DP,B,A,CC ; Push 8 bytes.
    LDS   SMASH_S_SAVE_AND_TEMP ; Get S
    PULS  DP,X,PC ; RTS
    PSHS  X,DP ; Save
    ADDB  #$08 ; Voff for stack move.
    TFR   D>U ; Screen pos to U
    LDD   #$0000 ; Clear pixels.
    LDX   #$0000
    LEAY  X ; Move X to Y
    TFR   A>DP ; Clear
    ANDCC #$00 ; Clear
GFX_SET_8X8: ; 0x00017D, $D17D
    PSHU  Y,X,DP,B,A,CC ; Push 8x2
    LEAU  264,U ; X++
    PSHU  Y,X,DP,B,A,CC ; Push 8X4
    LEAU  264,U ; X++
GFX_SET_4X8: ; 0x000189, $D189
    PSHU  Y,X,DP,B,A,CC
    LEAU  264,U ; X++
    PSHU  Y,X,DP,B,A,CC
    PULS  DP,X,PC ; RTS
    PSHS  X,DP ; Save
    STS   SMASH_S_SAVE_AND_TEMP ; Save
    BCC   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x00019C, $D19C
    LDS   2,Y ; Get stack from Y+2
    ADDB  #$08 ; Adjust Y pos.
    TFR   D>U ; Pos to U
    PULS  CC,A,B,DP,X,Y ; Pull 8 bytes.
    PSHU  Y,X,DP,B,A,CC ; Push to screen.
    LEAU  264,U ; POSX++
    BRA   GFX_MOVE_8X8 ; This is basically 10x8.
    BCC   SKIP_Y+=2 ; Bullets?
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x0001B1, $D1B1
    LDY   2,Y ; Add 2...
    TFR   D>U ; Screen pos to U?
    LDD   Y ; D from Y
    STD   U ; D to SCR
    LDD   2,Y ; D to SCRY+2
    STD   2,U
    LDD   4,Y ; D to SCY+4
    STD   256,U ; SCRX+1
    LDD   6,Y
    STD   258,U ; SCRX+1,SCRY+2
    LDD   8,Y
    STD   512,U ; SCRX+2
    LDD   10,Y
    STD   514,U ; SCRX+2,SCRY+2
    RTS ; RTS
    TFR   D>U ; POS to U
    LDD   #$0000 ; Clear
    STD   U ; SCR
    STD   2,U ; SRCY+2
    STD   256,U ; SCRX+1
    STD   258,U ; SCRX+1,SCRY+2
    STD   512,U ; SCRX+2
    STD   514,U ; SCRX+2,SCRY+2
    RTS ; RTS
    BCC   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x0001F5, $D1F5
    LDY   2,Y ; Y+=2
    TFR   D>U ; Screen pos?
    LDD   Y ; Get graphics
    STD   U ; Store to screen
    LDD   2,Y
    STA   2,U ; SCRY+2
    STB   256,U ; SCRX+1
    LDD   4,Y
    STD   257,U ; SCRX+1,Y+2
    RTS ; Leave
    TFR   D>U ; Screen pos?
    LDD   #$0000 ; Clear
    STD   U ; Store SCR
    STA   2,U ; SCRY+2
    STD   256,U ; SCRX+1
    STA   258,U ; SCRX+1,SCRY+2.
    RTS ; RTS
    PSHS  U,X,B,A ; Save
    STS   SMASH_S_SAVE_AND_TEMP ; Save
    BCC   SKIP_Y+=2 ; Do
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000228, $D228
    LDS   2,Y ; S=Y+2
    ADDB  #$04 ; Correct height.
    TFR   D>U ; Screen pos.
    PULS  A,B,X ; Get graphics.
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get graphics.
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LDS   SMASH_S_SAVE_AND_TEMP ; Load stack
    PULS  A,B,X,U,PC ; RTS
    PSHS  U,X,B,A ; Save
    ADDB  #$04 ; Correct pos.
    TFR   D>U ; Pos
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    PSHU  X,B,A ; 4 bytes.
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes.
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes.
    PULS  A,B,X,U,PC ; RTS
GFX_16X6_MOVE+ADJUST: ; 0x00028E, $D28E
    PSHS  X ; Save
    STS   SMASH_S_SAVE_AND_TEMP ; Save
    BCC   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000297, $D297
    LDS   2,Y ; Get S from Y+2
    ADDB  #$06 ; Height
    TFR   D>U ; To SCR
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put 8
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
GFX_12X6_MOVE: ; 0x0002AE, $D2AE
    PULS  A,B,X,Y ; Get 6w
    PSHU  Y,X,B,A ; Put 6
    LEAU  262,U ; X+1
GFX_10X6_MOVE: ; 0x0002B6, $D2B6
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put 5
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LDS   SMASH_S_SAVE_AND_TEMP ; Restore
    PULS  X,PC ; RTS
GFX_CLEAR_16X6: ; 0x0002DF, $D2DF
    PSHS  X ; Save
    ADDB  #$06 ; Height
    TFR   D>U ; Pos
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    PSHU  Y,X,B,A ; Clear 8w
    LEAU  262,U ; X+1
    PSHU  Y,X,B,A ; Clear
    LEAU  262,U ; X+1
GFX_CLR_12X6: ; 0x0002F9, $D2F9
    PSHU  Y,X,B,A ; Clear
    LEAU  262,U ; X+1
GFX_CLR_10X6: ; 0x0002FF, $D2FF
    PSHU  Y,X,B,A ; Clear
    LEAU  262,U ; X+1
    PSHU  Y,X,B,A
    LEAU  262,U
    PSHU  Y,X,B,A
    LEAU  262,U
    PSHU  Y,X,B,A
    LEAU  262,U
    PSHU  Y,X,B,A
    PULS  X,PC ; RTS
    PSHS  X ; Save
    STS   SMASH_S_SAVE_AND_TEMP ; Save
    BCC   SKIP Y+=2
    LEAY  2,Y ; Y+=2
SKIP Y+=2: ; 0x000324, $D324
    LDS   2,Y ; S+=2
    ADDB  #$06 ; Add height
    TFR   D>U ; Pos
    BRA   GFX_10X6_MOVE ; Move
    PSHS  X ; Save
    ADDB  #$06 ; Height
    TFR   D>U ; Pos
    LDD   #$0000 ; Clear
    LDX   #$0000
    LEAY  X ; Clear
    BRA   GFX_CLR_10X6 ; Do
    PSHS  X ; Save
    STS   SMASH_S_SAVE_AND_TEMP ; Save
    BCC   SKIP_Y+=2 ; Skip
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000346, $D346
    LDS   2,Y ; S = Y+2
    ADDB  #$06 ; Height
    TFR   D>U ; POS
    JMP   GFX_12X6_MOVE ; Move
GFX_CLEAR_12X6: ; 0x000350, $D350
    PSHS  X ; Save
    ADDB  #$06 ; Adj height
    TFR   D>U ; To POS
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    BRA   GFX_CLR_12X6 ; Do.
SCORE_ADD_AB_SETTINGS: ; 0x000360, $D360
    PSHS  U,Y,X,B,A ; Save
    ORCC  #$01 ; Set CC.c
    ROL   R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT? ; Flag?
    LSRA ; If 1 if shifted off, multiplies value passed by 10
    PSHS  A ; Save pos.
    LDA   #$00 ; Clear upper.
    BCC   SKIP_MUL_BY_10 ; If A was odd, take.
    ASLB ; D << 4, all chars one pos up.
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
SKIP_MUL_BY_10: ; 0x000375, $D375
    JSR   GET_PLAYER_PTR_IN_X_FROM_A08B ; Player 1 or 2?
    STD   A073_SCRATCHPAD_ADDR ; Store val to add to scratch.
    LDB   #$03 ; Load B with greatest score index.
    SUBB  S+ ; Sub B from on stack, aka where to place value.
    LDA   B,X ; Get score place.
    ADDA  A073_SCRATCHPAD_ADDR+1 ; Add with lower.
    DAA ; Dec adjust.
    STA   B,X ; Store back.
    DECB ; B-=1
    BMI   TEST_BONUS_SHIP+SMARTBOMB ; If negative, skip carry up routine.
LOOP_CARRY_SCORE_OVERFLOW_UP: ; 0x000388, $D388
    LDA   B,X ; Get score place.
    ADCA  A073_SCRATCHPAD_ADDR ; Add with carry to higher.
    DAA ; Adjust
    STA   B,X ; Store back.
    LDA   #$00
    STA   A073_SCRATCHPAD_ADDR ; Clear val?
    DECB ; Minus index.
    BPL   LOOP_CARRY_SCORE_OVERFLOW_UP ; If still not negative, loop.
TEST_BONUS_SHIP+SMARTBOMB: ; 0x000396, $D396
    LDD   SRAM_C481_BONUS_SHIP_ADD ; Get D
    BEQ   DONT_AWARD_EXTRA_SHIP ; D is 0, never extra ships.
    LEAX  1,X ; PLAYER PTR += 1
    LEAY  3,X ; Y = X+3
    BSR   TEST_IF_AWARD_EXTRA_SHIP
    BCS   DONT_AWARD_EXTRA_SHIP ; If last CMP SCORE_0000XX<CMP, goto.
    LDA   1,Y ; Get current extra ship score 00XX00
    ADDA  SRAM_C481_BONUS_SHIP_ADD+1 ; Add with sram val
    DAA ; Adjust
    STA   1,Y ; Store back
    LDA   Y ; Get current extra schip score XX0000
    ADCA  SRAM_C481_BONUS_SHIP_ADD ; Add with sram val.
    DAA ; Adjust
    STA   Y ; Store back. Contains next score to give a ship if above.
    INC   6,X ; Inc ships, PLAYER[6+1], PLAYER[7]
    INC   8,X ; Inc smartbombs, PLAYER[8+1], PLAYER[9]
    JSR   DISP_SHIPS_ALL_PLAYERS ; Update UI
    JSR   SMARTBOMBS_TO_SCREEN
    LDD   #$D4B0 ; Sound.
    JSR   SOUND_SET_SOUND_PRIORITIED
    LDB   #$05 ; Score keep entry.
    JSR   GOTO_B3-C00F_BOOKKEEP_UPDATE_+1 ; Track
DONT_AWARD_EXTRA_SHIP: ; 0x0003C5, $D3C5
    BSR   CURRENT_PLAYER_SCORE_TO_SCREEN
    PULS  A,B,X,Y,U ; Why not also pull PC???
    RTS ; Ugh
TEST_IF_AWARD_EXTRA_SHIP: ; 0x0003CA, $D3CA
    PSHS  B,A ; Save
    LDD   X ; Load D from X
    CMPD  Y ; Compare to Y
    BNE   RTS ; RTS, figured. BCC here would fix bug?
    LDA   2,X ; Compare score digits 2 instead.
    CMPA  2,Y ; Compare
RTS: ; 0x0003D7, $D3D7
    PULS  A,B,PC ; RTS, Code handles next branch.
CURRENT_PLAYER_SCORE_TO_SCREEN: ; 0x0003D9, $D3D9
    LDA   A08B_CURRENT_PLAYER ; Load val
PLAYER_PASSED_SCORE_TO_SCREEN: ; 0x0003DB, $D3DB
    PSHS  A ; Use passed value.
    DECA ; Dec val
    BNE   PLAYER_TWO_HANDLER ; Do player 2.
    LDX   #$0F1C ; Pos
    LDU   #$A1C3 ; Data ptr
    BRA   USE_REGS ; Use these.
PLAYER_TWO_HANDLER: ; 0x0003E8, $D3E8
    LDX   #$711C ; Pos
    LDU   #$A200 ; Data ptr
USE_REGS: ; 0x0003EE, $D3EE
    CLR   A073_SCRATCHPAD_ADDR ; Clear displayed flag.
    LDB   #$06 ; Digit count?
    LDA   CURRENT_BANK ; Save bank.
    PSHS  A ; To stack
    LDA   #$02 ; Switch to bank.
    STA   CURRENT_BANK ; Commit
    STA   BANKSWITCH
LOOP_MORE_DIGITS: ; 0x0003FD, $D3FD
    LDA   U+ ; Get A from U.
    LDY   PALETTE_ENTRY_0x0 ; Get Y val from here, 0xC5something
    BITB  #$01 ; Test if we're high/low nibble.
    BNE   USING_LOW_NIBBLE ; Odd doesn't need shifted, skip code below.
    LEAU  -1,U ; Reset
    LSRA ; Shift high nibble low.
    LSRA
    LSRA
    LSRA
USING_LOW_NIBBLE: ; 0x00040D, $D40D
    ANDA  #$0F ; Isolate. This code basically enables zeros after a valid digit.
    BNE   DIGIT_TO_SCREEN ; If != 0
    CMPB  #$02 ; If B _ 2
    BLS   DIGIT_TO_SCREEN ; <=, go. Always show 2 chars.
    TST   A073_SCRATCHPAD_ADDR ; Test if went before.
    BNE   DIGIT_TO_SCREEN ; If did, go again.
    EXG   X-D ; Location to D?
    JSR   GFX_BANK2_CHR_CLEAR ; Clear char.
    BRA   SCORE_CHR_POST ; Done, post put rtn.
DIGIT_TO_SCREEN: ; 0x000420, $D420
    INC   A073_SCRATCHPAD_ADDR ; Since taken, always do.
    ASLA ; *2
    ASLA ; *4, because target fmt is [B,B,W]
    LEAY  A,Y ; Add A to Y
    EXG   X-D ; Loc to D.
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Score digit.
SCORE_CHR_POST: ; 0x00042B, $D42B
    EXG   X-D ; Put loc back to X. Should have ADDA #$04 here instead. Lowkey mistake.
    LEAX  1024,X ; X+=4
    DECB ; Dec digits left.
    BNE   LOOP_MORE_DIGITS ; Do more.
    PULS  A ; Pull bank.
    STA   CURRENT_BANK ; Restore.
    STA   BANKSWITCH
    PULS  A,PC ; RTS
COINDOOR_CALLBACK_3: ; 0x00043D, $D43D
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BPL   JMP_REMOVE_CALLBACK_TASK ; If positive, ignore this.
    JSR   BANKSWITCH_TO_3 ; Switch to bank 3..
    JSR   JMP_TO_HIGHSCORES_TO_RAM ; High scores to RAM.
    INC   POOL_A162_TO_A182/DRAW_CMD_TMP? ; Inc
    BRA   JMP_REMOVE_CALLBACK_TASK ; goto.
COIN_DOOR_CALLBACK_IDK: ; 0x00044C, $D44C
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BPL   JMP_REMOVE_CALLBACK_TASK ; If positive, remove task.
    ORCC  #$90 ; Set entire, mask IRQ.
    CLR   BANKSWITCH ; IO bank.
    LDA   #$04 ; REG:IO
    STA   PIA_ROM_CTRL_B ; Store to CTRL.
    LDA   PIA_ROM_DATA_B ; Get. Idk why
    JSR   BANKSWITCH_TO_3 ; Goto bank 3, menu routines.
    LDA   PIA_ROM_DATA_A_RAM_COPY ; Get
    LSRA ; Shift.
    BCS   GOTO_SETTINGS_MENU? ; If shifted off 1,do this instead.
    JMP   JMP_FAILED_W/_AUTO_NOT_PRESSED ; Goto.
GOTO_SETTINGS_MENU?: ; 0x000468, $D468
    JMP   JMP_SETTINGS_MENU? ; Goto.
JMP_REMOVE_CALLBACK_TASK: ; 0x00046B, $D46B
    JMP   CALLBACK_TASK_REMOVE ; Remove task.
COINDOOR_CALLBACK_4: ; 0x00046E, $D46E
    LDX   #$A07F ; Ptr
    LDB   #$12 ; C012
    BRA   USE_XB_PROVIDED
COINDOOR_CALLBACK_2: ; 0x000475, $D475
    LDX   #$A080 ; PTR
    LDB   #$15 ; C015
    BRA   USE_XB_PROVIDED
COINDOOR_CALLBACK_5: ; 0x00047C, $D47C
    LDX   #$A081 ; Ptr
    LDB   #$18 ; C018
USE_XB_PROVIDED: ; 0x000481, $D481
    LDA   SLAM_TIMER ; Get val
    BNE   JMP_REMOVE_CALLBACK_TASK ; If != 0, goto.
    LDA   X ; Get val from ptr.
    BNE   JMP_REMOVE_CALLBACK_TASK ; If != 0, goto.
    LDA   #$16 ; Idk val.
    STA   X ; Store to ptr. Sets coin accept timers.
    LDA   #$C0 ; Val
    STD   9,U ; Store coin slot callback.
    LDA   #$0A ; Frames, aka give time for slam to be triggered.
    LDX   #$D499 ; Ptr to add credit handler.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup callback.
CALLBACK_ADD_CREDIT?: ; 0x000499, $D499
    LDA   SLAM_TIMER ; Load val.
    BNE   JMP_REMOVE_CALLBACK_TASK ; If set, don't do anything.
    LDD   #$D4AB ; Sound
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play
    JSR   BANKSWITCH_TO_3 ; Switch to menu bank, handles coins.
    JSR   [9,U] ; JSR to coin bookkeep handler.
    BRA   JMP_REMOVE_CALLBACK_TASK ; Remove.
SOUND_REQUEST_DATA: ; 0x0004AB, $D4AB
    .db $FF ; FORMAT: [PRIORITY OF REQUEST], also, REQ. Add credit SND.
    .db $01 ; FORMAT: [TIME_DATA_FWD, TIME_BLOCK_CHANGE, SOUND_VAL]
    .db $18 ; FORMAT: [0x00 = EOF, otherwise rpt prev.]
    .db $19
    .db $00 ; EOF
    .db $FF ; REQ, Bonus ship SND.
    .db $01
    .db $20
    .db $1E
    .db $00 ; EOF
    .db $F0 ; REQ. Dying SND.
    .db $02
    .db $08
    .db $11
    .db $01
    .db $20
    .db $17
    .db $00 ; EOF
    .db $F0 ; REQ
    .db $01
    .db $40
    .db $0A
    .db $00 ; EOF
    .db $F0 ; REQ
    .db $01
    .db $10
    .db $0B
    .db $00 ; EOF
    .db $E8 ; REQ
    .db $01
    .db $04
    .db $14
    .db $02
    .db $06
    .db $11
    .db $02
    .db $0A
    .db $17
    .db $00 ; EOF
    .db $E8 ; REQ
    .db $06
    .db $04
    .db $11
    .db $01
    .db $10
    .db $17
    .db $00 ; EOF
    .db $E0 ; REQ
    .db $03
    .db $0A
    .db $08
    .db $00 ; EOF
    .db $E0 ; REQ
    .db $01
    .db $18
    .db $1F
    .db $00 ; EOF
    .db $E0 ; REQ
    .db $01
    .db $18
    .db $11
    .db $00 ; EOF
    .db $D8 ; REQ
    .db $01
    .db $10
    .db $1A
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $30
    .db $15
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $10
    .db $05
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $08
    .db $17
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $08
    .db $07
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $0A
    .db $01
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $0A
    .db $06
    .db $00 ; EOF
    .db $D0 ; REQ
    .db $01
    .db $10
    .db $0B
    .db $00 ; EOF
    .db $C8 ; REQ
    .db $0A
    .db $01
    .db $0E
    .db $00 ; EOF
    .db $C0 ; REQ
    .db $01
    .db $08
    .db $07
    .db $00 ; EOF
    .db $C0 ; REQ
    .db $01
    .db $30
    .db $14
    .db $00 ; EOF
    .db $C0 ; REQ
    .db $01
    .db $20
    .db $18
    .db $00 ; EOF
    .db $C0 ; REQ
    .db $01
    .db $08
    .db $03
    .db $00 ; EOF
    .db $C0 ; REQ, BULLET.
    .db $01
    .db $30
    .db $09
    .db $00 ; EOF
    .db $C0 ; REQ
    .db $01
    .db $08
    .db $03
    .db $00 ; EOF
    .db $C0 ; REQ
    .db $01
    .db $18
    .db $0C
    .db $00 ; EOF
OUTPUT_B_TO_SOUND_BOARD: ; 0x000539, $D539
    PSHS  B,A,CC ; Save.
    ORCC  #$FF ; Mask IRQ's
    CLR   BANKSWITCH ; IO bank.
    LDA   #$3F ; Write val
    STA   PIA_ROM_DATA_B ; Store to...
    COMB ; Invert B
    ANDB  #$3F ; LED's to 0's, keep data.
    STB   PIA_ROM_DATA_B ; Store to data reg.
    PULS  CC,A,B,PC ; RTS
SOUND_SET_SOUND_PRIORITIED: ; 0x00054D, $D54D
    PSHS  X,B,A,CC ; Save
    CLR   SOUND_NOT_PLAYING_FLAG ; Clear loc.
    TFR   D>X ; X=D
    LDA   X ; Get A from X
    CMPA  SOUND_PRIORITY_PLAYING ; If A _ $A0B2
    BCS   RTS_DENY_SOUND ; <, RTS
    STA   SOUND_PRIORITY_PLAYING ; Store this priority.
    LEAX  -2,X ; Sub 2 from D passed, so forward is onto our data.
    ORCC  #$10 ; Mask IRQ so we won't get taken away.
    STX   SOUND_PLAYING_DATA_PTR ; Store ptr.
    LDD   #$0101 ; Timer vals, sets to update sound.
    STD   SOUND_TIMER_BLOCK_UPDATE ; Set both
RTS_DENY_SOUND: ; 0x000566, $D566
    PULS  CC,A,B,X,PC ; RTS
SOUND_AND_INPUT_MANAGE: ; 0x000568, $D568
    LDA   SOUND_TIMER_BLOCK_UPDATE ; Load timer
    BEQ   CHECK_THRUST_SOUND ; If 0, do thrust.
    DEC   SOUND_TIMER_BLOCK_UPDATE ; Dec if not 0
    BNE   LEAVE_SOUND_DISPATCH ; Don't update anything if timer not done.
    LDX   SOUND_PLAYING_DATA_PTR ; Load sound data ptr.
    DEC   SOUND_TIMER_NEXT_DATA ; Dec timer.
    BNE   PLAY_SOUND_SET_BLOCK_TIMER ; If not 0, keep outputting.
    LEAX  3,X ; To next sound data.
    STX   SOUND_PLAYING_DATA_PTR ; Store new data PTR.
    LDA   X ; Load A from new ptr.
    BNE   PLAY_SOUND_SET_NEXT_DATA_TIMER ; If valid, set.
    STA   SOUND_PRIORITY_PLAYING ; Clear, any sound will replace. Falls through to thrust handling.
CHECK_THRUST_SOUND: ; 0x000580, $D580
    LDA   WGT_DATA_A_RAM_COPY ; Get inputs on wigit A
    BITA  #$02 ; Test thrust pressed
    BNE   THRUST_PRESSED ; Thrust pressed, goto.
    LDA   SOUND_NOT_PLAYING_FLAG ; Test
    BEQ   LEAVE_SOUND_DISPATCH ; If 0, goto.
    CLR   SOUND_NOT_PLAYING_FLAG ; Clear otherwise.
    LDB   #$0F ; Load B
    BRA   PLAY_SOUND_IN_B ; Always goto.
THRUST_PRESSED: ; 0x000590, $D590
    LDA   SOUND_NOT_PLAYING_FLAG ; Load val
    BNE   LEAVE_SOUND_DISPATCH ; If != 0, goto. No request?
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$98 ; Test 1001.1000
    BNE   LEAVE_SOUND_DISPATCH ; If these states, don't do thrust.
    LDB   #$16 ; Load B, space sound/no sound.
    STB   SOUND_NOT_PLAYING_FLAG ; Store as flag, too.
    BRA   PLAY_SOUND_IN_B ; Goto
PLAY_SOUND_SET_NEXT_DATA_TIMER: ; 0x0005A0, $D5A0
    STA   SOUND_TIMER_NEXT_DATA ; Move to next data timer.
PLAY_SOUND_SET_BLOCK_TIMER: ; 0x0005A2, $D5A2
    LDD   1,X ; Get data from X+1
    STA   SOUND_TIMER_BLOCK_UPDATE ; Store A loaded here
PLAY_SOUND_IN_B: ; 0x0005A6, $D5A6
    BSR   OUTPUT_B_TO_SOUND_BOARD ; Write B
LEAVE_SOUND_DISPATCH: ; 0x0005A8, $D5A8
    LDA   PIA_ROM_CTRL_A ; Get CTRL
    BITA  #$40 ; Test C2, SLAM switch
    BEQ   DONT_SEED_SLAM_COUNTER ; If not set, don't seed.
    LDA   #$3C ; Not clear, seed.
    STA   SLAM_TIMER ; Store
DONT_SEED_SLAM_COUNTER: ; 0x0005B3, $D5B3
    LDA   SLAM_TIMER ; Get value
    BEQ   SLAM_TIMER_IS_ZERO ; If 0, goto
    DEC   SLAM_TIMER ; Dec otherwise
SLAM_TIMER_IS_ZERO: ; 0x0005B9, $D5B9
    LDA   COIN_ACCEPT_BLOCK_7F ; Load
    BEQ   COIN_ACCEPT_7F_ZERO ; If 0, goto
    DEC   COIN_ACCEPT_BLOCK_7F ; Dec otherwise.
COIN_ACCEPT_7F_ZERO: ; 0x0005BF, $D5BF
    LDA   COIN_ACCEPT_BLOCK_81 ; Load
    BEQ   COIN_ACCEPT_81_ZERO ; If 0, goto
    DEC   COIN_ACCEPT_BLOCK_81 ; Dec otherwise
COIN_ACCEPT_81_ZERO: ; 0x0005C5, $D5C5
    LDA   COIN_ACCEPT_BLOCK_80 ; Load
    BEQ   COIN_ACCEPT_80_ZERO ; If 0, goto
    DEC   COIN_ACCEPT_BLOCK_80 ; Dec otherwise
COIN_ACCEPT_80_ZERO: ; 0x0005CB, $D5CB
    LDA   WGT_DATA_A_RAM_COPY ; Get newest
    ORA   WGT_DATA_A_RAM_COPY_OLD ; OR with old, setting 1 for all pressed for 2 frames.
    COMA ; Invert, getting eligible for new pressed in A
    LDB   WGT_DATA_A_RAM_COPY ; Newest...
    STB   WGT_DATA_A_RAM_COPY_OLD ; to old
    LDB   PIA_WGT_DATA_A ; Update newest.
    STB   WGT_DATA_A_RAM_COPY
    LDB   PIA_WGT_DATA_B ; Update newest.
    STB   WGT_DATA_B_RAM_COPY
    ANDA  WGT_DATA_A_RAM_COPY ; AND eligible to be newly pressed with updated newest buttons.
    BEQ   CHECK_COINDOOR_INPUT ; No new pressed, do coin door.
    LDU   #$F882 ; Ptr to widget buttons.
FILL_IN_$82-$88: ; 0x0005E5, $D5E5
    CLRB ; Clear
LOOP_ADD_4: ; 0x0005E6, $D5E6
    ADDB  #$04 ; B += 4
    LSRA ; Shift to carry
    BCC   LOOP_ADD_4 ; If C = 0, loop. FIRE4,THRST8,SMART12,HYPER16,2PS20,1PS24,REVRS28,DOWN32
    LEAU  B,U ; U += B
    PULU  A,B,X ; Fill in D,X from U
    LDU   R_A082_BUTTON_PRESSED_PTR_A1 ; Load U from addr
    BNE   STORE_TO_SLOT_B ; If U != 0, goto.
    STD   R_A082_BUTTON_PRESSED_PTR_A1
    STX   R_A084_BUTTON_PRESSED_PTR_A2
    RTS ; Rts
STORE_TO_SLOT_B: ; 0x0005F8, $D5F8
    STD   R_A086_BUTTON_PRESSED_PTR_B1 ; Ret this otherwise.
    STX   R_A088_BUTTON_PRESSED_PTR_B2
    RTS ; Rts
CHECK_COINDOOR_INPUT: ; 0x0005FD, $D5FD
    LDA   PIA_ROM_DATA_A_RAM_COPY ; Load A with all pressed last 2 reads.
    ORA   PIA_ROM_DATA_A_RAM_COPY_OLD
    COMA ; Invert, 1's are newly pressed now.
    LDB   PIA_ROM_DATA_A_RAM_COPY ; Move last to old
    STB   PIA_ROM_DATA_A_RAM_COPY_OLD
    LDB   PIA_ROM_DATA_A ; Get current buttons.
    ANDB  #$3F ; Get only the buttons.
    STB   PIA_ROM_DATA_A_RAM_COPY ; Update this
    BITA  PIA_ROM_DATA_A_RAM_COPY ; Test if any are newly pressed that we need to catch.
    BEQ   RTS ; If no matches on newly pressed.
    LDX   #$0078 ; Time to wait.
WAIT_FOR_X_TO_0: ; 0x000614, $D614
    LEAX  -1,X ; X--
    BNE   WAIT_FOR_X_TO_0 ; Loop
    LDB   PIA_ROM_DATA_A ; Get buttons again.
    ANDB  PIA_ROM_DATA_A_RAM_COPY ; Get bits pressed both times.
    STB   PIA_ROM_DATA_A_RAM_COPY ; Replace
    ANDA  PIA_ROM_DATA_A_RAM_COPY ; See if any buttons newly pressed.
    BEQ   RTS ; No, RTS
    LDU   #$F8A2 ; PTR to data
    BSR   FILL_IN_$82-$88
RTS: ; 0x000628, $D628
    RTS
DISP_SHIPS_ALL_PLAYERS: ; 0x000629, $D629
    PSHS  U,Y,X,B,A ; Save
    LDX   #$0F14 ; Scr pos, X:30,Y14
    LDA   R_A1C9_P1_SHIPS ; Load ship count?
    BSR   DISPLAY_SHIPS ; Disp
    LDA   A08C_CURRENT_PLAYER_COUNT_1/2
    DECA ; See if 1
    BEQ   RTS_SHIPS ; Was 1, leave.
    LDX   #$7114
    LDA   R_A206_P2_SHIPS
    BSR   DISPLAY_SHIPS ; Disp
RTS_SHIPS: ; 0x000640, $D640
    PULS  A,B,X,Y,U,PC ; RTS
DISPLAY_SHIPS: ; 0x000642, $D642
    CMPA  #$05 ; If A _ 5
    BLS   DONT_CAP_COUNT ; <= 5, taken.
    LDA   #$05 ; Cap at 5 ships
DONT_CAP_COUNT: ; 0x000648, $D648
    PSHS  A ; Save val
    LDD   #$2006 ; WWHH, Clear rectangle.
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear it.
    LDA   S ; Get count.
    BEQ   RTS ; Leave if no ships to put on.
    LDY   #$F9D5 ; PTR to CHR
    TFR   X>D ; Position to proper reg.
LOOP_DISPLAY_SHIPS: ; 0x00065A, $D65A
    JSR   GFX_BANK2_CHR_TO_SCREEN
    ADDA  #$06 ; Add X off.
    DEC   S ; One less.
    BNE   LOOP_DISPLAY_SHIPS ; Display loop.
RTS: ; 0x000663, $D663
    PULS  A,PC ; RTS
DISPLAY_SETUP_INGAME: ; 0x000665, $D665
    PSHS  U,Y,X,B,A
    LDD   #$4020 ; POS
    LDX   #$3008 ; XXYY
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear area.
    BSR   DRAW_SCANNER_OUTLINES ; Put scanner to screen.
    BSR   DISP_SHIPS_ALL_PLAYERS ; Ships.
    BSR   SMARTBOMBS_TO_SCREEN ; Smartbombs.
    LDA   A08C_CURRENT_PLAYER_COUNT_1/2 ; Load max player.
SCORE_LOOP: ; 0x000678, $D678
    JSR   PLAYER_PASSED_SCORE_TO_SCREEN ; Put that player to screen.
    DECA
    BNE   SCORE_LOOP ; Loop again to show both.
    PULS  A,B,X,Y,U,PC ; RTS
SMARTBOMBS_TO_SCREEN: ; 0x000680, $D680
    PSHS  U,Y,X,B,A
    LDX   #$291B ; Pos P1
    LDA   R_A1CB_P1_SMARTBOMBS ; Get count.
    BSR   DISPLAY_SMARTBOMBS_SUB
    LDA   A08C_CURRENT_PLAYER_COUNT_1/2 ; Player count
    DECA ; DEC
    BEQ   RTS_SMARTBOMBS ; Is only 1 player, leave.
    LDX   #$8B1B ; Pos P2
    LDA   R_A208_P2_SMARTBOMBS ; Count
    BSR   DISPLAY_SMARTBOMBS_SUB
RTS_SMARTBOMBS: ; 0x000697, $D697
    PULS  A,B,X,Y,U,PC
DISPLAY_SMARTBOMBS_SUB: ; 0x000699, $D699
    CMPA  #$03 ; If A _ 3
    BLS   DONT_CAP_SMARTBOMBS ; <=, skip cap.
    LDA   #$03 ; Cap
DONT_CAP_SMARTBOMBS: ; 0x00069F, $D69F
    PSHS  A ; Save count.
    LDD   #$030B ; Clear WWHH
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear
    LDA   S ; Load count
    BEQ   ALL_SMARTBOMBS_DISPLAYED
    LDY   #$F9D9 ; PTR to BMP for Smartbombs.
    TFR   X>D ; Pos X to correct reg for sub.
LOOP_MORE_SMARTBOMBS: ; 0x0006B1, $D6B1
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Display
    ADDB  #$04 ; Add Y pos.
    DEC   S ; Dec count.
    BNE   LOOP_MORE_SMARTBOMBS
ALL_SMARTBOMBS_DISPLAYED: ; 0x0006BA, $D6BA
    PULS  A,PC
DRAW_SCANNER_OUTLINES: ; 0x0006BC, $D6BC
    LDD   #$5555 ; Load color
    LDX   #$0028 ; XXYY pos.
LOOP_SCANNER_ENTIRE_SCREEN_H: ; 0x0006C2, $D6C2
    STD   X ; Store 2x2
    LEAX  256,X ; X++
    CMPX  #$9C00 ; Compare to end of screen.
    BCS   LOOP_SCANNER_ENTIRE_SCREEN_H
    LDX   #$2F08 ; XXYY
LOOP_V_SECTION: ; 0x0006D0, $D6D0
    STD   16640,X ; POS X + 65
    STD   X++ ; POS
    CMPX  #$2F28 ; End V
    BNE   LOOP_V_SECTION
    LDX   #$2F07 ; Pos small H.
H_PART_SMALL: ; 0x0006DE, $D6DE
    STA   X ; Put byte.
    LEAX  256,X ; X+1
    CMPX  #$7107 ; End pos
    BNE   H_PART_SMALL ; Not done loop.
    LDX   #$4C07 ; XXYY pos.
    LDD   #$9999 ; White?
LOOP_WHITE_PART: ; 0x0006EF, $D6EF
    STD   X ; Store top
    STD   33,X ; Bottom
    LEAX  256,X ; X+1
    CMPX  #$5407 ; End X
    BNE   LOOP_WHITE_PART ; Not done, loop.
    RTS
GET_PLAYER_PTR_IN_X_FROM_A08B: ; 0x0006FE, $D6FE
    PSHS  A ; Save A
    LDA   A08B_CURRENT_PLAYER ; Get A
DECIDE_X_A1C2|A1FF_SUB: ; 0x000702, $D702
    LDX   #$A1C2 ; Load X
    DECA ; Dec A
    BEQ   RTS_PULA
    LDX   #$A1FF ; Change X if not 0.
RTS_PULA: ; 0x00070B, $D70B
    PULS  A,PC ; RTS
DECIDE_PLAYER_PTR_FROM_A: ; 0x00070D, $D70D
    PSHS  A
    BRA   DECIDE_X_A1C2|A1FF_SUB
RANDOM_VALUE_FWD+IN_A: ; 0x000711, $D711
    PSHS  B ; Save B
    LDB   A0DF_RAND_BYTE ; Get val.
    LDA   #$03 ; Load A
    MUL ; Multiple B*3
    ADDB  #$11 ; Add with #$11
    LDA   A0E0_RAND_WORD+1 ; Load val
    LSRA ; >>1
    LSRA ; >>2
    LSRA ; >>3
    EORA  A0E0_RAND_WORD+1 ; EOR with original...
    LSRA ; >>1
    ROR   A0E0_RAND_WORD ; Rotate loc...
    ROR   A0E0_RAND_WORD+1 ; Rotate loc...
    ADDB  A0E0_RAND_WORD+1 ; Add B with 
    ADCB  A0E0_RAND_WORD ; Add B with carry.
    STB   A0DF_RAND_BYTE ; Store to.
    LDA   A0DF_RAND_BYTE ; Get A from...
    PULS  B,PC ; Recover B, RTS.
ROM_PIA_DDR_A: ; 0x000730, $D730
    .db $C0 ; 1=Out, 0=Inp
ROM_PIA_DDR_B: ; 0x000731, $D731
    .db $FF
WGT_PIA_DDR_A: ; 0x000732, $D732
    .db $00
WGT_PIA_DDR_B: ; 0x000733, $D733
    .db $00
ROM_PIA_CTRL_A: ; 0x000734, $D734
    .db $14 ; C2 L2H, OUTPUT REG, C1 H2L
ROM_PIA_CTRL_B: ; 0x000735, $D735
    .db $05 ; C2 H2L, OUTPUT REG, C1 H2L+INT
WGT_PIA_CTRL_A: ; 0x000736, $D736
    .db $34 ; C2 OUT+LOW, OUTPUT REG
WGT_PIA_CTRL_B: ; 0x000737, $D737
    .db $3E ; C2 OUT+HIGH, OUTPUT REG, C1 L2H
DEFENDER_GAME_INIT,ATTRACT: ; 0x000738, $D738
    ORCC  #$FF ; Mask interrupts.
    LDS   #$BFFF ; Set S to top of RAM.
    LDA   #$A0
    TFR   A>DP ; DP=$A0
    CLR   BANKSWITCH ; Bank 0.
    LDB   #$04 ; 3 loops
    LDU   #$CC00 ; IO PIAs
    LDX   #$D730 ; PIA_DATA_D730
PIA_SET_LOOP: ; 0x00074D, $D74D
    CLR   1,U ; Clear PIA CTRL, for DDR.
    LDA   X+ ; Get data from X
    STA   U++ ; Store at PIA DATA, for DDR
    LDA   3,X ; Get other setup
    STA   -1,U ; Store to PIA CTRL, for setup.
    DECB ; Loop counter
    BNE   PIA_SET_LOOP
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    LDX   #$9C00 ; Start addr to clear.
CLEAR_X_TO_$C000: ; 0x000760, $D760
    CLR   X+
    LDB   #$38 ; Always set watchdog.
    STB   WATCHDOG
    CMPX  #$C000 ; Go to $C000
    BNE   CLEAR_X_TO_$C000 ; Loop
    CLR   PIA_ROM_DATA_A ; Write outputs to 0's.
    CLR   PIA_ROM_DATA_B
    LDX   #$C47D ; SRAM pointer
    JSR   GET_DATA_FROM_SRAM[X]_IN_B
    TFR   B>A ; Put to A
    CMPA  #$20 ; Blank? Space?
    BHI   CLEAR_B ; If above, write cleared.
    ANDA  #$0F ; Get bottom bits.
    CMPA  #$09 ; If _ 9
    BLS   COMMIT_B_AS_IS ; <=, commit same value.
CLEAR_B: ; 0x000784, $D784
    CLRB ; Init to clear.
COMMIT_B_AS_IS: ; 0x000785, $D785
    STB   SRAM_C495-C496_PLAY_CREDITS ; Set var from B
    LDD   #$A55A ; Sanity check val.
    STD   A0E0_RAND_WORD ; Seed random.
    LDD   #$FF70 ; PTR to 0's?
    STD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG ; Store to...
    CLR   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+2
    LDB   #$FF ; D=A0FF
    STD   PIA_ROM_DATA_A_RAM_COPY ; Store as pressed.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED ; Set screen+other
    JSR   BANKSWITCH_TO_3 ; Goto bank
    JSR   JMP_TO_HIGHSCORES_TO_RAM ; Move initial to RAM.
    BSR   LIST_CHAIN_A05F_A061_A063_A069 ; Inits some lists.
    BSR   GAME_DATA_INIT_SUB ; Does tons with pools of memory.
    JSR   SETUP_TEXT+MENU+MISC ; Sets up idk, also bankswitches?
    LDX   #$D825 ; PTR to JMP to schedule attract start.
    LDA   #$01 ; Type
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Sets up callback.
    COM   A0BA_PLAYER_GAME_STATE ; Invert state, to FF?
    ANDCC #$00 ; Unmask IRQ's
    JMP   CORE_OS_TASK_LOOP ; Jumps to...
GAME_DATA_INIT_SUB: ; 0x0007B6, $D7B6
    BSR   SETUP_GAMEPLAY_PALETTE
    JSR   LASER_HOLES_POOL_CREATE
    JSR   INIT_ALL_STARS
    BSR   CHAIN_LIST_23B_LARGE_POOL_AND_NULL_OTHERS
    JSR   SETUP_A1A2-A1C1_WITH_99/9A/A9/AA
    JMP   SETUP_RANDOM_VALUES_A162-A182,A182-A1A2 ; Abuses RTS.
LIST_CHAIN_A05F_A061_A063_A069: ; 0x0007C6, $D7C6
    PSHS  X,B,A ; Save
    CLRA
    CLRB
    LDX   #$AAC5 ; PTR to list start?
    STX   LIST_15B_CALLBACKS_AVAILABLE ; Store ptr
LOOP_CREATE_LIST_15: ; 0x0007CF, $D7CF
    LEAX  15,X ; Add 15 to X
    STX   -15,X ; Store current X to last. AKA creating a list.
    CMPX  #$AF1B ; End of list, 0x4A entries, 74.
    BNE   LOOP_CREATE_LIST_15
    STD   X ; NULL OBJ.next
    STD   LIST_CALLBACKS_GENERIC? ; Null whatever list this is.
    LDX   #$AF2A ; PTR to next list.
    STX   LIST_23B_CALLBACKS_AVAILABLE_SMALL ; Point to this list, small.
CREATE_SHORT_23B_OBJ_LIST: ; 0x0007E1, $D7E1
    LEAX  23,X ; Add 23 bytes.
    STX   -23,X ; Store this to PREV.next
    CMPX  #$AF86 ; End of list, 4 entries. Dont think these are ever used?
    BNE   CREATE_SHORT_23B_OBJ_LIST
    STD   X ; Null OBJ.next
    LDX   #$A05F ; Initial location.
    STX   R_A063_CALLBACK_LIST/CURRENT ; For list.
    PULS  A,B,X,PC ; RTS
SETUP_GAMEPLAY_PALETTE: ; 0x0007F5, $D7F5
    LDX   #$F8BE ; PTR to data.
    LDU   #$A026 ; PTR to stuff.
    LDB   #$10 ; 0x0F bytes to move.
LOOP_MOVE_DATA_FROM_X_TO_Y_WITH_B_COUNTER: ; 0x0007FD, $D7FD
    LDA   X+ ; Get data from X.
    STA   U+ ; Store to ptr.
    DECB ; Loop counter.
    BNE   LOOP_MOVE_DATA_FROM_X_TO_Y_WITH_B_COUNTER
    RTS ; Leave
CHAIN_LIST_23B_LARGE_POOL_AND_NULL_OTHERS: ; 0x000805, $D805
    PSHS  X,B,A,CC ; Save
    ORCC  #$FF ; Mask interrupts?
    LDX   #$A23C ; Initial
    STX   LIST_23B_LARGE_POOL ; Store ptr to first in list.
LIST_23B_CREATE_LOOP: ; 0x00080E, $D80E
    LEAX  23,X ; Space
    STX   -23,X ; Store PREV.next
    CMPX  #$AAAE ; End of pool. 0x5E items. 94.
    BNE   LIST_23B_CREATE_LOOP ; Loop
    CLRA ; Clear D
    CLRB
    STD   X ; NULL OBJ.next
    STD   LIST_OFFSCREEN ; Null
    STD   LIST_IN_WORLD ; Null
    STD   LIST_BULLETS? ; Null
    PULS  CC,A,B,X,PC ; RTS, interrupts back.
GOTO_B1_C000_ATTRACT_START: ; 0x000825, $D825
    JSR   BANKSWITCH_TO_1 ; Swap in attract program.
    JMP   JMP_ATTRACT_START ; Goto attract program.
SRAM_C495_LOAD: ; 0x00082B, $D82B
    LDX   #$C495 ; Ptr
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get data
    DECA ; Sub 1
    BNE   RTS ; Use val if not 0.
    LDA   #$02 ; Default
    STA   SRAM_C495-C496_PLAY_CREDITS ; Store
RTS: ; 0x000838, $D838
    RTS
CALLBACK_P1_BUTTON_PRESSED_CALLBACK: ; 0x000839, $D839
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BPL   TASK_REMOVE_JMP ; If positive, delete task.
    BSR   SRAM_C495_LOAD ; Put to RAM
    LDA   SRAM_C495-C496_PLAY_CREDITS ; Load
    BEQ   TASK_REMOVE_JMP ; If 0, do instead.
    LDD   #$D4BD ; Sound
SET_SOUND_SETUP_GAME: ; 0x000846, $D846
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play
    BSR   SETUP_GAME_START? ; Set up game for only or 2nd player.
TASK_REMOVE_JMP: ; 0x00084B, $D84B
    JMP   CALLBACK_TASK_REMOVE ; Lots goes here.
2P_START_BUTTON_PRESSED_CALLBACK: ; 0x00084E, $D84E
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BPL   TASK_REMOVE_JMP ; If positive, delete task.
    BSR   SRAM_C495_LOAD ; Put to RAM
    LDA   SRAM_C495-C496_PLAY_CREDITS ; Load credits?
    CMPA  #$02 ; If _ #$02
    BCS   TASK_REMOVE_JMP ; <, dont play game. Credits count?
    BSR   SETUP_GAME_START? ; Sets up game for player.
    LDD   #$D4C2 ; Sound
    BRA   SET_SOUND_SETUP_GAME ; Goto above. Sets up 2nd game.
SETUP_GAME_START?: ; 0x000861, $D861
    CLR   R_A038_BOOKKEEP_SUB_SUB_CREDITS? ; Clear unk
    NOP ; NOP
    LDA   GAME_START_ENABLED_FLAG ; Load
    BEQ   RTS ; RTS if not set.
    LDA   A0BA_PLAYER_GAME_STATE ; Load game state.
    BPL   UI_INITIAL_DISPLAY ; If is positive, goto.
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Deschedule.
    JSR   CLEAR_ALL_SCREEN ; Clear the entire screen.
    LDA   #$7F
    STA   A0BA_PLAYER_GAME_STATE ; Store initial state.
    LDA   #$01
    STA   A08B_CURRENT_PLAYER ; Store
    STA   SHOW_PLAYER_TEXT_FLAG? ; Enable text always?
    CLR   A08C_CURRENT_PLAYER_COUNT_1/2 ; Clear?
    LDX   #$A1C2 ; Load ptr to player data?
CLEAR_DATA_LOOP: ; 0x000881, $D881
    CLR   X+ ; Clear
    CMPX  #$A23C ; End of player data?
    BNE   CLEAR_DATA_LOOP ; Loop
    LDX   #$C485 ; SRAM PTR, initial ships.
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get data
    ANDA  #$0F ; Get bottom bits just to make sure corruption isn't too rewarding.
    STA   R_A1C9_P1_SHIPS ; Store to P1 ships.
    LDB   #$0A ; Idk val.
    STD   R_A1CB_P1_SMARTBOMBS ; Ships and smartbomb count always same, B is IDK.
    CLR   R_A039_BOOKKEEP_SUB_CREDITS? ; Clear
    NOP ; NOP
    LDX   #$A1C2 ; Ptr to P1 data?
    JSR   END_WAVE_EXTRAS_HUMANOIDS+DIFFICULTY ; Do difficulty into player.
    LDX   #$C481 ; Get SRAM
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Get data in.
    STD   SRAM_C481_BONUS_SHIP_ADD ; Store to, word.
    STD   R_A1C6_SRAM_C481_P1_NEXT_SHIP ; Store to P1
    CLR   R_A1C8_ONLY_EVER_CLEARED?UNK ; Clear BYTE.
    LDX   #$A1C2 ; PTR to P1 data
LOOP_COPY_P1_DATA_TO_P2: ; 0x0008B2, $D8B2
    LDA   X+ ; Get data in player.
    STA   60,X ; Store to player 2. Off by 1 because of X+ above.
    CMPX  #$A1FF ; Compare to end P1 data, P2 start.
    BNE   LOOP_COPY_P1_DATA_TO_P2
    LDX   #$D919 ; Ptr to bookkeep 7 below.
    LDA   #$00 ; Idk val
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Do this.
UI_INITIAL_DISPLAY: ; 0x0008C4, $D8C4
    INC   A08C_CURRENT_PLAYER_COUNT_1/2 ; Inc players in game.
    LDA   SRAM_C495-C496_PLAY_CREDITS ; Load A
    ADDA  #$99 ; Decimal -1
    DAA ; Adjust
    STA   SRAM_C495-C496_PLAY_CREDITS ; Store back.
    LDX   #$C47D ; Ptr
    JSR   STORE_A_TO_SRAM[X]_BANKED ; Put A here???
    LDA   A08C_CURRENT_PLAYER_COUNT_1/2 ; Load players?
    DECA ; Dec
    BEQ   RTS ; If was 1 originally, RTS.
    JSR   DISPLAY_SETUP_INGAME ; Update display if not.
RTS: ; 0x0008DB, $D8DB
    RTS
SAVE_BANK+SET_WATCHDOG_NONFLIPPED: ; 0x0008DC, $D8DC
    PSHS  X,A ; Save
    LDA   CURRENT_BANK ; Get bank.
    PSHS  A ; Save
SET_WATCHDOG_NONFLIPPED: ; 0x0008E2, $D8E2
    LDX   #$DF17 ; IRQ handler.
    LDD   #$383C ; A=Watchdog, B=Ctrl (C2 SET HIGH, OUTPUT REG)
    BRA   SETUP_IRQ_RTN+WATCHDOG+WIDGET_B_CTRL+BANK@S
SET_WATCHDOG_GAMEPLAY?: ; 0x0008EA, $D8EA
    PSHS  X,A ; Save
    LDA   CURRENT_BANK ; Get bank.
    PSHS  A ; Save too.
    CLRA ; Zero
    JSR   BANKSWITCH_TO_A ; Switch to A
    LDA   PIA_WGT_DATA_B ; Get widget data.
    BPL   SET_WATCHDOG_NONFLIPPED ; If WGT_DATA_B7 not set, load P1 data.
    LDX   #$DFC3 ; IRQ handler.
    LDD   #$3934 ; A=Watchdog (Flipped screen) and CTRL (C2 SET LOW, OUTPUT REG)
SETUP_IRQ_RTN+WATCHDOG+WIDGET_B_CTRL+BANK@S: ; 0x0008FF, $D8FF
    STX   IRQ_CMD_LOC+1 ; Set up IRQ RTN.
    CLR   CURRENT_BANK ; Switch to bank 0
    CLR   BANKSWITCH ; Actually.
    STB   PIA_WGT_CTRL_B ; Store to widget ctrl.
    STA   WATCHDOG ; Store to watchdog.
    LDA   #$7E ; JMP command.
    STA   IRQ_CMD_LOC ; Store JMP.
    PULS  A ; Pull saved bank.
    STA   CURRENT_BANK ; Restore.
    STA   BANKSWITCH
    PULS  A,X,PC ; Restore regs+RTS
SHIP_START: ; 0x000919, $D919
    LDB   #$07 ; Bookkeep to increase. Total ships played.
    JSR   GOTO_B3-C00F_BOOKKEEP_UPDATE_+1 ; ++ it
WAVE_START: ; 0x00091E, $D91E
    JSR   GAME_DATA_INIT_SUB ; Init game data.
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Sort them into two others.
    LDA   #$7F ; Store to
    STA   A0BA_PLAYER_GAME_STATE ; Status of some type?
    LDX   R_A063_CALLBACK_LIST/CURRENT ; Get list ptr from here.
    CMPX  LIST_CALLBACKS_GENERIC? ; If X _ $A05F
    BNE   SCHEDULE_TIMER_CALLBACK ; !=, goto
    LDX   X ; Move to next obj.
    BEQ   INIT_SOME_LISTS ; If NULL, goto
SCHEDULE_TIMER_CALLBACK: ; 0x000932, $D932
    LDA   #$0F ; Countdown
    LDX   #$D93A ; Handler
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Leaves
CALLBACK_GAME_START_DELAY_FOR_COINS: ; 0x00093A, $D93A
    LDA   COIN_ACCEPT_BLOCK_7F ; Load val
    ORA   COIN_ACCEPT_BLOCK_80 ; Combine
    ORA   COIN_ACCEPT_BLOCK_7F ; Or again? Junk inst? Probs mistake, should be 81 I bet.
    BNE   SCHEDULE_TIMER_CALLBACK ; If any set, reschedule wait???
INIT_SOME_LISTS: ; 0x000942, $D942
    JSR   LIST_CHAIN_A05F_A061_A063_A069 ; List init stuff.
    LDX   #$D950 ; Handler
    LDA   #$00 ; Type
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Add callback.
    JMP   CORE_OS_TASK_LOOP ; Goto main loop.
CALLBACK_GAMEPLAY_SETUP?: ; 0x000950, $D950
    CLRA
    JSR   BANKSWITCH_TO_A ; IO bank.
    LDA   PIA_WGT_DATA_B ; Get widget input
    BPL   SET_UP_GAMEPLAY_VARS
    JSR   CLEAR_ALL_SCREEN ; Clear all screen otherwise? rofl.
    LDA   A08B_CURRENT_PLAYER ; Load val
    DECA ; --
    BNE   VAL_NOT_0 ; !=0, goto.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED
    BRA   SKIP_WATCHDOG_OTHER
VAL_NOT_0: ; 0x000966, $D966
    BSR   SET_WATCHDOG_GAMEPLAY?
SKIP_WATCHDOG_OTHER: ; 0x000968, $D968
    LDA   #$FF ; Set all buttons to on.
    STA   WGT_DATA_A_RAM_COPY
    STA   WGT_DATA_A_RAM_COPY_OLD
SET_UP_GAMEPLAY_VARS: ; 0x00096E, $D96E
    CLRA ; Clear D
    CLRB
    STD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Clear
    STD   R_A022_SCREEN_POS_HORIZ_2_TRGT? ; Clear
    JSR   BANKSWITCH_TO_7 ; Bank 7
    JSR   JMP_TO_GENERATE_LAND_DATA_B300-B6FF ; Prep for land.
    JSR   JMP_TO_DRAW_LAND_INITIALIZATION? ; Draw land.
    JSR   CLEAR_GAME_SCREEN ; Clear the screen.
    LDD   #$0300 ; Facing right val.
    STD   R_A0BD_UNK_DIR_UNK ; To
    STD   SHIP_DIRECTION_300/FD00
    CLR   SOUND_NOT_PLAYING_FLAG ; Clear
    CLR   LASERS_ONSCREEN_COUNT ; Zero
    CLR   R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT? ; Clear
    CLR   REVERSE_BLOCK_FLAG ; Dont block reverse
    CLR   R_A09A_SMARTBOMB_DISABLED
    CLR   BULLET/MINE_SPAWNED_COUNT ; These
    LDX   #$A11A ; Humanoid pointer.
    STX   HUMANOID_LAST_MARKED_PTR
    JSR   GET_PLAYER_PTR_IN_X_FROM_A08B ; Get player ptr.
    STX   A08D_CURRENT_PLAYER_PTR? ; Store to.
    LDA   8,X ; Get PLAYER[8], wave?
    ANDA  #$07 ; Range
    LDU   #$DB53 ; PTR to level colors.
    LDA   A,U ; Load from ptr
    STA   COLOR_PALETTE_RAM_COPY+5 ; Store to wave color?
    DEC   7,X ; Dec PLAYER[7], ship count.
    JSR   DISPLAY_SETUP_INGAME ; Show display.
    LDD   #$2080 ; Unsure val
    STD   R_A0C1_SHIP_UNK
    STD   SHIP_SCR_POS_XXYY ; Ship screen pos.
    LDD   #$2000 ; Unsure val
    STD   R_A0C3_SHIP_SCR_HPOS?
    LDD   #$0800 ; Unsure val.
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add?
    STD   R_A0CC_SHIP_W_POS? ; Store to
    LDD   #$8000 ; VPOS?
    STD   SHIP_VPOS ; Store to
    CLRA ; Clear with A/B/D now.
    CLRB
    STD   SCREEN_H_DELTA
    STA   R_A0C9_UNUSED?ONLY_CLEARED
    STD   PLAYER_V_MOMENTUM
    LDX   #$E9E3 ; Callback to on/off screen handler.
    LDA   #$00 ; Timer
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$E782 ; Callback rotate colors.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$F493 ; Callback UPDATE_UI
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$E9BF ; Callback forward pool pointers.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$F464 ; Callback rotate colors.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$F43D ; Callback rotate colors.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDA   SHOW_PLAYER_TEXT_FLAG?
    BEQ   SKIP_SHOW_PLAYER_TEXT ; If == 0, skip player text.
    LDB   A08C_CURRENT_PLAYER_COUNT_1/2 ; Load count.
    DECB
    BEQ   SKIP_SHOW_PLAYER_TEXT ; If 1, goto.
    LDU   #$C0EF ; SENTENCE PTR PLAYER ONE
    LDA   A08B_CURRENT_PLAYER ; Load val
    DECA ; Dec
    BEQ   DONT_MOVE_U ; If was 1, don't move.
    LDU   #$C0F1 ; SENTENCE PTR PLAYER TWO
DONT_MOVE_U: ; 0x000A11, $DA11
    LDX   #$3C80 ; Pos?
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN ; Print
    LDA   #$80 ; Countdown
    LDX   #$DA1F ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup task it seems. Needs more digging.
SKIP_SHOW_PLAYER_TEXT: ; 0x000A1F, $DA1F
    JSR   CLEAR_GAME_SCREEN ; Clear the game screen.
    LDB   #$05 ; Game state 0000.0101
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player data pointer
    LDA   10,X ; Load PLAYER[10], HUMANOID COUNT
    BSR   SET_GAME_STATE_B_HAS_PLANET_IF_NOT_ZERO ; Manip B possibly.
    LDA   #$60 ; Timer?
    LDX   #$DA32 ; Callback?
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; I need to figure this out more apparently
CALLBACK_MAIN?: ; 0x000A32, $DA32
    JSR   INIT_HUMANOIDS? ; Do with spawn in?
    BSR   GAME_STATE_CLEARED_HUMANOID_STATE_SET
    CLR   SHOW_PLAYER_TEXT_FLAG? ; Clear show text flag.
    JMP   GAMEMASTER_TASK_BAITER
GAME_STATE_CLEARED_HUMANOID_STATE_SET: ; 0x000A3C, $DA3C
    CLRB
GAME_STATE_FROM_B_SET_HUMANOIDS_STATE: ; 0x000A3D, $DA3D
    LDA   A0FA_HUMANOID_COUNT ; Load count...
SET_GAME_STATE_B_HAS_PLANET_IF_NOT_ZERO: ; 0x000A3F, $DA3F
    BNE   SET_GAME_STATE
    ORB   #$02 ; Set bit, planet blown up.
SET_GAME_STATE: ; 0x000A43, $DA43
    STB   A0BA_PLAYER_GAME_STATE ; Store state.
    RTS
HYPERSPACE_DIED_ON_REENTRY: ; 0x000A46, $DA46
    LDB   #$58 ; Game state died?
    BSR   GAME_STATE_FROM_B_SET_HUMANOIDS_STATE ; Set state.
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Move. Lock screen?
    STD   R_A022_SCREEN_POS_HORIZ_2_TRGT?
    LDX   SHIP_SCR_POS_XXYY ; Pos from
    LDD   #$0806 ; Size
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear ship.
    JSR   SAVE_STATE_TO_PLAYER ; Save state to player
    LDD   #$D4B5
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play sound.
    LDY   #$F9C1 ; PTR to BITMAP/BMP
    LDA   SHIP_DIRECTION_300/FD00 ; Load val
    BPL   DONT_LOAD_OTHER_BITMAP ; If positive, skip ptr change.
    LDY   #$F9CB ; Pos 2 to BMP
DONT_LOAD_OTHER_BITMAP: ; 0x000A6B, $DA6B
    LDX   #$DB4B ; Callback unk
    STX   7,U ; Store to OBJ[7]
    LDU   #$AFDD ; Unsure val
    JSR   GFX_SILHOUETTE ; Not exactly sure. Silhouette rtn?
    TFR   U>X ; Silh gfx data ptr to X
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Reload task ptr to U
    STX   11,U ; To U[11] task data.
CALLBACK_LOOP_FLASHING_CLEAR: ; 0x000A7C, $DA7C
    LDD   R_A0C1_SHIP_UNK ; Pos
    LDY   11,U ; Silhouette gfx data
    JSR   GFX_BANK2_CHR_CLEAR ; Clear off screen.
    LDA   #$02 ; Countdown
    LDX   #$DA8C ; Handler
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_HANDLER_SILHOUETTE_SHOW: ; 0x000A8C, $DA8C
    LDD   R_A0C1_SHIP_UNK ; Pos
    LDY   11,U ; BMP ptr
    JSR   GFX_BANK2_CHR_TO_SCREEN ; To screen
    LDX   7,U ; X from OBJ[7], flash color.
    LDA   X+ ; A from ptr
    BEQ   SHIP_FLASH_COLORS_EOF ; Goto
    STA   COLOR_PALETTE_RAM_COPY+11 ; Store val to palette 11, 0xB
    CLR   COLOR_PALETTE_RAM_COPY ; Clear black, probably because smartbomb at same time.
    STX   7,U ; Ptr update.
    LDA   #$02 ; Countdown
    LDX   #$DA7C ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup callback.
SHIP_FLASH_COLORS_EOF: ; 0x000AA8, $DAA8
    LDA   #$7F
    STA   A0BA_PLAYER_GAME_STATE ; State to...
    LDA   #$FF ; White
    STA   COLOR_PALETTE_RAM_COPY ; To pal[0], whole screen white instead of black.
    LDA   #$02 ; Countdown
    LDX   #$DAB8 ; Handler
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_HANDLER_SHIP_EXPLODE_TASK: ; 0x000AB8, $DAB8
    CLR   COLOR_PALETTE_RAM_COPY ; Color back to 0
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Clean up callbacks.
    LDX   R_A0C1_SHIP_UNK ; X from
    LEAX  1027,X ; Get epicenter
    JSR   BANKSWITCH_TO_7 ; To 7
    JSR   JMP_TO_SHIP_EXPLODE? ; Idk, ship exploding?
    JSR   CURRENT_PLAYER_SCORE_TO_SCREEN ; Score to screen.
    CLR   SOUND_TIMER_BLOCK_UPDATE ; Clear, don't block any updates.
    LDB   #$13 ; Sound to play.
    JSR   OUTPUT_B_TO_SOUND_BOARD ; Play sound.
    JSR   ENEMY_COUNTS_ALIVE+TO_SPAWN ; Load enemy counts.
    BNE   WAVE_NOT_OVER
    JSR   END_OF_WAVE ; End wave if everything dead.
    JSR   CLEAR_GAME_SCREEN ; Clear screen.
WAVE_NOT_OVER: ; 0x000ADE, $DADE
    LDA   A08B_CURRENT_PLAYER ; Load current player
    LDX   A08D_CURRENT_PLAYER_PTR? ; Load player ptr
    LDB   7,X ; Load PLAYER[7]
    BNE   PLAYER_GAME_NOT_OVER ; If not 0, goto.
    LDB   A08C_CURRENT_PLAYER_COUNT_1/2 ; Load B with same?
    DECB ; DEC
    BEQ   A08C_CURRENT_PLAYER_1 ; If was 1
    EORA  #$03 ; Invert player val in A
    JSR   DECIDE_PLAYER_PTR_FROM_A ; Get PTR from A
    LDB   7,X ; Load PLAYER[7] of other
    BEQ   A08C_CURRENT_PLAYER_1 ; If 0, goto.
    LDU   #$C0EF ; PTR to SENTENCE PLAYER ONE
    CMPA  #$02 ; If is 2
    BEQ   SKIP_LOAD_PLAYER_TWO
    LDU   #$C0F1 ; PTR to SENTENCE PLAYER TWO
SKIP_LOAD_PLAYER_TWO: ; 0x000AFE, $DAFE
    LDX   #$3C78 ; Pos
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN ; To screen.
    LDU   #$C075 ; PTR to SENTENCE GAME OVER
    LDX   #$3E88 ; POS
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN ; To screen.
    LDA   #$60 ; Timer
    LDX   #$DB15 ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup.
PLAYER_GAME_NOT_OVER: ; 0x000B15, $DB15
    LDA   A08B_CURRENT_PLAYER ; Current
LOOP_PLAYER_PTR: ; 0x000B17, $DB17
    INCA ; INC
    CMPA  A08C_CURRENT_PLAYER_COUNT_1/2 ; Compare?
    BLS   DONT_LOAD_ONE ; <=, goto...?
    LDA   #$01
DONT_LOAD_ONE: ; 0x000B1E, $DB1E
    JSR   DECIDE_PLAYER_PTR_FROM_A ; Get ptr
    LDB   7,X ; Load PLAYER[7]
    BEQ   LOOP_PLAYER_PTR ; If 0, goto.
    STA   A08B_CURRENT_PLAYER ; Store A to current
    INC   SHOW_PLAYER_TEXT_FLAG? ; Inc IDK
    JMP   SHIP_START ; Bookkeep, never returns.
A08C_CURRENT_PLAYER_1: ; 0x000B2C, $DB2C
    LDU   #$C075 ; PTR to SENTENCE GAME OVER
    LDX   #$3E80 ; POS
    LDA   #$FF ; State
    STA   A0BA_PLAYER_GAME_STATE ; Update
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN ; To screen.
    CLR   SOUND_TIMER_BLOCK_UPDATE ; Clear
    LDB   #$13 ; No sound?
    JSR   OUTPUT_B_TO_SOUND_BOARD ; To
    LDA   #$28 ; Timer
    LDX   #$DB48 ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_GAME_OVER_BACK_TO_INTRO/INITIALS?: ; 0x000B48, $DB48
    JMP   GOTO_B1_C000_ATTRACT_START
DATA_SHIP_FLASH?: ; 0x000B4B, $DB4B
    .db $07 ; B=0/3,G=0/7,R=7/7
    .db $07
    .db $07
    .db $0F ; B=0/3,G=1/7,R=7/7
    .db $3F ; B=0/3,G=7/7,R=7/7
    .db $7F ; B=1/3,G=7/7,R=7/7
    .db $FF ; B=3/3,G=7/7,R=7/7
    .db $FF
SCANNER_COLORS_PER_WAVE: ; 0x000B53, $DB53
    .db $00 ; Black
    .db $81 ; B=2/3,G=0/7,R=1/7
    .db $28 ; B=0/3,G=5/7,R=0/7
    .db $07 ; B=0/3,G=0/7,R=7/7
    .db $16 ; B=0/3,G=2/7,R=6/7
    .db $2F ; B=0/3,G=5/7,R=7/7
    .db $84 ; B=2/3,G=0/7,R=4/7
    .db $15 ; B=0/3,G=2/7,R=5/7
    .db $00 ; EOF value. Resets to index 0, black wave.
GFX_SILHOUETTE: ; 0x000B5C, $DB5C
    PSHS  U,X,B,A ; Save
    JSR   BANKSWITCH_TO_2 ; Bank 2 for BMP lib.
    LDD   Y ; Load WWHH from BMP
    STD   U ; Store to $AFDD
    MUL ; MUL, aka get bytes to do into D.
    LEAX  10,U ; X = $AFE7
    STX   2,U ; AFE7 to AFDF
    LEAX  D,X ; X += BMP_BYTES
    STX   4,U ; Store to $AFE1
    PSHS  X ; As S[2]
    LEAX  D,X ; X += BMP_BYTES
    PSHS  X ; As S[0]
    LDD   6,Y ; BMP_ONTO_SCRN...
    STD   6,U ; ...to U[6]
    LDD   8,Y ; BMP_OFF_SCRN...
    STD   8,U ; ...to U[8]
    LDX   2,Y ; Load BMP_EVEN PTR from BMP container.
    LEAU  10,U ; U+=10, to end of slot info.
    BSR   BMP_TO_SLOT_SILHOUETTE_MASK ; Do, needs more looking at.
    LDX   4,Y ; Load BMP_ODD ptr
    LDU   2,S ; U from S+2. This shouldn't be needed as U at pos already? TODO: Solve
    LDD   S ; Odd data end ptr value move.
    STD   2,S ; To here, where rtn checks.
    BSR   BMP_TO_SLOT_SILHOUETTE_MASK ; Do again for this bmp.
    LEAS  4,S ; Fix up stack from pushed ptrs.
    PULS  A,B,X,U,PC
BMP_TO_SLOT_SILHOUETTE_MASK: ; 0x000B90, $DB90
    LDD   X++ ; D from BMP_GFX
    BITA  #$F0 ; Test upper nibble
    BEQ   SKIP_O_A:UN ; None set, goto.
    ORA   #$F0 ; Set mask. F is just a catch all mask for the AND later.
SKIP_O_A:UN: ; 0x000B98, $DB98
    BITA  #$0F ; Test lower nibble
    BEQ   SKIP_OR_A_LN ; None set, goto.
    ORA   #$0F ; Set mask.
SKIP_OR_A_LN: ; 0x000B9E, $DB9E
    BITB  #$F0 ; Test upper nibble
    BEQ   SKIP_OR_B:UN ; None set, goto.
    ORB   #$F0 ; Set mask.
SKIP_OR_B:UN: ; 0x000BA4, $DBA4
    BITB  #$0F ; Test lower nibble
    BEQ   SKIP_OR_B:LN ; None set, goto.
    ORB   #$0F ; Set mask.
SKIP_OR_B:LN: ; 0x000BAA, $DBAA
    ANDA  #$BB ; Set proper pixel value wanted.
    ANDB  #$BB
    STD   U++ ; Store to U
    CMPU  4,S ; Compare to end of data for this BMP data.
    BCS   BMP_TO_SLOT_SILHOUETTE_MASK ; Loop if not at yet.
    RTS
SAVE_STATE_TO_PLAYER: ; 0x000BB6, $DBB6
    PSHS  U,X,B,A ; Save
    LDU   A08D_CURRENT_PLAYER_PTR? ; Get player ptr
    LEAU  10,U ; +=10
    LDA   #$33 ; Load val
LOOP_CLEAR_51_BYTES: ; 0x000BBE, $DBBE
    CLR   U+
    DECA ; Clear player ptr +
    BNE   LOOP_CLEAR_51_BYTES
    LDU   A08D_CURRENT_PLAYER_PTR? ; Get player ptr again
    LDA   A0FA_HUMANOID_COUNT ; Load val
    STA   10,U ; Store to PLAYER[10]
    LEAU  11,U ; +=11
    LDX   #$A0FB ; Ptr
LOOP_MOVE_RAM_TO_PLAYER: ; 0x000BCE, $DBCE
    LDA   X+ ; Load data from
    CMPX  #$A100 ; Compare to
    BHI   DONT_ADD_WITH_22_IN
    ADDA  22,X ; Add with value 22 in, 5 bytes do this.
DONT_ADD_WITH_22_IN: ; 0x000BD8, $DBD8
    STA   U+ ; Store to player ptr.
    CMPX  #$A112 ; A111 is end
    BNE   LOOP_MOVE_RAM_TO_PLAYER
    PULS  A,B,X,U,PC ; RTS
MAKE_A_NUMBER_HUMANOIDS: ; 0x000BE1, $DBE1
    PSHS  B,A ; Save, A=NUMBER_TO_MAKE_IN_GRP,B=WORLD_OFF_ADD
    STA   A073_SCRATCHPAD_ADDR+1 ; SCRATCH = How many to make in group.
LOOP_FILL_OUT: ; 0x000BE5, $DBE5
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Fill out obj with data.
    .db $F9 ; GFX
    .db $01
    .db $ED ; Hit handler.
    .db $70
    .db $66 ; Scanner colors.
    .db $66
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random in A
    LDD   A0E0_RAND_WORD ; Load random word.
    ANDA  #$1F ; Range groups
    ADDA  1,S ; Add with B on stack.
    STD   10,X ; Store to HWORLD
    LSRB ; Shift B
    BCC   NOT_ALT_BMP_HUM ; If shifted off 0, goto.
    LDD   #$F915 ; Humanoid bitmap shifted.
    STD   2,X ; Store to obj.
NOT_ALT_BMP_HUM: ; 0x000C01, $DC01
    LDA   #$E0 ; Move to OBJ[12], unk.
    STA   12,X ; To WORLDV
    LDA   #$10 ; Move to OBJ[20], unk
    STA   20,X ; To ATTR
    CLRA ; Clear D
    CLRB
    STD   16,X ; Clear VSPEED
    STD   14,X ; HSPEED
    STD   6,X ; OBJ_GROUP_LIST? Need good name.
    STX   LIST_IN_WORLD ; Store to list?
    STX   Y++ ; Humanoid ptr to Y buffer.
    DEC   A073_SCRATCHPAD_ADDR+1 ; Dec val.
    BNE   LOOP_FILL_OUT ; Loop if not 0.
    PULS  A,B,PC ; RTS
CALLBACK_IDK: ; 0x000C1D, $DC1D
    INC   A08D_CURRENT_PLAYER_PTR?+1
    LDD   -31232,U ; Screw up D. WTF?
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Callback in X.
    LDU   #$A11A ; Ptr to humanoid objects array.
    LEAY  U ; To Y also.
    STU   7,X ; Ptr to XOBJ[7]
LOOP_CLEAR_A11A-A141: ; 0x000C2D, $DC2D
    CLR   U+ ; Clear PTR.
    CMPU  #$A142 ; Clear A11A to A141, 40B
    BNE   LOOP_CLEAR_A11A-A141
    LDU   A08D_CURRENT_PLAYER_PTR? ; Get player PTR
    LDA   10,U ; PLAYER[10] is humanoid count.
    STA   A0FA_HUMANOID_COUNT ; Store to game var?
    BEQ   NO_HUMANOIDS ; If 0, no humanoids.
    CMPA  #$07 ; If _ 7
    BLS   HUMANOIDS_COUNT_<=7? ; <=, goto.
    LSRA ; Shift val twice, /4
    LSRA
    CLRB ; Clear for 4 loops.
NOT_ZERO_HUMANOID: ; 0x000C44, $DC44
    BSR   MAKE_A_NUMBER_HUMANOIDS
    ADDB  #$40 ; 4 loops.
    BNE   NOT_ZERO_HUMANOID
    ASLA ; Shift left
    ASLA ;  2x
    NEGA ; Invert
    ADDA  10,U ; Add count?
    BEQ   NO_HUMANOIDS ; If 0, goto.
HUMANOIDS_COUNT_<=7?: ; 0x000C51, $DC51
    STA   A073_SCRATCHPAD_ADDR ; Store count <= 7 here?
LOOP_MORE_HUMANOIDS: ; 0x000C53, $DC53
    LDB   A0E0_RAND_WORD ; Load B. TODO: Used for STD 10,X below?
    LDA   #$01 ; Idk val
    BSR   MAKE_A_NUMBER_HUMANOIDS ; Make humanoid, B=OFFSET, A=HOW MANY.
    DEC   A073_SCRATCHPAD_ADDR ; Dec counter
    BNE   LOOP_MORE_HUMANOIDS
NO_HUMANOIDS: ; 0x000C5D, $DC5D
    LDU   A08D_CURRENT_PLAYER_PTR? ; Load player ptr
    LEAU  11,U ; U += 11
    LDX   #$A0FB ; Ptr to game RAM.
LOOP_PLAYER_TO_GAME_STATE: ; 0x000C64, $DC64
    LDA   U+ ; Load from player
    STA   X+ ; Store to game state.
    CMPX  #$A112 ; End
    BNE   LOOP_PLAYER_TO_GAME_STATE
    LDX   #$A112 ; Useless if ran from above. TODO: Only ran from there?
INIT_GAME_ALIVE+TIMERS_LOOP: ; 0x000C70, $DC70
    CLR   X+ ; Init to 0 alive counts + timers.
    CMPX  #$A11A ; Humanoid data start check.
    BNE   INIT_GAME_ALIVE+TIMERS_LOOP ; Clear all.
CREATE_HUMANOIDS_LOOP: ; 0x000C77, $DC77
    JSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get obj
    LDA   A0DF_RAND_BYTE ; Get random.
    LSRA ; Shift
    ADDA  #$2A ; Add
    STA   12,X ; Store to OBJ[12]
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random.
    ANDA  #$3F ; Get bits.
    ADDA  #$80 ; Set top.
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add with this.
    STD   10,X ; Store to OBJ[10]
    LDA   R_A0FF_SWARMERS_IN_POD_IDK ; Load val
    BEQ   EXIT_OBJ_TO_ONSCREEN ; If 0, goto.
    CMPA  #$06 ; IF A _ 6
    BLS   DONT_CAP_TO_6 ; <=, goto.
    LDA   #$06 ; Cap at 6
DONT_CAP_TO_6: ; 0x000C96, $DC96
    LEAY  X ; X to Y
    JSR   MAKE_A#_SWARMERS_FROM_YOBJ_INFO ; Make other obj?
    LDX   LIST_23B_LARGE_POOL ; Get list ptr
    STX   Y ; Store to Y.next
    STY   LIST_23B_LARGE_POOL ; Makes Y new head?
    NEGA ; Invert original A
    ADDA  R_A0FF_SWARMERS_IN_POD_IDK ; Add with val
    STA   R_A0FF_SWARMERS_IN_POD_IDK ; Store back
    BNE   CREATE_HUMANOIDS_LOOP ; If not 0, continue.
EXIT_OBJ_TO_ONSCREEN: ; 0x000CA9, $DCA9
    LDA   R_A0FE_ENEMY_MUTANT_COUNT? ; Load val
    BEQ   NO_ENEMIES_MUTANT? ; If 0, skip.
    JSR   MAKE_NUMBER_OF_ENEMIES_MUTANT?
    CLR   R_A0FE_ENEMY_MUTANT_COUNT?
NO_ENEMIES_MUTANT?: ; 0x000CB2, $DCB2
    LDA   R_A0FD_PODS_TO_MAKE
    STA   R_A114_PODS_ALIVE_COUNT?
    BEQ   NO_ENEMIES_PODS?
    CLR   R_A0FD_PODS_TO_MAKE
    JSR   MAKE_NUMBER_OF_PODS?
NO_ENEMIES_PODS?: ; 0x000CBE, $DCBE
    LDA   R_A0FC_BOMBERS_TO_MAKE
    STA   R_A113_BOMBER_ALIVE_COUNT?
    BEQ   NO_ENEMIES_BOMBERS? ; If 0, RTS
BOMBERS_GROUP_LOOP: ; 0x000CC5, $DCC5
    CMPA  #$03
    BLS   CAP_AT_3
    LDA   #$03 ; TODO: Can switch to 4 cap?
CAP_AT_3: ; 0x000CCB, $DCCB
    PSHS  A ; Save count using.
    JSR   MAKE_#_BOMBERS_GROUP ; Make group
    LDA   R_A0FC_BOMBERS_TO_MAKE
    SUBA  S+ ; Count -= Used
    STA   R_A0FC_BOMBERS_TO_MAKE ; Store back
    BNE   BOMBERS_GROUP_LOOP ; Loop if not 0.
NO_ENEMIES_BOMBERS?: ; 0x000CD8, $DCD8
    RTS
GAMEMASTER_TASK_BAITER: ; 0x000CD9, $DCD9
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load list here.
    LDA   #$28 ; Load val
    STA   7,U ; OBJ[7]
    LDA   BAITER_SPAWN_RELOAD ; Move
    STA   BAITER_TIMER
    LDA   #$01 ; Val?
    STA   EXTRA_WAVE_SPAWN_TIMER ; Set
GAMEMASTER_TASK: ; 0x000CEA, $DCEA
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BITA  #$08 ; Test bit.
    BNE   DONT_SPAWN_EXTRA_WAVE_LANDERS ; If set, goto.
    JSR   ENEMY_COUNTS_ALIVE+TO_SPAWN
    BNE   WAVE_CONTINUE ; If A not 0, goto. Enemies number?
    LDA   #$77 ; Set game state 0111.0111
    STA   A0BA_PLAYER_GAME_STATE
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Sort OS stuff.
    JSR   SAVE_STATE_TO_PLAYER
    JSR   END_OF_WAVE
    LDX   A08D_CURRENT_PLAYER_PTR?
    INC   7,X ; PLAYER[7], wave++
    JMP   WAVE_START ; Next wave start.
WAVE_CONTINUE: ; 0x000D09, $DD09
    CMPA  #$08 ; 8 enemies left?
    BHI   MORE_THAN_8_ENEMIES ; >, goto.
    LDB   BAITER_SPAWN_RELOAD ; Load val
    LSRB ; >> 1, /2
    CMPA  #$03 ; IF NUM_ENEMIES _ 3
    BHI   DONT_DIVIDE_AGAIN ; >, goto. AKA go even faster.
    LSRB ; >> 1, /2
DONT_DIVIDE_AGAIN: ; 0x000D16, $DD16
    INCB ; INC base val we received.
    CMPB  BAITER_TIMER ; Compare to spawn timer.
    BCC   MORE_THAN_8_ENEMIES ; If B > Val, don't store. Only store lower.
    STB   BAITER_TIMER ; Store lower if base is lower than timer.
MORE_THAN_8_ENEMIES: ; 0x000D1F, $DD1F
    DEC   BAITER_TIMER ; Just dec counter.
    BNE   DONT_SPAWN_BAITER ; If not 0, goto.
    CMPA  #$04 ; If NUM_ENEMIES _ 4
    LDA   BAITER_SPAWN_RELOAD ; Replace A
    BCC   A_TO_BAITER_TIMER_ASIS ; NUM_ENEMIES > 4, don't rebase lower.
    LSRA ; /4 otherwise.
    LSRA
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get new val even lower maybe.
A_TO_BAITER_TIMER_ASIS: ; 0x000D30, $DD30
    STA   BAITER_TIMER ; Store to timer.
    LDA   R_A119_BAITER_ALIVE_COUNT ; Load val
    CMPA  #$0C ; If _ #$0C
    BCC   DONT_SPAWN_BAITER ; >=, goto
    JSR   MAKE_BAITER_RTN? ; Do IDK
    INC   R_A119_BAITER_ALIVE_COUNT ; INC
DONT_SPAWN_BAITER: ; 0x000D40, $DD40
    DEC   EXTRA_WAVE_SPAWN_TIMER ; Dec counter
    BEQ   TIMER_A117_ZERO ; If 0, goto.
    LDA   R_A112_LANDER_COUNT? ; Load count abducting rn.
    BNE   DONT_SPAWN_EXTRA_WAVE_LANDERS ; If not 0, skip?
TIMER_A117_ZERO: ; 0x000D4A, $DD4A
    LDA   EXTRA_WAVE_SPAWN_REFRESH ; Move
    STA   EXTRA_WAVE_SPAWN_TIMER
    LDA   R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT? ; Load count
    BEQ   DONT_SPAWN_EXTRA_WAVE_LANDERS ; == 0, don't spawn in as no more needed.
    LDA   R_A112_LANDER_COUNT? ; Load count
    CMPA  #$08
    BCC   DONT_SPAWN_EXTRA_WAVE_LANDERS ; >=, goto. Too many to spawn in new wave.
    LDA   R_A101_MUTANT_RELATED?_UNK ; Load val
    CMPA  R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT? ; If val _ count
    BLS   SPAWN_WAVE_OF_LANDERS ; <=, goto. If taken, spawns the mutant count?
    LDA   R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT? ; Load count of landers instead.
SPAWN_WAVE_OF_LANDERS: ; 0x000D64, $DD64
    JSR   SPAWN_WAVE_OF_ENEMIES_LANDER/MUTANT ; Request spawns.
    NEGA ; Negate requested.
    ADDA  R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT? ; Add to, aka sub.
    STA   R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT? ; Store updated count. Should always be 0? Hmm...
DONT_SPAWN_EXTRA_WAVE_LANDERS: ; 0x000D6C, $DD6C
    LDA   STARS_NUM_TO_CHANGE? ; Load val
    CMPA  #$10 ; If _ #$10
    BCC   DONT_INC_A0AE ; >=, DONT INC
    INC   STARS_NUM_TO_CHANGE? ; Change one more star this go.
DONT_INC_A0AE: ; 0x000D74, $DD74
    LDA   A024_TIME_PLAYED? ; Load val
    INCA ; Inc
    CMPA  #$F0 ; If _ #$F0
    BLS   SKIP_BOOKKEEP
    LDB   #$06 ; Bookkeep entry
    JSR   GOTO_B3-C00F_BOOKKEEP_UPDATE_+1 ; ++
    CLRA ; Clear
SKIP_BOOKKEEP: ; 0x000D81, $DD81
    STA   A024_TIME_PLAYED? ; Store/clear.
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load our callback.
    DEC   7,U ; DEC OBJ[7], GEN_USE, in our case, MASTER_DIFF_TIMER
    BNE   RESCHEDULE_GAMEMASTER_TASK ; Not 0, just reschedule.
    LDB   #$02 ; Index into difficulty data to read from.
    LDY   #$A0FB ; Ptr to game diff data.
    JSR   STEP_DIFFICULTY@Y_WITH_TBL_OFFSET@B ; Manip player data
    LDA   #$28 ; Timer
    STA   7,U ; Store back timer.
RESCHEDULE_GAMEMASTER_TASK: ; 0x000D96, $DD96
    LDA   #$0F ; Timer
    LDX   #$DCEA ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup.
GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT: ; 0x000D9E, $DD9E
    PSHS  A ; Save A
    JSR   RANDOM_VALUE_FWD+IN_A ; Random value
LOOP_UNTIL_NEW_IS_LOWER: ; 0x000DA3, $DDA3
    CMPA  S ; Compare with pushed
    BLS   NEW_IS_<=_STACK
    LSRA ; Shift
    BRA   LOOP_UNTIL_NEW_IS_LOWER
NEW_IS_<=_STACK: ; 0x000DAA, $DDAA
    INCA ; ++ when done.
    LEAS  1,S ; Clean up stack, no pull.
    RTS ; Leave
ENEMY_COUNTS_ALIVE+TO_SPAWN: ; 0x000DAE, $DDAE
    LDA   R_A112_LANDER_COUNT?
    ADDA  R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT?
    ADDA  R_A113_BOMBER_ALIVE_COUNT?
    ADDA  R_A114_PODS_ALIVE_COUNT?
    ADDA  R_A116_SWARMERS_ALIVE_COUNT?
    ADDA  R_A115_MUTANT_ALIVE_COUNT?
    ADDA  R_A0FE_ENEMY_MUTANT_COUNT?
    RTS ; RTS
DECIMAL_BACK_TO_HEX_A: ; 0x000DC2, $DDC2
    PSHS  B ; Save B
    CLRB ; Clear
LOOP_A_DEC_10: ; 0x000DC5, $DDC5
    CMPA  #$10 ; If A _ #$10
    BCS   A_<_#$10 ; <, goto.
    ADDB  #$0A ; B+=#$0A for every A >= #$10
    SUBA  #$10 ; A -= #$10
    BRA   LOOP_A_DEC_10 ; Loop again
A_<_#$10: ; 0x000DCF, $DDCF
    PSHS  B ; Hex val to stack.
    ADDA  S+ ; Leftover in A += Hex
    PULS  B,PC ; RTS, result in A.
BYTE_TO_DISP?: ; 0x000DD5, $DDD5
    PSHS  B ; Save B
    TFR   A>B ; A to B
    CLRA ; Clear
LOOP_HIGHER_THAN_0x09: ; 0x000DDA, $DDDA
    CMPB  #$0A
    BCS   NO_FIXING_NEEDED
    ADDA  #$10 ; Add high digit to A
    DAA ; Adjust
    SUBB  #$0A ; Subtract value added decimally.
    BRA   LOOP_HIGHER_THAN_0x09
NO_FIXING_NEEDED: ; 0x000DE5, $DDE5
    PSHS  B ; Push to stack
    ADDA  S+ ; Add low digit to A
    DAA ; Adjust again. TODO: Find 99->00 factor.
    PULS  B,PC
END_OF_WAVE: ; 0x000DEC, $DDEC
    CLR   COLOR_PALETTE_RAM_COPY ; Clear
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load ptr to list.
    PULS  X ; X from stack.
    STX   13,U ; Store to [A063]+13
    JSR   CLEAR_GAME_SCREEN ; Clear game screen.
    LDU   #$C0F9 ; Attack wave
    LDX   #$3850 ; POS
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN ; To screen.
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player pointer
    LDA   8,X ; Get wave
    BSR   BYTE_TO_DISP?
    TFR   A>B ; To B
    CLRA ; Clear A
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Get location.
    JSR   JMP_TO_VAL_IN_AB_TO_SCREEN
    LDX   #$3D60 ; Pos
    LDU   #$C0FB ; PTR TO SENTENCE COMPLETED
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN
    LDU   #$C0F3 ; PTR TO SENTENCE BONUS X
    LDX   #$3C90 ; Pos
    JSR   GOTO_B2-C002_SENTENCE_TO_SCREEN ; To screen.
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player ptr.
    CLRB ; Clear
    LDA   8,X ; Get wave
    CMPA  #$05 ; Compare to 5
    BLS   CAP_BONUS_AT_500 ; If <= 5, use.
    LDA   #$05 ; Cap at 5.
CAP_BONUS_AT_500: ; 0x000E2B, $DE2B
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Get pos.
    JSR   JMP_TO_VAL_IN_AB_TO_SCREEN ; Put to screen.
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load ptr
    LDX   #$3CA0 ; Pos
    LDA   A0FA_HUMANOID_COUNT ; Load val
    STA   9,U ; Store to list entry?
    BEQ   NO_MORE_HUMANOIDS_TO_DISPLAY ; If 0, goto.
HUMANOID_DISPLAY_LOOP: ; 0x000E3B, $DE3B
    TFR   X>D ; Pos to actual.
    LDY   #$F915 ; Ptr to bmp, humanoid.
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Put to screen.
    LEAX  1024,X ; space 4 pixels.
    LDA   #$01 ; Score add flag, multiply.
    LDY   A08D_CURRENT_PLAYER_PTR? ; Load ptr to player
    LDB   8,Y ; Load wave
    CMPB  #$05
    BCS   DONT_CAP_WAVE_BONUS
    LDB   #$05
DONT_CAP_WAVE_BONUS: ; 0x000E55, $DE55
    ASLB ; Shift to upper nibble.
    ASLB
    ASLB
    ASLB
    JSR   SCORE_ADD_AB_SETTINGS ; Add to score
    STX   7,U ; Screen pos to player data.
    LDA   #$04 ; Callback timer.
    LDX   #$DE66 ; Callback area.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Set task.
CALLBACK_WAVE_END_HUMANOIDS: ; 0x000E66, $DE66
    LDX   7,U ; Get screen pos.
    DEC   9,U ; Dec humanoid counter.
    BNE   HUMANOID_DISPLAY_LOOP
NO_MORE_HUMANOIDS_TO_DISPLAY: ; 0x000E6C, $DE6C
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get ptr.
    JSR   END_WAVE_EXTRAS_HUMANOIDS+DIFFICULTY
    LDA   #$80 ; Timer for callback.
    LDX   #$DE79 ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Set task.
CALLBACK_WAVE_END_WAIT: ; 0x000E79, $DE79
    JMP   [13,U] ; Jumps to RTN in 13,U
END_WAVE_EXTRAS_HUMANOIDS+DIFFICULTY: ; 0x000E7C, $DE7C
    PSHS  U,X,B,A ; Save
    INC   8,X ; PLAYER[8], wave?
    LDX   #$C49D ; Sram ptr
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get data. Number between new humanoids?
    STA   A073_SCRATCHPAD_ADDR ; Store to.
    LDX   2,S ; Restore player ptr
    TSTA ; Test SRAM loaded.
    BEQ   NO_NEW_PLANET ; If we loaded 0, never new planet.
    LDA   8,X ; Load wave
TEST_RESET_HUMANOIDS: ; 0x000E8F, $DE8F
    SUBA  A073_SCRATCHPAD_ADDR ; Sub with sram val
    BCS   NO_NEW_PLANET ; If we went negative, not modulo even.
    BNE   TEST_RESET_HUMANOIDS ; If it's not 0, try again.
    LDA   #$0A ; Store
    STA   10,X ; PLAYER[10], humanoid count?
NO_NEW_PLANET: ; 0x000E99, $DE99
    JSR   BANKSWITCH_TO_7 ; Goto bank.
    LDA   8,X ; PLAYER[8], wave
    PSHS  A ; Save wave.
    CMPA  #$04 ; Compare to 4
    BLS   USE_VAL_<=_4
    LDA   #$04 ; Cap
USE_VAL_<=_4: ; 0x000EA6, $DEA6
    LDU   DIFFICULTY_DATA_START_LOC ; Load PTR from bank 7.
    ADDA  #$03 ; A+=3, slot 4 to 7 as base add?
    LEAX  11,X ; PLAYER[11] base
LOOP_DIFFICULTY_BASE_WRITE: ; 0x000EAD, $DEAD
    LDB   A,U ; Get B from U[A]
    STB   X+ ; Store to PLAYER[11+X]
    LEAU  8,U ; U+=8
    CMPU  DIFFICULTY_DATA_END_LOC ; See if at end. 23 bytes
    BNE   LOOP_DIFFICULTY_BASE_WRITE ; Loop if not there.
    PULS  A ; Restore A, wave raw
    SUBA  #$04 ; A-=4
    BCC   DIDNT_GO_NEGATIVE ; A >= 4, dont zero.
    CLRA ; Clear if went negative.
DIDNT_GO_NEGATIVE: ; 0x000EC0, $DEC0
    STA   A073_SCRATCHPAD_ADDR ; Wave - 4 or 0
    LDX   #$C497 ; SRAM PTR
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Get word
    JSR   DECIMAL_BACK_TO_HEX_A ; Back to
    ADDA  A073_SCRATCHPAD_ADDR ; Add with wave - 4 to get base.
    STA   A073_SCRATCHPAD_ADDR ; Store to, wave + base.
    BEQ   RTS ; If 0, leave.
    TFR   B>A ; Put B to A.
    JSR   DECIMAL_BACK_TO_HEX_A ; Do rtn on B
    CMPA  A073_SCRATCHPAD_ADDR ; If A _ Other
    BCC   SKIP_COMMIT ; >=, skip.
    STA   A073_SCRATCHPAD_ADDR ; Commit lower A
SKIP_COMMIT: ; 0x000EDC, $DEDC
    LDA   A073_SCRATCHPAD_ADDR ; Load lowest, WAVE - 4 | MAX
MORE_DIFFICULTY_MANIP: ; 0x000EDE, $DEDE
    LDB   #$03 ; Slot index in STEP_DIFFICULTY
    JSR   GET_PLAYER_PTR_IN_X_FROM_A08B ; Get player X ptr
    LEAY  11,X ; Y = PLAYER[11]
    BSR   STEP_DIFFICULTY@Y_WITH_TBL_OFFSET@B ; Player difficulty step.
    DECA ; A--
    BNE   MORE_DIFFICULTY_MANIP ; Do more.
RTS: ; 0x000EEA, $DEEA
    PULS  A,B,X,U,PC ; RTS
STEP_DIFFICULTY@Y_WITH_TBL_OFFSET@B: ; 0x000EEC, $DEEC
    PSHS  Y,X,A ; Save
    JSR   BANKSWITCH_TO_7 ; Bank 7
    LDX   DIFFICULTY_DATA_START_LOC ; Get difficult pointer
LOOP_X_PTR: ; 0x000EF4, $DEF4
    LDA   B,X ; Get data at DIFF_LOC[B]
    BMI   DATA_MINUS ; If negative, goto.
    ADDA  Y ; Add positive
    BCS   DONT_COMMIT_TO_PLAYER ; If overflow, taken.
    CMPA  X ; Compare to data pointed to.
    BHI   DONT_COMMIT_TO_PLAYER ; If A higher (signed), goto.
    BRA   COMMIT_TO_PLAYER ; Is good to commit.
DATA_MINUS: ; 0x000F02, $DF02
    ADDA  Y ; Add player data, aka sub.
    BCC   DONT_COMMIT_TO_PLAYER ; If underflow.
    CMPA  1,X ; Compare to PLAYER+1
    BCS   DONT_COMMIT_TO_PLAYER ; If PLAYER+1 is lower, goto.
COMMIT_TO_PLAYER: ; 0x000F0A, $DF0A
    STA   Y ; If it's higher, store to player data.
DONT_COMMIT_TO_PLAYER: ; 0x000F0C, $DF0C
    LEAY  1,Y ; Player data++
    LEAX  8,X ; Difficulty data+=8, 1 slot?
    CMPX  DIFFICULTY_DATA_END_LOC ; See if end.
    BNE   LOOP_X_PTR ; Loop if not end.
    PULS  A,X,Y,PC ; RTS, Restore.
IRQ_INITIAL_P1: ; 0x000F17, $DF17
    CLR   BANKSWITCH ; Set to IO
    LDA   #$A0 ; Setup DP
    TFR   A>DP
    LDA   #$04 ; PIA CTRL setting no interrupts, output reg direction.
    STA   PIA_ROM_CTRL_B ; Set setting
    LDA   PIA_ROM_DATA_B ; Clear IRQs
    LDA   VIDEO_COUNTER_BITS ; Load scanline.
    CMPA  #$80
    BCS   VADD_BOTTOM_HALF_SCREEN ; Top half, goto lower half stuff?
    LDA   IRQ_NEXT_STEP_TODO ; Load val
    BNE   LEAVE_IRQ_RTN ; If != 0, leave.
    INC   IRQ_NEXT_STEP_TODO ; Mark processing this currently.
    JSR   SOUND_AND_INPUT_MANAGE ; Do subs
    JSR   MOVEMENT+CAMERA?
    JSR   STARS_UPDATE?
    LDA   VIDEO_COUNTER_BITS ; Load counter
    SUBA  #$08 ; -=8
    CMPA  #$A8 ; If A _ Scanline 168
    BLS   DONT_CAP_A ; <=, goto.
    LDA   #$A8 ; Cap
DONT_CAP_A: ; 0x000F47, $DF47
    STA   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+1 ; Store to bits
    LDA   #$02
    STA   BANKSWITCH ; Bankswitch to 2
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+1
    JSR   IRQ_RTN_WORLD_ENEMIES_UPDATE_SCR_POS/DISPLAY
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+1
    JSR   SHIP_MOVE_RTN
    JSR   BULLETS_PROCESS_RTN
    BRA   LEAVE_IRQ_RTN ; Leave IRQ RTN
VADD_BOTTOM_HALF_SCREEN: ; 0x000F5D, $DF5D
    LDB   IRQ_NEXT_STEP_TODO ; Load val
    BEQ   LEAVE_IRQ_RTN ; If 0, nothing to do here.
    CLR   IRQ_NEXT_STEP_TODO ; Clear
    INC   TICKS_HAPPENED_COUNTER? ; Inc
    LDB   #$38
    STB   WATCHDOG ; Set watchdog.
    CMPA  #$08 ; VADDR
    BHI   DONT_SET_PALETTE ; VADDR > 8, dont set palette.
    LDU   #$C010 ; Color palette stack ptr.
    LDD   COLOR_PALETTE_RAM_COPY+10
    LDX   COLOR_PALETTE_RAM_COPY+12
    LDY   COLOR_PALETTE_RAM_COPY+14
    PSHU  Y,X,B,A
    LDD   COLOR_PALETTE_RAM_COPY+4
    LDX   COLOR_PALETTE_RAM_COPY+6
    LDY   COLOR_PALETTE_RAM_COPY+8
    PSHU  Y,X,B,A
    LDD   COLOR_PALETTE_RAM_COPY
    LDX   COLOR_PALETTE_RAM_COPY+2
    PSHU  X,B,A
DONT_SET_PALETTE: ; 0x000F89, $DF89
    JSR   CHECK_COINDOOR_INPUT ; Check coin door input.
    LDA   #$07
    STA   BANKSWITCH ; Bankswitch to 7
    LDA   A0BA_PLAYER_GAME_STATE
    BITA  #$02 ; Test bit on val
    BNE   SKIP_BANK7_RTN ; If set, skip JSR below.
    JSR   JMP_TO_LAND_IRQ
SKIP_BANK7_RTN: ; 0x000F9A, $DF9A
    LDA   #$02
    STA   BANKSWITCH ; Bank to 2
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG ; Load val
    JSR   SHIP_MOVE_RTN ; IDK
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG ; Load val again
    JSR   IRQ_RTN_WORLD_ENEMIES_UPDATE_SCR_POS/DISPLAY ; IDK
    JSR   MOVE_ONSCREEN_OBJECTS ; IDK
LEAVE_IRQ_RTN: ; 0x000FAC, $DFAC
    ORCC  #$FF ; Mask interrupts.
    CLR   BANKSWITCH ; Set to IO
    LDA   #$05 ; CTRL, C1 enable
    STA   PIA_ROM_CTRL_B ; COUNT_240_IRQ enable.
    LDA   CURRENT_BANK ; Load bank was.
    STA   BANKSWITCH ; Restore.
    LDA   S ; Get CC on stack.
    ANDA  #$6F ; Clear Entire+IRQ mask.
    STA   S ; Put that back.
    PULS  CC,A,B,DP,X,Y,U,PC ; RTI manually since we unset entire?
IRQ_INITIAL_P2: ; 0x000FC3, $DFC3
    CLR   BANKSWITCH ; Set to IO
    LDA   #$A0 ; DP
    TFR   A>DP
    LDA   #$04 ; Sets no interrupts from, DDR Output
    STA   PIA_ROM_CTRL_B ; Store, reading port data.
    LDA   PIA_ROM_DATA_B ; Clear IRQ from ROM PIA.
    LDA   VIDEO_COUNTER_BITS ; Get video counter.
    CMPA  #$58 ; If _ #$58
    BCS   VIDEO_COUNTER_BITS_UNDER_#$58 ; <, goto.
    LDB   IRQ_NEXT_STEP_TODO ; Get val
    BNE   LEAVE_IRQ_RTN ; If != 0, goto.
    INC   IRQ_NEXT_STEP_TODO ; Inc if 0
    COMA ; Invert video bits because flipped screen.
    NOP ; Nop
    STA   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+1 ; Store inverted here.
    JSR   CHECK_COINDOOR_INPUT ; Do coin door input
    LDA   #$07
    STA   BANKSWITCH ; Bankswitch to 7
    LDA   A0BA_PLAYER_GAME_STATE ; Val
    BITA  #$02 ; If bit 2 is set.
    BNE   SKIP_LAND_TASK ; Skip land task flag.
    JSR   JMP_TO_LAND_IRQ ; Do this if set.
SKIP_LAND_TASK: ; 0x000FF4, $DFF4
    LDA   #$02 ; Bank 2
    STA   BANKSWITCH
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG ; Load val
    JSR   SHIP_MOVE_RTN
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG ; Load val
    JSR   IRQ_RTN_WORLD_ENEMIES_UPDATE_SCR_POS/DISPLAY
    BRA   LEAVE_IRQ_RTN ; Leaves
VIDEO_COUNTER_BITS_UNDER_#$58: ; 0x001005, $E005
    LDB   IRQ_NEXT_STEP_TODO
    BEQ   LEAVE_IRQ_RTN ; Leaves if 0
    CLR   IRQ_NEXT_STEP_TODO ; Clear
    INC   TICKS_HAPPENED_COUNTER? ; Inc
    LDB   #$39 ; Always flipped?
    STB   WATCHDOG ; Store
    CMPA  #$04 ; Video counter bits.
    BHI   VIDEO_COUNTER_>_4 ; If > 4, goto.
    LDU   #$C010 ; Ptr
    LDD   COLOR_PALETTE_RAM_COPY+10 ; Load
    LDX   COLOR_PALETTE_RAM_COPY+12 ; Load
    LDY   COLOR_PALETTE_RAM_COPY+14 ; Load
    PSHU  Y,X,B,A ; Push all loaded to stack
    LDD   COLOR_PALETTE_RAM_COPY+4 ; Load
    LDX   COLOR_PALETTE_RAM_COPY+6 ; Load
    LDY   COLOR_PALETTE_RAM_COPY+8 ; Load
    PSHU  Y,X,B,A ; Push all to stack.
    LDD   COLOR_PALETTE_RAM_COPY ; Load
    LDX   COLOR_PALETTE_RAM_COPY+2 ; Load
    PSHU  X,B,A ; Push to stack.
VIDEO_COUNTER_>_4: ; 0x001031, $E031
    JSR   SOUND_AND_INPUT_MANAGE
    JSR   MOVEMENT+CAMERA?
    JSR   STARS_UPDATE?
    LDA   #$02
    STA   BANKSWITCH
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+1
    JSR   SHIP_MOVE_RTN
    LDD   SCR_DMG_ZONE_[FROM,CNTR,TO]_ARR_CONFIG+1 ; This load is very cool.
    JSR   IRQ_RTN_WORLD_ENEMIES_UPDATE_SCR_POS/DISPLAY
    JSR   BULLETS_PROCESS_RTN
    JSR   MOVE_ONSCREEN_OBJECTS
    JMP   LEAVE_IRQ_RTN
INIT_ALL_STARS: ; 0x001052, $E052
    LDX   #$AF9D ; Ptr to stars data.
    LDB   #$10 ; Num stars?
    STB   STARS_NUM_TO_CHANGE? ; Seed change count when initing.
    CLRB
LOOP_MORE_STARS: ; 0x00105A, $E05A
    JSR   RANDOM_VALUE_FWD+IN_A ; Get val.
    CMPA  #$9C ; If _ #$9C
    BCC   LOOP_MORE_STARS ; >=, get another number. Invalid column byte.
    STA   X ; <9C gets stored,  STAR[0]
TRY_NEW_RANDOM_VAL: ; 0x001063, $E063
    JSR   RANDOM_VALUE_FWD+IN_A ; Get val.
    CMPA  #$A8 ; If _ #$A8
    BHI   TRY_NEW_RANDOM_VAL ; >, Get another.
    CMPA  #$2A ; If _ #$2A
    BLS   TRY_NEW_RANDOM_VAL ; <=, get another.
    STA   1,X ; Store to X[1], STAR[1], POS_Y
    STB   2,X ; Store to X[2], STAR[2], color.
    ADDB  #$11 ; Add with value
    ANDB  #$77 ; Limit bits on each nibble.
    LEAX  4,X ; X+=4, next star.
    CMPX  #$AFDD ; End star data, total 16 stars.
    BNE   LOOP_MORE_STARS ; Set up all 16.
RTS_STARS: ; 0x00107D, $E07D
    RTS ; RTS
STARS_UPDATE?: ; 0x00107E, $E07E
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BITA  #$20 ; Test bit
    BNE   RTS_STARS ; If not set, RTS
    LDX   #$AF9D ; Load, stars PTR
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load val
    ANDB  #$80 ; Clear bottom 7
    STD   STAR_SCREEN_DELTA ; Store
    LDD   R_A022_SCREEN_POS_HORIZ_2_TRGT? ; Load
    ANDB  #$80 ; Clear bottom 7
    SUBD  STAR_SCREEN_DELTA ; Sub with
    ASLB ; D << 1
    ROLA
    STA   STAR_SCREEN_DELTA ; Store to
    LDB   #$F0 ; Load, star bit mask.
    LDA   R_A020_SCREEN_POS_HORIZ_1_CURR?+1 ; Load BOTTOM value.
    BITA  #$40 ; Test bit. Even odd star switch?
    BNE   SKIP_INVERT_B  ; If set, goto.
    COMB ; Invert mask to 0x0F.
SKIP_INVERT_B : ; 0x0010A0, $E0A0
    STB   STAR_DISPLAY_MASK ; Store B
    CLRA ; Clear
    STA   [X] ; XOBJ[0], clears star.
    STA   [4,X] ; XOBJ[4]
    STA   [8,X] ; XOBJ[8]
    STA   [12,X] ; XOBJ[12]
    STA   [16,X] ; XOBJ[16]
    STA   [20,X] ; XOBJ[20]
    STA   [24,X] ; XOBJ[24]
    STA   [28,X] ; XOBJ[28]
    STA   [32,X] ; XOBJ[32]
    STA   [36,X] ; XOBJ[36]
    STA   [40,X] ; XOBJ[40]
    STA   [44,X] ; XOBJ[44]
    STA   [48,X] ; XOBJ[48]
    STA   [52,X] ; XOBJ[52]
    STA   [56,X] ; XOBJ[56]
    STA   [60,X] ; XOBJ[60]
    LDB   STARS_NUM_TO_CHANGE? ; Get B
LOOP_UPDATE_STARS_COUNT: ; 0x0010D4, $E0D4
    LDA   X ; A from STAR[0], HPOS
    ADDA  STAR_SCREEN_DELTA ; Add with val
    CMPA  #$9C ; CMP to SCREEN_HIGH_MAX?
    BCS   STAR_HPOS_KEEP ; <, goto.
    CMPA  #$C0 ; 0x9C - 0xC0, to leftmost edge.
    BLS   LOAD_A_ZERO ; <=, goto.
    LDA   #$9B ; Rightmost edge otherwise.
    BRA   STAR_HPOS_KEEP ; Always goto
LOAD_A_ZERO: ; 0x0010E4, $E0E4
    LDA   #$00 ; STAR_HPOS_OFFSCREEN, leftmost edge.
STAR_HPOS_KEEP: ; 0x0010E6, $E0E6
    STA   X ; Store to STAR[0]
    LDA   2,X ; Load STAR[2], color.
    ANDA  STAR_DISPLAY_MASK ; AND with val.
    STA   [0,X] ; MISTAKE wrong addrmode? A to X ptr. Store to STAR[0] loc.
    LEAX  4,X ; Next star.
    DECB ; B--
    BNE   LOOP_UPDATE_STARS_COUNT ; If not 0, loop.
    LDB   A0DF_RAND_BYTE ; Get random byte
    ANDB  #$3C ; Get 0011.1100, star index in B.
    LDX   #$AF9D ; Load list to stars.
    ABX ; X+X, star index.
    LDA   2,X ; A from X+2, STAR[2], color.
    ADDA  #$11 ; Next color.
    ANDA  #$77 ; Range
    STA   2,X ; Store new color.
    LDA   A0DF_RAND_BYTE ; Get random val.
    BITA  #$01 ; Test bit
    BNE   RTS ; If set, leave.
    CMPA  #$98 ; If _ #$98
    BCS   STAR_HPOS_IS_VALID ; <, goto. Valid HPOS for star.
    LDU   #$A102 ; Ptr to IDK
    LEAU  -74,U ; U-=74, U now A0B8
    LDU   U ; U.next from A0B8
    CMPU  #$6245 ; U _ val. Copy protection value.
    BEQ   PASS_COPY_PROTECTION ; If EQ
    TST   A0BA_PLAYER_GAME_STATE ; Test
    BMI   PASS_COPY_PROTECTION ; If top bit set, don't crash.
    CMPA  #$A0 ; CMP #$A0
    BCS   PASS_COPY_PROTECTION ; <, goto.
    CMPA  #$A1 ; If _ val
    BCC   PASS_COPY_PROTECTION ; >=, goto.
    LDB   A0E0_RAND_WORD+1 ; B random, lower addr byte.
    TFR   D>X ; D to X, val range A0XX.
    LDB   A0E0_RAND_WORD ; Load random val
    STB   X ; Store to A0XX range. Copy protection commital.
PASS_COPY_PROTECTION: ; 0x001130, $E130
    SUBA  #$84 ; A -= 84
STAR_HPOS_IS_VALID: ; 0x001132, $E132
    CLR   [0,X] ; Clear STAR[X], also mistake. Used wrong offset addrmode, +1 byte code size.
    STA   X ; Store HPOS, STAR[0]
    LDA   A0BA_PLAYER_GAME_STATE
    BITA  #$02 ; Test game state bit 0000.0010
    BEQ   RTS ; If game state not set, RTS. Flag for no planet?
    LDA   A0E0_RAND_WORD+1 ; Get random.
    ANDA  #$3F ; Get bits 0011.1111
    LDB   #$03 ; B = 3
    MUL ; Multiply vals, 0x00 up to 0xBD
    ADDB  #$2A ; Add #$2A, range 0x2A to 0xE7
    STB   1,X ; Store B to XXYY ptr?
RTS: ; 0x001148, $E148
    RTS
SETUP_RANDOM_VALUES_A162-A182,A182-A1A2: ; 0x001149, $E149
    LDX   #$A162 ; PTR
    STX   PTR_TO_A162_POOL ; Store
LOOP_RANDOM: ; 0x00114E, $E14E
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random.
    STA   32,X ; Store to X+32, pool is from A162 to A1A2?
    STA   X+ ; Store to X
    CMPX  #$A183 ; Becuase of X inc, not off by one, is correct.
    BNE   LOOP_RANDOM ; Loop
    RTS ; Leave
DRAW_THRUST_TO_LEFT: ; 0x00115C, $E15C
    LDX   PTR_TO_A162_POOL ; X from
    LDU   SHIP_SCR_POS_XXYY ; U from
    LEAU  -255,U ; X-1, Y+1
    LDD   X ; Load from X
    STD   U ; Store to U
    LDA   5,X ; Load 
    LDB   9,X ; Load
    STD   2,U ; Store to
    LDA   12,X ; Load
    STA   4,U ; Store
    LDA   WGT_DATA_A_RAM_COPY
    BITA  #$02 ; If thrust pressed.
    BEQ   RTS ; Not pressed, RTS.
    LDA   3,X ; Load
    LDB   6,X ; Load
    STD   -255,U ; Store
    LDA   10,X ; Load
    STA   -253,U ; Store
    LDA   4,X ; Load
    LDB   7,X
    STD   -511,U ; Store
    LDA   11,X ; Load
    STA   -509,U ; Store
    LDA   8,X ; Load
    STA   -766,U ; Store
RTS: ; 0x00119A, $E19A
    RTS
DRAW_THRUST_TO_RIGHT: ; 0x00119B, $E19B
    LDU   PTR_TO_A162_POOL ; Load val
    LDX   SHIP_SCR_POS_XXYY ; Lod val
    LEAX  2049,X ; X+8,Y+1
    PULU  A,B,Y ; Pull from U
    STD   X ; Val to X
    STY   2,X ; Val to X[2]
    PULU  A,B,Y ; Pull
    STA   4,X ; Val to OBJ[4]
    LDA   WGT_DATA_A_RAM_COPY ; Load
    BITA  #$02 ; Test thrust
    BEQ   RTS ; Not pressed.
    STB   257,X ; B to. Thrust drawn?
    STY   258,X ; Y to
    PULU  A,B,Y
    STY   513,X ; Y to
    STA   515,X ; A to
    STB   770,X ; B to
RTS: ; 0x0011CC, $E1CC
    RTS
CLEAR_THRUST_MOVING_LEFT: ; 0x0011CD, $E1CD
    LDU   SHIP_SCR_POS_XXYY ; Load stack
    CLRB ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear Y
    LEAU  2054,U ; U,X+16px,Y+6
    PSHU  Y,X,B ; Clear 5Y
    STX   257,U ; Clear +1Y,3H
    STB   259,U
    STX   513,U ; Clear +2Y,3h
    STB   515,U
    STB   770,U ; Clear +3Y, 1h
    RTS
CLEAR_THRUST_MOVING_RIGHT: ; 0x0011F0, $E1F0
    LDU   SHIP_SCR_POS_XXYY ; Load stack
    CLRB ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    LEAU  -250,U ; X-1,Y+6
    PSHU  Y,X,B ; Clear 5
    STX   -255,U ; Clear X-1,Y-1,3B
    STB   -253,U
    STX   -511,U ; Clear X-2,Y-1,3B
    STB   -509,U
    STB   -766,U ; Clear X-3,Y-2,1B
    RTS
SHIP_MOVE_RTN: ; 0x001213, $E213
    STA   SMASH_S_SAVE_AND_TEMP ; Save
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$10 ; Test bit
    BNE   RTS_FROM_SHIP_MOVE? ; If set, leave.
    LDA   SMASH_S_SAVE_AND_TEMP ; Load saved.
    CMPA  SHIP_SCR_POS_XXYY+1 ; If A _ Loc
    BLS   RTS_FROM_SHIP_MOVE? ; <=, goto.
    CMPB  SHIP_SCR_POS_XXYY+1 ; If B _ Loc
    BHI   RTS_FROM_SHIP_MOVE? ; >, goto.
    LDA   R_A0BD_UNK_DIR_UNK ; Load val
    BMI   DIFF_JSR_SET ; If negative, goto.
    JSR   CLEAR_16X6_AT_SHIP ; MISTAKE: Code could be improved here. Using shared 16x6 clear.
    JSR   CLEAR_THRUST_MOVING_RIGHT
    BRA   SKIP_OTHER_SET ; Skip other subs.
DIFF_JSR_SET: ; 0x001231, $E231
    JSR   CLEAR_16X6_AT_SHIP
    JSR   CLEAR_THRUST_MOVING_LEFT
SKIP_OTHER_SET: ; 0x001237, $E237
    LDD   SHIP_DIRECTION_300/FD00 ; Move val
    STD   R_A0BD_UNK_DIR_UNK
    BMI   D_NEGATIVE ; If negative, goto.
    JSR   RTN_SHIP_FACING_RIGHT
    JSR   DRAW_THRUST_TO_LEFT
RTS_FROM_SHIP_MOVE?: ; 0x001243, $E243
    RTS ; Leave
D_NEGATIVE: ; 0x001244, $E244
    JSR   RTN_SHIP_FACING_LEFT
    JMP   DRAW_THRUST_TO_RIGHT
RTN_SHIP_FACING_RIGHT: ; 0x00124A, $E24A
    LDY   #$F9C1
MOVE_THING: ; 0x00124E, $E24E
    LDA   R_A0C3_SHIP_SCR_HPOS?+1 ; Load
    ASLA ; Into carry
    LDD   R_A0C1_SHIP_UNK ; Move
    STD   SHIP_SCR_POS_XXYY
    JMP   GFX_16X6_MOVE+ADJUST ; Put to screen
RTN_SHIP_FACING_LEFT: ; 0x001258, $E258
    LDY   #$F9CB ; BITMAP ptr
    BRA   MOVE_THING ; Move
CLEAR_16X6_AT_SHIP: ; 0x00125E, $E25E
    LDD   SHIP_SCR_POS_XXYY ; Pos?
    JMP   GFX_CLEAR_16X6 ; Move
MOVEMENT+CAMERA?: ; 0x001263, $E263
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$40 ; Test bit
    LBNE  RTS ; RTS if set.
    CLR   STAR_SCREEN_DELTA ; Clear
    LDD   SCREEN_H_DELTA ; Load
    COMA ; Invert
    COMB
    ADDD  #$0001 ; +1
    BPL   SKIP_INVERT_ADDR ; If positive
    COM   STAR_SCREEN_DELTA ; Invert
SKIP_INVERT_ADDR: ; 0x001278, $E278
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    ADDD  SCREEN_H_DELTA+1 ; D +=
    STD   SCREEN_H_DELTA+1 ; D to
    LDA   STAR_SCREEN_DELTA ; Load
    ADCA  SCREEN_H_DELTA ; Add with carry
    STA   SCREEN_H_DELTA ; Store
    LDD   SCREEN_H_DELTA ; Load into D
    LDA   WGT_DATA_A_RAM_COPY ; Get input
    BITA  #$02 ; Test if thrust
    BEQ   THRUST_NOT_PRESSED ; If 1, taken
    CLR   STAR_SCREEN_DELTA ; Clear
    LDD   R_A0BD_UNK_DIR_UNK ; Load
    BPL   SKIP_INVERT ; If positive, goto
    COM   STAR_SCREEN_DELTA ; Invert
SKIP_INVERT: ; 0x001296, $E296
    ADDD  SCREEN_H_DELTA+1 ; Add with
    STD   SCREEN_H_DELTA+1 ; Store to
    LDA   STAR_SCREEN_DELTA ; Load
    ADCA  SCREEN_H_DELTA ; Add with carry
    STA   SCREEN_H_DELTA ; Store to
THRUST_NOT_PRESSED: ; 0x0012A0, $E2A0
    LDD   SCREEN_H_DELTA ; Get word
    ASRA ; D >> 2
    RORB
    ASRA
    RORB
    CLRA ; A=0
    ASRB ; B >> 1
    RORA ; Bring B into A sign?
    STA   R_A094_THRUST_UNK_A2 ; Store
    STB   R_A093_SHIP_SUCTION_TO ; Store
    LDA   R_A0BD_UNK_DIR_UNK ; Load
    BMI   SUCTION_DIFF ; If negative, goto.
    LDA   #$20 ; Left ship wall
    TSTB ; Test B
    BMI   CLEAR_BEFORE_RTN ; If B negative.
    BRA   SKIP_CLEARS ; Always went to.
SUCTION_DIFF: ; 0x0012B8, $E2B8
    LDA   #$70 ; Right ship wall
    TSTB ; Test B
    BMI   SKIP_CLEARS ; If negative, goto. Skip clears.
CLEAR_BEFORE_RTN: ; 0x0012BD, $E2BD
    CLR   R_A094_THRUST_UNK_A2 ; Clear
    CLR   R_A093_SHIP_SUCTION_TO ; Clear
SKIP_CLEARS: ; 0x0012C1, $E2C1
    LDB   R_A094_THRUST_UNK_A2 ; Load
    ADDA  R_A093_SHIP_SUCTION_TO ; Add
    STA   R_A093_SHIP_SUCTION_TO ; Store
    SUBD  R_A0C3_SHIP_SCR_HPOS? ; Sub value with loc
    BEQ   CLEAR_95 ; If 0, goto
    BCS   CMPD_TO_#$FF00 ; If value subbed was higher, goto.
    CMPD  #$0100 ; Subbed was lower.
    BLS   CLEAR_95 ; If <= val, goto.
    LDD   #$0040 ; Load with
    STD   R_A095_CAM_HMOD ; Store to.
    LDD   #$0100 ; Load
    ADDD  R_A0C3_SHIP_SCR_HPOS? ; Add with
    BRA   D_TO_C3 ; Goto
CMPD_TO_#$FF00: ; 0x0012DF, $E2DF
    CMPD  #$FF00 ; Comp to
    BGT   CLEAR_95 ; If >, goto
    LDD   #$FFC0 ; Load val
    STD   R_A095_CAM_HMOD ; Store to
    LDD   #$FF00 ; Load val
    ADDD  R_A0C3_SHIP_SCR_HPOS? ; Store to
    BRA   D_TO_C3
CLEAR_95: ; 0x0012F1, $E2F1
    CLRA
    CLRB
    STD   R_A095_CAM_HMOD ; Clear
    LDD   R_A093_SHIP_SUCTION_TO ; Move
D_TO_C3: ; 0x0012F7, $E2F7
    STD   R_A0C3_SHIP_SCR_HPOS? ; Store
    STA   R_A0C1_SHIP_UNK ; Store to
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load
    STD   R_A022_SCREEN_POS_HORIZ_2_TRGT? ; Store
    LDD   SCREEN_H_DELTA ; Load
    CMPD  #$0100 ; If D _ val
    BLT   DONT_APPLY_HMAX ; <, set
    LDD   #$0100 ; Max
DONT_APPLY_HMAX: ; 0x00130A, $E30A
    CMPD  #$FF00 ; Compare to
    BGT   DONT_APPLY_HMIN ; If >, don't apply min.
    LDD   #$FF00 ; Min
DONT_APPLY_HMIN: ; 0x001313, $E313
    STD   SCREEN_H_DELTA ; Store
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add with, moving screen.
    SUBD  R_A095_CAM_HMOD ; Sub from
    STD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Store new final pos?
    LDD   R_A0C3_SHIP_SCR_HPOS? ; Load
    LSRA ; D >> 2
    RORB
    LSRA
    RORB
    ANDB  #$E0 ; Mask bits ***0.0000
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add with HPOS
    STD   R_A0CC_SHIP_W_POS? ; Store to ship pos.
    LDB   SHIP_VPOS ; Load
    LDA   WGT_DATA_B_RAM_COPY
    LSRA ; Test UP bit
    BCS   UP_SET
    LDA   WGT_DATA_A_RAM_COPY
    BMI   DOWN_SET ; If down set
    LDD   #$0000 ; No SHIP VPOS change.
    BRA   COMMIT_D_AS_VCHANGE
UP_SET: ; 0x001337, $E337
    CMPB  #$2B ; Compare PLAYER.VPos to val
    BLS   RTS ; <=, RTS, top of screen already.
    LDD   PLAYER_V_MOMENTUM ; Load momentum?
    BPL   SET_UNIT_UP ; If positive, aka going down, up unit.
    ADDD  #$FFF8 ; Add sub unit
    CMPD  #$FE00 ; If _ val
    BGE   COMMIT_D_AS_VCHANGE ; >, write.
    LDD   #$FE00 ; Cap
    BRA   COMMIT_D_AS_VCHANGE ; Commit
SET_UNIT_UP: ; 0x00134D, $E34D
    LDD   #$FF00 ; If going down, instantly change to 1 unit up.
    BRA   COMMIT_D_AS_VCHANGE ; Commit val
DOWN_SET: ; 0x001352, $E352
    CMPB  #$EE ; PLAYER.VPos
    BCC   RTS ; If >=, RTS
    LDD   PLAYER_V_MOMENTUM ; Get momentum?
    BLE   SET_UNIT_DOWN ; If <= 0, aka going up, set to 1 unit.
    ADDD  #$0008 ; Add with sub unit.
    CMPD  #$0200 ; Map
    BLS   COMMIT_D_AS_VCHANGE ; <=, save.
    LDD   #$0200 ; Cap
    BRA   COMMIT_D_AS_VCHANGE ; Alaways do.
SET_UNIT_DOWN: ; 0x001368, $E368
    LDD   #$0100 ; Instantly move 1 unit per.
    BRA   COMMIT_D_AS_VCHANGE ; This can be taken out rofl.
COMMIT_D_AS_VCHANGE: ; 0x00136D, $E36D
    STD   PLAYER_V_MOMENTUM ; Store momentum.
    ADDD  SHIP_VPOS ; Add to player VPos
    STD   SHIP_VPOS ; Store to VPos
    STA   R_A0C1_SHIP_UNK+1 ; Store here too, idk why.
RTS: ; 0x001375, $E375
    RTS ; Leave
MOVE_ONSCREEN_OBJECTS: ; 0x001376, $E376
    LDA   A0BA_PLAYER_GAME_STATE ; State?
    BITA  #$20 ; Test bit
    BNE   RTS ; If set, RTS
    LDX   #$A065 ; List
    BRA   X_TO_X.NEXT
VALID_OBJ_PROCESS: ; 0x001381, $E381
    LDD   10,X ; Load X[10]
    ADDD  14,X ; Add X[14]
    STD   10,X ; Store to X[10]
    LDD   12,X ; Load X[12]
    ADDD  16,X ; Add X[16]
    CMPA  #$2A ; If _ #$2A
    BCC   DONT_WRAP_TO_BOTTOM ; >=, goto.
    LDA   #$F0 ; Wrap to bottom of screen.
DONT_WRAP_TO_BOTTOM: ; 0x001392, $E392
    CMPA  #$F0 ; If _ #$F0
    BLS   DONT_WRAP_TO_TOP_OF_GAMEPLAY_AREA ; <=, goto
    LDA   #$2A ; Wrap to top of play area.
DONT_WRAP_TO_TOP_OF_GAMEPLAY_AREA: ; 0x001398, $E398
    STD   12,X ; Store to OBJ[12]
X_TO_X.NEXT: ; 0x00139A, $E39A
    LDX   X ; X = X.next
    BNE   VALID_OBJ_PROCESS ; Process if !=NULL
RTS: ; 0x00139E, $E39E
    RTS
IRQ_RTN_WORLD_ENEMIES_UPDATE_SCR_POS/DISPLAY: ; 0x00139F, $E39F
    PSHS  B,A ; S[0] == 0xFF, S[1] == 0x70
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$20 ; Test bit
    BNE   RTS ; If set, leave.
    LDX   #$A065 ; Load list ptr, LIST_IN_WORLD
    BRA   X_TO_X.next ; Into list obj.
PROCESS_OBJ_DETERMINE: ; 0x0013AC, $E3AC
    LDD   4,X ; Load SCREEN_POS
    BEQ   SCRPOS_IS_NULL ; If zero, goto. Means not on screen.
    CMPB  S ; Compare to FF
    BHI   X_TO_X.next ; If higher than stack, next obj.
    CMPB  1,S ; Compare to 70
    BLS   X_TO_X.next ; <=, next obj.
    LDY   2,X ; Load Y from OBJ[Y]
    JSR   [8,Y] ; Clear off screen.
    CLRA ; Clear D
    CLRB
    STD   4,X ; Clear OBJ[4], no POS_SCREEN
SCRPOS_IS_NULL: ; 0x0013C2, $E3C2
    LDB   12,X ; Load WORLD_V
    CMPB  S ; B _ S[0], FF
    BHI   X_TO_X.next ; If B if higher, next.
    CMPB  1,S ; S[1], 70.
    BLS   X_TO_X.next ; If B <=, goto.
    LDD   10,X ; Load OBJ[10], POS_WORLDH
    SUBD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Sub with val
    CMPD  #$2580 ; Compare to val
    BCC   X_TO_X.next ; If D >= Val, goto.
    LDY   2,X ; OBJ[2], GFX_PTR
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    ADDA  Y ; Add A with BMP_WIDTH
    CMPA  #$9C ; If A _ #$9C
    BHI   X_TO_X.next ; >, next obj. Screen officially has margin on right?
    SUBA  Y ; Subtrack added to get POS original.
    ASLB ; Shift B, filling out carry. Even/odd BMP flag.
    LDB   12,X ; B from POS_WORLD_V
    STD   4,X ; Store D to OBJ[4], SCR_POS
    JSR   [6,Y] ; Put on screen call.
X_TO_X.next: ; 0x0013ED, $E3ED
    LDX   X ; To X.next
    BNE   PROCESS_OBJ_DETERMINE ; If not null, process.
RTS: ; 0x0013F1, $E3F1
    PULS  A,B,PC
SPAWNS_BULLET/MINE_WITH_6_PAST_JSR: ; 0x0013F3, $E3F3
    PSHS  U,Y,B,A ; Save
    LDA   BULLET/MINE_SPAWNED_COUNT ; Load
    CMPA  #$14 ; If A _ #$14, cap?
    BCC   RTS_TO_PC_JSR'D+6 ; >=, goto.
    LDD   10,X ; Load OBJ[10]
    SUBD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Sub with
    CMPD  #$2580 ; Screen width.
    BCC   RTS_TO_PC_JSR'D+6 ; >= CMP'd, RTS
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    LDB   12,X ; B from OBJ[12]
    CMPB  #$2A ; Off screen top
    BLS   RTS_TO_PC_JSR'D+6 ; <=, goto.
    LDX   LIST_23B_LARGE_POOL ; Get objs in list.
    BEQ   RTS_TO_PC_JSR'D+6 ; RTS if none.
    STD   4,X ; D to OBJ[4]
    STD   10,X ; D to OBJ[10]
    EXG   A-B ; Flip D
    STD   12,X ; To OBJ[12]
    STU   6,X ; U to OBJ[6], root object?
    CLRA ; Clear D
    CLRB
    STD   14,X ; Clear
    STD   16,X ; Clear
    LDU   6,S ; U is JSR'd from addr.
    PULU  A,B,Y ; D=JSR[0],Y=JSR[2]
    STD   18,X ; D to OBJ[18]
    STY   2,X ; Y to OBJ[2] handler?
    PULU  A,B ; D=JSR[4]
    STU   6,S ; Store new U back, RTS's here.
    STD   8,X ; to OBJ[8]
    LDA   #$14 ; Val
    STA   21,X ; To OBJ[21], [22]
    STA   22,X
    LDD   X ; D from X.next
    STD   LIST_23B_LARGE_POOL ; Remove list entry taken.
    LDD   LIST_BULLETS? ; Load list first entry
    STD   X ; Store to X.next
    INC   BULLET/MINE_SPAWNED_COUNT ; Inc bullets?
    STX   LIST_BULLETS? ; Store X to list as head.
    PULS  A,B,Y,U,PC ; RTS, leaving 6 bytes ahead.
RTS_TO_PC_JSR'D+6: ; 0x00144A, $E44A
    LDU   6,S ; U = S[6]
    LEAU  6,U ; U += 6
    STU   6,S ; Replace
    CLRA ; Clear to flag rtn.
    PULS  A,B,Y,U,PC
BULLETS_PROCESS_RTN: ; 0x001453, $E453
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$20 ; Test bit
    BNE   RTS ; If set, RTS.
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load val
    ANDB  #$E0 ; Clear bottom B
    STD   R_A09D_BULLET_HPOS_IDK ; Store to
    LDD   R_A022_SCREEN_POS_HORIZ_2_TRGT? ; Load val
    ANDB  #$E0 ; Clear bottom B
    SUBD  R_A09D_BULLET_HPOS_IDK ; Sub with
    ASLB ; D << 2, 0's in.
    ROLA
    ASLB
    ROLA
    STD   R_A09D_BULLET_HPOS_IDK ; Store to
    LDX   #$A06D ; PTR to list.
    BRA   TO_NEXT_BULLET
PROCESS_BULLET: ; 0x001470, $E470
    LDY   4,X ; OBJ[4], POS_SCREEN
    LDD   16,X ; OBJ[16], SPEED_V
    ADDD  12,X ; OBJ[12], WORLD_V
    CMPA  #$2A ; A _ #$2A
    BLS   OFF_GAME_SCREEN ; <=, goto, off screen top.
    STD   12,X ; Store to OBJ[12], WORLD_V
    LDD   14,X ; OBJ[14], SPEED_H
    ADDD  R_A09D_BULLET_HPOS_IDK ; Add with
    ADDD  10,X ; OBJ[10], WORLD_H
    CMPA  #$98 ; IF A _ #$98
    BCC   OFF_GAME_SCREEN ; >=, goto, off screen.
    STD   10,X ; To OBJ[10], WORLD_H
    LDB   12,X ; OBJ[12], WORLD_V
    STD   4,X ; OBJ[4], POS_SCREEN
    LDU   4,X ; OBJ[4], POS_SCREEN
    JMP   [18,X] ; JMP location. Scanner pixels usually but not on scanner so reused.
TO_NEXT_BULLET: ; 0x001493, $E493
    LDX   X ; To next task.
    BNE   PROCESS_BULLET ; If valid, process.
RTS: ; 0x001497, $E497
    RTS
CALLBACK_HANDLER_BULLET_DIRECTED?: ; 0x001498, $E498
    LDU   RANDOM_PALETTE_ROTATION_DEFENDER_LOGO ; TODO: Why this and what this code is.
    LDB   11,X
    BPL   DELETE_DONT_ADD
    LEAU  6,U ; Switches which bullet shown?
DELETE_DONT_ADD: ; 0x0014A0, $E4A0
    LDD   #$0000 ; Clear
    STD   Y ; Clear Y to Y+2
    STA   2,Y
    STD   256,Y ; X+1, Y+0 to Y+2
    STA   258,Y
    LDY   4,X ; Y from XOBJ[4]
    LDD   U ; D from @U
    STD   Y ; X to Y
    LDD   2,U ; D from U[2]
    STA   2,Y ; A to Y+2
    STB   256,Y ; B to Y+0
    LDD   4,U ; D from U[4]
    STD   257,Y ; To X+1,Y+1 to Y+2
    BRA   TO_NEXT_BULLET ; Next
OFF_GAME_SCREEN: ; 0x0014C6, $E4C6
    CLRA ; Clear D
    CLRB
    STA   22,X ; Clear OBJ[22], disabled?
    STD   Y ; Clear Y
    STA   2,Y ; (0,2)
    STD   256,Y ; (2,0)
    STA   258,Y ; (2,2)
    BRA   TO_NEXT_BULLET ; Next OBJ
HANDLER_BULLET_MINE?: ; 0x0014D9, $E4D9
    LDU   POOL_A1A2_PTR_MINE_RELATED ; Graphic pixel graphics ptr.
    LDB   11,X ; OBJ[11]
    ASLB ; Get bit into carry
    LDD   #$0000 ; Clear bullet
    STD   Y ; X to X+1, Y to Y+2
    STA   2,Y
    STD   256,Y
    STA   258,Y
    LDY   4,X ; Get OBJ[4] to Y
    BCS   ALTERNATIVE_GRAPHIC? ; If CC.c = 1, goto
    LDD   U ; D from U. Could have been moved above before branch. Smaller code.
    ANDA  #$0F ; Delete top bits.
    STD   Y ; To YOBJ..?
    LDD   2,U ; Load from UOBJ[2]
    ANDA  #$0F ; Delete top bits
    STA   2,Y ; Store A to YOBJ[2]? Unsure why
    ANDB  #$F0 ; Get upper bits only.
    STB   257,Y ; Store to Y,X+1,Y+1
    JMP   TO_NEXT_BULLET ; Next OBJ
ALTERNATIVE_GRAPHIC?: ; 0x001507, $E507
    LDD   U ; D from U
    ANDB  #$0F ; Keep bottom bits.
    STB   1,Y ; Store to Y+1
    ANDA  #$F0 ; Get top bits
    STA   258,Y ; Store to Y,X+1,Y+2
    LDD   2,U ; Load U+2
    ANDA  #$F0 ; Keep top bits.
    STD   256,Y ; Store to Y+1
    JMP   TO_NEXT_BULLET ; Next bullet.
CALLBACK_BULLET/MINE_HIT_PLAYER: ; 0x00151E, $E51E
    LDD   #$0025 ; Score +25
    JSR   SCORE_ADD_AB_SETTINGS ; Score +25, hit by bullet?
    DEC   BULLET/MINE_SPAWNED_COUNT ; Dec counter.
    JSR   REMOVE_X_FROM_LIST_BULLETS ; Remove from list.
    JSR   CLEAR_XOBJ_GFX_OFF_SCREEN
    LDD   10,X ; D from OBJ[10]
    LSRA ; D >> 2
    RORB
    LSRA
    RORB
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add with val
    STD   10,X ; D to OBJ[10]
    LDA   12,X ; Load A with OBJ[12]
    SUBA  #$02 ; Sub 2
    STA   12,X ; Store back.
    LDD   #$F951 ; Load different callback.
    STD   2,X ; Store to obj.
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP
    LDD   #$D4E4
    JMP   SOUND_SET_SOUND_PRIORITIED ; Still unsure.
    .db $5E ; Data? ROM check byte?
SETUP_A1A2-A1C1_WITH_99/9A/A9/AA: ; 0x00154B, $E54B
    LDX   #$A1A2 ; Ptr?
    STX   POOL_A1A2_PTR_MINE_RELATED
LOOP_NOT_DONE: ; 0x001550, $E550
    LDB   #$0A ; Initial
    JSR   RANDOM_VALUE_FWD+IN_A
    BMI   NOT_NEGATIVE ; If top bit set, don't modify.
    LDB   #$09 ; Changed
NOT_NEGATIVE: ; 0x001559, $E559
    LSRA ; Shift A
    BCS   SHIFTED_OFF_ONE
    ADDB  #$A0 ; Add to B
    BRA   COMMIT_B
SHIFTED_OFF_ONE: ; 0x001560, $E560
    ADDB  #$90 ; Add this is was 0 shifted off.
COMMIT_B: ; 0x001562, $E562
    STB   X+ ; Store
    CMPX  #$A1C2 ; End?
    BNE   LOOP_NOT_DONE ; Not yet.
    RTS ; Leave
BULLET_TIMER_COUNTDOWN: ; 0x00156A, $E56A
    LDX   #$A06D ; List ptr
    BRA   TO_NEXT_BULLET/MINE
BULLET_PROCESS: ; 0x00156F, $E56F
    LDA   22,X ; Load timer.
    BEQ   REMOVE_BULLET_FROM_SCREEN ; If 0, delete.
    DEC   21,X ; Dec timer otherwise.
    BNE   TO_NEXT_BULLET/MINE ; To next
REMOVE_BULLET_FROM_SCREEN: ; 0x001579, $E579
    LDU   X ; Load next obj
    STU   Y ; To previous, removing OBJ X
    LDU   LIST_23B_LARGE_POOL ; Load list
    STU   X ; List to X.next
    STX   LIST_23B_LARGE_POOL ; X is new head.
    JSR   CLEAR_XOBJ_GFX_OFF_SCREEN
    DEC   BULLET/MINE_SPAWNED_COUNT
    LEAX  Y ; X is now X.prev
TO_NEXT_BULLET/MINE: ; 0x00158A, $E58A
    LEAY  X ; Obj X to Y, Y is X.last in rtn
    LDX   X ; X to X.next
    BNE   BULLET_PROCESS ; If not null, goto.
    RTS ; RTS
CALLBACK_FIRE_BUTTON_PRESSED: ; 0x001591, $E591
    LDA   LASERS_ONSCREEN_COUNT ; Load val
    CMPA  #$04 ; If A _ #$04
    BCC   REMOVE_OBJ+HANDLE ; >=, goto.
    INC   LASERS_ONSCREEN_COUNT ; ++
    LDD   #$D51B
    JSR   SOUND_SET_SOUND_PRIORITIED ; Request sound.
    LDX   R_A0C1_SHIP_UNK ; Load X with
    LDA   SHIP_DIRECTION_300/FD00 ; Load A with
    BPL   LASER_CREATE_TO_RIGHT ; If A positive, goto.
    JMP   LASER_HANDLE_TO_LEFT ; Otherwise.
REMOVE_OBJ+HANDLE: ; 0x0015A8, $E5A8
    JMP   CALLBACK_TASK_REMOVE
HIT_DETECT_LASER_AGAINST_ENEMIES: ; 0x0015AB, $E5AB
    PSHS  U,B,A ; Save
    LDA   #$02 ; Handler in bank 2
    STA   CURRENT_BANK
    STA   BANKSWITCH
    PULS  A,B ; Restore?
    NOP ; Removed something?
    NOP
    NOP
    LDU   #$F96F ; Ptr to IDK
    JSR   HIT_DETECT_VS_LIST_ONSCREEN? ; Do this
    PULS  U,PC ; Restore, leave.
LASER_CREATE_TO_RIGHT: ; 0x0015C1, $E5C1
    LEAX  1796,X ; X+7,Y+4?
    STX   7,U ; To UOBJ[7]
    STX   9,U ; To UOBJ[9]
    STX   11,U ; To OBJ[11]
LASER_CALLBACK_CONTINUE_TO_RIGHT: ; 0x0015CB, $E5CB
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$40 ; Test bit
    BNE   CLEAR_LASER_OBJ[11]_TO_OBJ[7] ; Set, goto.
    LDA   #$04 ; Idk val
    LDX   7,U ; Load OBJ[7]
    LDB   #$11 ; Load laser color.
    CMPX  #$9800 ; Compare to edge of screen.
    BCC   CLEAR_LASER_OBJ[11]_TO_OBJ[7] ; If >=, goto.
LOOP_STORE_LASER_1: ; 0x0015DC, $E5DC
    STB   X ; B to X
    LEAX  256,X ; X+1
    DECA ; Dec counter
    BNE   LOOP_STORE_LASER_1 ; Loop if not 0.
    LDB   #$99 ; Front of laser?
    STB   X ; B to X
    STX   7,U ; X stored back to obj.
    LDY   LASER_HOLES_POINTER_ADDR ; Load Y
    CMPY  #$A15F ; If Y _ ADDR
    BCS   DONT_SEED_Y ; <, goto.
    LDY   #$A142 ; Seed Y, randomness pool.
DONT_SEED_Y: ; 0x0015F8, $E5F8
    LDX   9,U ; X from OBJ[9]
    LDA   #$03 ; Unsure val
LOOP_STORE_LASER_2: ; 0x0015FC, $E5FC
    LDB   Y+ ; B from Y
    STB   X ; To X
    LEAX  256,X ; X+1
    DECA ; Dec A
    BNE   LOOP_STORE_LASER_2
    STY   LASER_HOLES_POINTER_ADDR ; Laser ptr 2?
    STX   9,U ; Store to OBJ[9]
    CLR   [11,U] ; Clear OBJ[11] PTR
    INC   11,U ; Inc high byte
    LDD   7,U ; D from OBJ[7]
    SUBA  #$06 ; Sub A
    BSR   HIT_DETECT_LASER_AGAINST_ENEMIES ; Need to solve
    BNE   CLEAR_LASER_OBJ[11]_TO_OBJ[7] ; Skip callback.
    LDA   #$01 ; Callback stuff.
    LDX   #$E5CB
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CLEAR_LASER_OBJ[11]_TO_OBJ[7]: ; 0x001621, $E621
    LDX   11,U ; Load OBJ[11]
    CLRA ; Clear A
LOOP_CLEAR_LASER: ; 0x001624, $E624
    STA   X ; Store to X+
    LEAX  256,X ; X+1
    CMPX  7,U ; Catch up to OBJ[7]
    BLS   LOOP_CLEAR_LASER ; If <=, goto.
    BRA   ONE_LESS_LASER
LASER_HANDLE_TO_LEFT: ; 0x001630, $E630
    LEAX  4,X ; X += 4? Idk why, addrmode ranging?
    STX   7,U ; Init obj stuff
    STX   9,U
    STX   11,U
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$40 ; Test bit
    BNE   CLEAR_LEASER_LEFT ; If set, player is dead.
    LDA   #$04 ; Loop count
    LDX   7,U ; PTR to current pos.
    LDB   #$11 ; Laser color.
    CMPX  #$0500 ; Edge of screen.
    BLS   CLEAR_LEASER_LEFT ; If X.pos <= 5, remove laser.
LOOP_PUT_LASER_LEFT: ; 0x001649, $E649
    STB   X ; Pixels to pos
    LEAX  -256,X ; -1
    DECA ; Loop--
    BNE   LOOP_PUT_LASER_LEFT ; != 0, loop
    LDB   #$99 ; White?
    STB   X ; Store to new pos.
    STX   7,U ; Store pos to obj
    LDY   LASER_HOLES_POINTER_ADDR ; Laser dots pool ptr
    CMPY  #$A15F ; End of pool
    BCS   DONT_RESET_LASER_HOLES_PTR ; <, not end
    LDY   #$A142 ; Beginning of pool
DONT_RESET_LASER_HOLES_PTR: ; 0x001665, $E665
    LDX   9,U ; Holes pos, in obj.
    LDA   #$03 ; Loops
LOOP_PUT_HOLES_LEFT: ; 0x001669, $E669
    LDB   Y+ ; Load from
    STB   X ; To screen
    LEAX  -256,X ; X-1
    DECA ; Loop--
    BNE   LOOP_PUT_HOLES_LEFT
    STY   LASER_HOLES_POINTER_ADDR ; Store pos in pool back
    STX   9,U ; Store holes next pos to OBJ
    CLR   [11,U] ; Clear end of line.
    DEC   11,U ; X--
    LDD   7,U ; D from laser current
    JSR   HIT_DETECT_LASER_AGAINST_ENEMIES
    BNE   CLEAR_LEASER_LEFT ; If true, hit enemy.
    LDA   #$01 ; Otherwise, continue laser with callback.
    LDX   #$E638
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CLEAR_LEASER_LEFT: ; 0x00168D, $E68D
    LDX   11,U ; Load OBJ[11]
    CLRA ; Clear
LOOP_CLEAR_LASER_LEFT: ; 0x001690, $E690
    STA   X ; Store to screen
    LEAX  -256,X ; X-1
    CMPX  7,U ; Compare to end
    BCC   LOOP_CLEAR_LASER_LEFT
ONE_LESS_LASER: ; 0x00169A, $E69A
    DEC   LASERS_ONSCREEN_COUNT ; 1 less laser on screen.
    JMP   CALLBACK_TASK_REMOVE
LASER_HOLES_POOL_CREATE: ; 0x00169F, $E69F
    LDX   #$A142 ; PTR?
    STX   LASER_HOLES_POINTER_ADDR ; Put to.
LOOP_MORES_HOLES: ; 0x0016A4, $E6A4
    JSR   RANDOM_VALUE_FWD+IN_A ; Depends on randomness?
    CLRB ; Clear B
    LSRA ; Random to carry.
    BCC   SKIP_ADD_1 ; If CC.c=0, don't add.
    ADDB  #$01
SKIP_ADD_1: ; 0x0016AD, $E6AD
    LSRA ; Get random again
    BCC   SKIP_ADD_10 ; If CC.c=0, don't add.
    ADDB  #$10
SKIP_ADD_10: ; 0x0016B2, $E6B2
    STB   X+ ; Store B to X.
    CMPX  #$A162 ; Compare to end.
    BNE   LOOP_MORES_HOLES
    RTS
HIT_DETECT_VS_LIST_ONSCREEN?: ; 0x0016BA, $E6BA
    LDX   #$A065 ; List to check hits against.
HIT_DETECT_VS_LIST_PASSED_IN_X: ; 0x0016BD, $E6BD
    STD   HIT_DETECT_UPPER_LEFT_XXYY ; D from addr
    ADDD  U ; D += WWHH of sprite.
    STD   HIT_DETECT_BOTTOM_RIGHT_XXYY ; Store to
    BRA   NO_HIT_DETECTED_X->X.NEXT ; Load list obj.
PROCESS_HIT_VS_OBJ: ; 0x0016C5, $E6C5
    LDD   4,X ; OBJ[4]
    BEQ   NO_HIT_DETECTED_X->X.NEXT ; POS_SCREEN invalid, no hit possible since not on screen.
    CMPA  HIT_DETECT_BOTTOM_RIGHT_XXYY ; If A _ addr
    BCC   NO_HIT_DETECTED_X->X.NEXT ; >=, next.
    CMPB  HIT_DETECT_BOTTOM_RIGHT_XXYY+1 ; If B _ addr
    BCC   NO_HIT_DETECTED_X->X.NEXT ; >=, next.
    ADDD  [2,X] ; Add to D OBJ GFX ptr XXYY
    CMPA  HIT_DETECT_UPPER_LEFT_XXYY ; If A _ addr
    BLS   NO_HIT_DETECTED_X->X.NEXT ; <=, next.
    CMPB  HIT_DETECT_UPPER_LEFT_XXYY+1 ; If B _ addr
    BHI   OBJ_HIT ; >, run code finally.
NO_HIT_DETECTED_X->X.NEXT: ; 0x0016DC, $E6DC
    LDX   X ; X to X.next
    BNE   PROCESS_HIT_VS_OBJ ; If valid, process.
    RTS ; Leave, no hit detected.
OBJ_HIT: ; 0x0016E1, $E6E1
    STU   R_A0DC_OBJ_DETECTING_HITS_AGAINST_THIS_GFX ; Detecting hits against this
    LDY   2,X ; Load XOBJ's graphic.
    SUBD  Y ; D - GFX_ATTR.XXYY
    STD   A073_SCRATCHPAD_ADDR ; Store to scratch
    CLRA ; Clear D
    CLRB
    STD   R_A0D0_HIT_DETECTED_UNK_1 ; Clear
    STD   R_A0D2_HIT_DETECTED_UNK_2 ; Clear
    LDD   A073_SCRATCHPAD_ADDR ; Load scratchpad
    SUBB  HIT_DETECT_UPPER_LEFT_XXYY+1 ; Subtract with val
    BHI   SUBTRACKED_HIGHER_B ; If subtracted was higher, goto.
    NEGB ; Invert B
    STB   R_A0D0_HIT_DETECTED_UNK_1+1 ; Store just B to addr?
    BRA   A_STUFF_NOW
SUBTRACKED_HIGHER_B: ; 0x0016FB, $E6FB
    STB   R_A0D2_HIT_DETECTED_UNK_2+1 ; Store B as-is
A_STUFF_NOW: ; 0x0016FD, $E6FD
    SUBA  HIT_DETECT_UPPER_LEFT_XXYY ; A - addr
    BHI   SUBTRACTED_HIGHER_A ; If subtracted was higher, goto.
    NEGA ; Invert
    STA   R_A0D0_HIT_DETECTED_UNK_1 ; Store to
    BRA   SKIP_OTHER_STORE
SUBTRACTED_HIGHER_A: ; 0x001706, $E706
    STA   R_A0D2_HIT_DETECTED_UNK_2 ; Otherwise store to
SKIP_OTHER_STORE: ; 0x001708, $E708
    LDD   A073_SCRATCHPAD_ADDR ; D from scratch again
    ADDD  Y ; Add GFX_ATTR.XXYY
    SUBB  HIT_DETECT_BOTTOM_RIGHT_XXYY+1 ; Sub with
    BHI   SUB_B_W/_HIGHER_2 ; If subtracted higher, goto.
    CLRB ; Clear B
SUB_B_W/_HIGHER_2: ; 0x001711, $E711
    SUBA  HIT_DETECT_BOTTOM_RIGHT_XXYY ; Sub with
    BHI   SUB_A_W/_HIGHER_2 ; Subbed with higher, goto.
    CLRA ; Clear A
SUB_A_W/_HIGHER_2: ; 0x001716, $E716
    STD   R_A0DA_HIT_DTCT_UNK ; Store to
    LDD   Y ; D from Y
    SUBD  R_A0D0_HIT_DETECTED_UNK_1 ; Sub with
    SUBD  R_A0DA_HIT_DTCT_UNK ; Sub with
    STD   IDFK_HIT_DETECTED_WRD ; Store to
    LDA   1,U ; A from GFX[1], HH
    STA   OBJ_HIT_BMP_UNK+1
    LDB   R_A0D2_HIT_DETECTED_UNK_2 ; B from addr
    MUL ; Multiply HEIGHT * VAL
    LDU   2,U ; U from UBMP[2], ptr to BMP.
    LEAU  D,U ; GFX PTR += D
    LDA   1,Y ; A from XBMP[1], HH
    STA   OBJ_HIT_BMP_UNK ; To var
    LDY   2,Y ; Y from BMP[2], PTR to GFX
    LDB   R_A0D0_HIT_DETECTED_UNK_1 ; B from
    MUL ; Multiply AB to D
    LEAY  D,Y ; GFX PTR += D
    LDA   R_A0D0_HIT_DETECTED_UNK_1+1 ; A from
    LEAY  A,Y ; Y GFX PTR += A
    LDA   R_A0D2_HIT_DETECTED_UNK_2+1 ; A from
    LEAU  A,U ; U GFX PTR += A
LOOP_HIT_DETERMINE_IDK: ; 0x00173F, $E73F
    LDB   IDFK_HIT_DETECTED_WRD+1 ; B from
    DECB ; --
L_001742_HIT_DETERMINE_IDK: ; 0x001742, $E742
    LDA   B,U ; A from UPTR+A
    BEQ   SKIP_RETURN_TRUE ; If 0, goto.
    LDA   B,Y ; A from Y+B
    BEQ   SKIP_RETURN_TRUE ; If 0, goto.
    LEAY  B,Y ; Y += B
    TFR   Y>D ; Y to D
    LDU   2,X ; U from XOBJ[2]
    SUBD  2,U ; D-=UOBJ[2]
    LDY   4,X ; Y from XOBJ[4]
LOOP_UNK_SUB_RTN: ; 0x001755, $E755
    SUBB  1,U ; B-=U+1
    SBCA  #$00 ; Adjust A. CC.c set if borrowed...
    BCS   EXIT_HIT_DETECT_TRUE ; If CC.c=1, goto.
    LEAY  256,Y ; Y+=1
    BRA   LOOP_UNK_SUB_RTN
EXIT_HIT_DETECT_TRUE: ; 0x001761, $E761
    ADDB  1,U ; B+=U+1
    ADCA  #$00 ; Adjust upper byte.
    LEAY  B,Y ; Y += B
    STY   R_A0F8_PARTICLE_CENTRAL_POINT ; To var
    JSR   [8,X] ; Clear OBJ off screen.
    LDA   #$01 ; True hit something.
    RTS ; True
SKIP_RETURN_TRUE: ; 0x001770, $E770
    DECB ; B--
    BPL   L_001742_HIT_DETERMINE_IDK ; If positive, loop.
    LDD   OBJ_HIT_BMP_UNK ; D from
    LEAY  A,Y ; Y += A
    LEAU  B,U ; U += B
    DEC   IDFK_HIT_DETECTED_WRD ; addr--
    BNE   LOOP_HIT_DETERMINE_IDK ; If not 0, goto.
    LDU   R_A0DC_OBJ_DETECTING_HITS_AGAINST_THIS_GFX ; U from addr.
    JMP   NO_HIT_DETECTED_X->X.NEXT ; Process next.
RESET_ROTATING_TEXT_COLOR: ; 0x001782, $E782
    CLR   ROTATING_COLOR_INDEX ; Clear
ROTATING_TEXT_COLOR_CALLBACK: ; 0x001784, $E784
    LDX   #$E799 ; X from
    LDA   ROTATING_COLOR_INDEX ; A from
    LDB   A,X ; B from A+X
    BEQ   RESET_ROTATING_TEXT_COLOR ; If 0, goto.
    INC   ROTATING_COLOR_INDEX ; Inc var
    STB   COLOR_PALETTE_RAM_COPY+1 ; B to Palette+1
    LDA   #$02 ; Callback setup.
    LDX   #$E784
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
TEXT_COLOR_ROTATION_TABLE: ; 0x001799, $E799
    .db $38
    .db $39
    .db $3A
    .db $3B
    .db $3C
    .db $3D
    .db $3E
    .db $3F
    .db $37
    .db $2F
    .db $27
    .db $1F
    .db $17
    .db $47
    .db $47
    .db $87
    .db $87
    .db $C7
    .db $C7
    .db $C6
    .db $C5
    .db $CC
    .db $CB
    .db $CA
    .db $DA
    .db $E8
    .db $F8
    .db $F9
    .db $FA
    .db $FB
    .db $FD
    .db $FF
    .db $BF
    .db $3F
    .db $3E
    .db $3C
    .db $00 ; EOF
CORE_OS_TASK_LOOP: ; 0x0017BE, $E7BE
    LDX   #$A05F ; PTR
    STX   R_A063_CALLBACK_LIST/CURRENT ; Store...
WAIT_FOR_IRQ_RAN: ; 0x0017C3, $E7C3
    LDA   TICKS_HAPPENED_COUNTER? ; Get A from
    BEQ   WAIT_FOR_IRQ_RAN ; If 0, wait.
    CLR   TICKS_HAPPENED_COUNTER? ; Clear.
    LDB   A0BA_PLAYER_GAME_STATE ; Get B
    BITB  #$7D ; Test 0111.1101 bits.
    BEQ   NONE_SET
    CLR   R_A05E_SLOWDOWN_FLAG? ; Clear?
    BRA   SKIP_SLOWDOWN_CODE
NONE_SET: ; 0x0017D3, $E7D3
    ASLA ; Ticks happened * 2
    ADDA  R_A05E_SLOWDOWN_FLAG? ; += this val
    SUBA  #$04 ; -= 4
    BPL   IS_STILL_POSITIVE
    CLRA ; Clear if negative.
IS_STILL_POSITIVE: ; 0x0017DB, $E7DB
    STA   R_A05E_SLOWDOWN_FLAG? ; Store 0 or val.
    CMPA  #$02 ; If _ 2
    BCS   SKIP_SLOWDOWN_CODE ; <, goto.
    LDB   #$03 ; Move
    STB   STARS_NUM_TO_CHANGE? ; Change to 3 stars updating.
    CMPA  #$02
    BLS   SKIP_SLOWDOWN_CODE ; <=, goto. Don't remove stuff from screen.
    LDA   #$02 ; Slowdown value.
    STA   R_A05E_SLOWDOWN_FLAG?
LIST_A065_RTN_IDK: ; 0x0017ED, $E7ED
    LDY   #$A065 ; List, on screen.  Y=LIST/CURR, X=LIST.NEXT
LOOP_FIND_MOVABLE_ONSCREEN: ; 0x0017F1, $E7F1
    LDX   Y ; X = Y.next
    BEQ   SKIP_SLOWDOWN_CODE ; No more objects left.
    LDA   20,X ; OBJ[20], block move offscreen.
    BEQ   OBJECT_IS_MOVABLE ; If 0, goto.
    LEAY  X ; Y is now X.next, skipping object.
    BRA   LOOP_FIND_MOVABLE_ONSCREEN
OBJECT_IS_MOVABLE: ; 0x0017FE, $E7FE
    LDU   X ; U = OBJ.next
    STU   Y ; U to PREV.next. X removed from list.
    LDD   A0DF_RAND_BYTE ; Get value from.
    ANDA  #$3F ; And...
    ADDA  #$60 ; Add
    ADDD  10,X ; Add to world pos.
    STD   10,X ; Store to obj.
    JSR   CLEAR_XOBJ_GFX_OFF_SCREEN ; Clear off screen.
    LDD   #$0000
    STD   4,X ; Clear, not on screen.
    LDU   LIST_OFFSCREEN ; Move X object to A06B list, extending list. U = List head
    STX   LIST_OFFSCREEN ; Store new head, our X obj.
    STU   X ; Set old head obj to HEAD.next, extending list with new obj.
SKIP_SLOWDOWN_CODE: ; 0x00181A, $E81A
    LDA   #$02
    STA   CURRENT_BANK
    STA   BANKSWITCH ; Switch to bank 2, for gfx?
    BSR   L_001861 ; Sub
    JSR   JMP_TO_PARTICLE_FORWARD ; Sub
    JSR   RANDOM_VALUE_FWD+IN_A ; Forward random.
SCHEDULE_BUTTONS_IF_STATE_RTN: ; 0x001829, $E829
    LDX   R_A082_BUTTON_PRESSED_PTR_A1 ; Get val
    BNE   HANDLE_A1 ; If set, make task.
    LDX   R_A086_BUTTON_PRESSED_PTR_B1 ; X from
    BEQ   NO_MORE_BUTTON_TASKS ; If 0, goto.
    LDD   R_A088_BUTTON_PRESSED_PTR_B2 ; D from
    CLR   R_A086_BUTTON_PRESSED_PTR_B1 ; Clear
    CLR   R_A086_BUTTON_PRESSED_PTR_B1+1 ; Clear
    BRA   HANDLE_B1/B2 ; Goto
HANDLE_A1: ; 0x001839, $E839
    LDD   R_A084_BUTTON_PRESSED_PTR_A2 ; D from A2
    CLR   R_A082_BUTTON_PRESSED_PTR_A1 ; Clear
    CLR   R_A082_BUTTON_PRESSED_PTR_A1+1 ; Clear
HANDLE_B1/B2: ; 0x00183F, $E83F
    ANDB  A0BA_PLAYER_GAME_STATE ; B is state test.
    BNE   SCHEDULE_BUTTONS_IF_STATE_RTN ; If any states set, don't schedule.
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; A is timer, X is rtn.
    BRA   SCHEDULE_BUTTONS_IF_STATE_RTN
NO_MORE_BUTTON_TASKS: ; 0x001848, $E848
    LDU   #$A05F ; Obj handle list.
    BRA   U=U.NEXT,HANDLE_CALLBACK ; Handle
CALLBACK_PTR_VALID,HANDLE: ; 0x00184D, $E84D
    DEC   4,U ; OBJ[4]--
    BNE   U=U.NEXT,HANDLE_CALLBACK ; If not 0, don't call handler.
    STU   R_A063_CALLBACK_LIST/CURRENT ; Callback focused on to addr.
    JMP   [2,U] ; Run handler callback.
U=U.NEXT,HANDLE_CALLBACK: ; 0x001856, $E856
    LDU   U ; U = U.next
    BNE   CALLBACK_PTR_VALID,HANDLE ; If valid ptr, goto.
    LDS   #$BFFF ; Set stack if we ever run out of tasks?
    JMP   CORE_OS_TASK_LOOP ; Goto
L_001861: ; 0x001861, $E861
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$10 ; Test bit
    BNE   SHIP_NOT_HIT ; If set, don't check.
    LDD   SHIP_SCR_POS_XXYY ; Load ship pos.
    LDU   #$F9C1 ; Load U with
    TST   R_A0BD_UNK_DIR_UNK ; Test byte.
    BPL   DONT_LOAD_OTHER_SHIP_DIRECTION ; If positive, goto.
    LDU   #$F9CB ; If negative, load instead.
DONT_LOAD_OTHER_SHIP_DIRECTION: ; 0x001873, $E873
    PSHS  U,B,A ; U and D
    INC   R_A0DE_HUMANOID_KILL_FLAG ; Inc idk
    JSR   HIT_DETECT_VS_LIST_ONSCREEN? ; Hit detect vs ship?
    PULS  A,B,U ; Restore GFX ptr, SCR_POS of ship.
    BNE   SHIP_HIT ; If hit returned true, goto.
    LDX   #$A06D ; Load ptr to other list, bullets?
    JSR   HIT_DETECT_VS_LIST_PASSED_IN_X ; Do
    BEQ   SHIP_NOT_HIT ; If 0 ret, RTS
SHIP_HIT: ; 0x001886, $E886
    LDX   #$DA46 ; Set up callback to death.
    LDA   #$00 ; Type
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Callback.
    LDA   A0BA_PLAYER_GAME_STATE ; Game state
    ORA   #$08 ; Set bit. Player dead.
    STA   A0BA_PLAYER_GAME_STATE ; Store to.
SHIP_NOT_HIT: ; 0x001894, $E894
    CLR   R_A0DE_HUMANOID_KILL_FLAG ; Clear addr
    RTS ; RTS
REVERSE_BUTTON_PRESSED_CALLBACK: ; 0x001897, $E897
    LDA   REVERSE_BLOCK_FLAG ; Load val
    BNE   REMOVE_CALLBACK_UNHANDLED ; If set, goto.
    INC   REVERSE_BLOCK_FLAG ; ++?
    LDD   R_A0BD_UNK_DIR_UNK ; D from
    COMB ; Invert
    COMA
    ADDD  #$0001 ; Add 1
    STD   SHIP_DIRECTION_300/FD00 ; Store to
SETUP_CALLBACK_WAIT_UNPRESS_REVERSE: ; 0x0018A6, $E8A6
    LDA   #$02 ; Callback
    LDX   #$E8AE
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
    LDA   WGT_DATA_A_RAM_COPY ; Load widget
    BITA  #$40 ; Test reverse.
    BNE   SETUP_CALLBACK_WAIT_UNPRESS_REVERSE ; If set, setup callback.
    LDA   #$05 ; Callback setup to enable reverse in 5 ticks.
    LDX   #$E8BC
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    CLR   REVERSE_BLOCK_FLAG ; Clear val, can be done again.
REMOVE_CALLBACK_UNHANDLED: ; 0x0018BE, $E8BE
    JMP   CALLBACK_TASK_REMOVE ; Remove callback.
CALLBACK_SMARTBOMB_PRESSED: ; 0x0018C1, $E8C1
    LDA   R_A09A_SMARTBOMB_DISABLED ; Load val
    BNE   SMARTBOMB_BUTTON_HANDLED ; If not 0, handle.
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player ptr.
    LDA   9,X ; Load OBJ[9]
    BEQ   SMARTBOMB_BUTTON_HANDLED ; Request denied.
    INC   R_A09A_SMARTBOMB_DISABLED ; Inc this.
    DEC   9,X ; OBJ[9]--, smartbombs.
    JSR   SMARTBOMBS_TO_SCREEN ; Put new count to screen.
    LDD   #$D4D2 ; D val
    JSR   SOUND_SET_SOUND_PRIORITIED ; Req snd.
LOOP_ON_SCREEN_LIST: ; 0x0018D8, $E8D8
    LDX   LIST_IN_WORLD ; Load list
LOOP_DESTROY_OBJECTS: ; 0x0018DA, $E8DA
    BEQ   POST_SMARTBOMB_HANDLERS ; If NULL, goto.
    LDD   4,X ; D from OBJ[4], POS_SCREEN?
    BEQ   TO_NEXT_X_OBJ ; If 0, goto. If 0, not on screen.
    LDA   20,X ; A from OBJ[20], BLOCK_MOVE_OFFSCREEN
    CMPA  #$02 ; Compare to.
    BCC   TO_NEXT_X_OBJ ; If >=, goto.
    JSR   [8,X] ; OBJ destroy handler
    BRA   LOOP_ON_SCREEN_LIST
TO_NEXT_X_OBJ: ; 0x0018EC, $E8EC
    LDX   X ; X_TO_X.NEXT
    BRA   LOOP_DESTROY_OBJECTS
POST_SMARTBOMB_HANDLERS: ; 0x0018F0, $E8F0
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load list
    LDA   #$04 ; Load A with timer
    STA   7,U ; Store to OBJ[7]
SETUP_CALLBACK_E900: ; 0x0018F6, $E8F6
    COM   COLOR_PALETTE_RAM_COPY ; Invert color.
    LDA   #$02 ; Setup callback for 2 ticks.
    LDX   #$E900 ; Where.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_SMARTBOMB_COUNTER: ; 0x001900, $E900
    DEC   7,U ; Dec value
    BNE   SETUP_CALLBACK_E900 ; Not done, callback again. WW-BB-WW-BB frames.
SMARTBOMB_UNPRESS_WAIT: ; 0x001904, $E904
    LDA   #$0A ; Timer
    LDX   #$E90C ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_SMARTBOMB_TIMEOUT?: ; 0x00190C, $E90C
    LDA   WGT_DATA_A_RAM_COPY ; Load PIA
    BITA  #$04 ; Test smartbomb.
    BNE   SMARTBOMB_UNPRESS_WAIT ; If set, wait.
    LDA   #$0A ; Callback setup
    LDX   #$E91A
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    CLR   R_A09A_SMARTBOMB_DISABLED ; Clear smartbomb disable.
SMARTBOMB_BUTTON_HANDLED: ; 0x00191C, $E91C
    JMP   CALLBACK_TASK_REMOVE ; Do.
HYPERSPACE_BUTTON_PRESSED_CALLBACK: ; 0x00191F, $E91F
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$FD ; Test 1111.1101
    LBNE  JMP_TO_CALLBACK_REMOVE ; If any set, goto.
    LDA   #$77 ; Load 0111.0111
    STA   A0BA_PLAYER_GAME_STATE ; Store to state
    JSR   CLEAR_GAME_SCREEN ; Clear screen.
    LDA   #$0F ; Callback.
    LDX   #$E936
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
LOOP_REMOVE_ALL_BULLETS: ; 0x001936, $E936
    LDX   LIST_BULLETS? ; Load list.
    BEQ   ALL_BULLETS_REMOVED ; NULL, goto.
    JSR   REMOVE_X_FROM_LIST_BULLETS ; Remove from list.
    BRA   LOOP_REMOVE_ALL_BULLETS ; Do to all.
ALL_BULLETS_REMOVED: ; 0x00193F, $E93F
    CLR   BULLET/MINE_SPAWNED_COUNT ; Clear count
    LDD   A0DF_RAND_BYTE ; Random world pos.
    STD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; New location on screen.
    STD   R_A022_SCREEN_POS_HORIZ_2_TRGT?
    LSRB ; Shift B
    BCC   VAL_SHIFTED_0 ; If 0 shifted off, goto.
    LDD   #$2000 ; Idk val
    LDX   #$0300 ; Idk val
    BRA   VAL_SHIFTED_1
VAL_SHIFTED_0: ; 0x001952, $E952
    LDX   #$FD00 ; Idk val
    LDD   #$7000 ; Idk val
VAL_SHIFTED_1: ; 0x001958, $E958
    STD   R_A0C3_SHIP_SCR_HPOS? ; Val to
    STX   SHIP_DIRECTION_300/FD00 ; Val to
    LDB   A0E0_RAND_WORD ; Get random
    LSRB ; Shift to range 0x00 to 0x7F
    ADDB  #$2A ; Add 2A for scanner.
    STB   SHIP_VPOS ; Store to VPOS of ship.
    STD   R_A0C1_SHIP_UNK ; Store unk, not sure what A is. TODO
    CLRA ; Clear
    CLRB
    STA   R_A0C9_UNUSED?ONLY_CLEARED ; Clear
    STD   SCREEN_H_DELTA ; Clear, no delta.
    STD   PLAYER_V_MOMENTUM ; Clear, no momentum.
    JSR   GOTO_B7-C000,DRAW_LAND ; Draw land updated.
    LDB   #$50 ; Game state
    JSR   GAME_STATE_FROM_B_SET_HUMANOIDS_STATE ; Set game state with humanoids in mind.
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Spawn the ship in.
    .db $F9 ; BMP
    .db $C1
    .db $ED ; PLAYER HIT?
    .db $BC
    .db $00 ; Scanner pixels
    .db $00
    LDD   #$0000 ; Load
    STD   14,X ; Clear HSPEED
    STD   16,X ; VSPEED
    LDD   SHIP_VPOS ; Load VPOS
    STD   12,X ; VPOS_OBJ
    LDD   R_A0C3_SHIP_SCR_HPOS? ; Load
    LSRA ; D >> 2
    RORB
    LSRA
    RORB
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add
    STD   10,X ; To OBJ[10], HWORLD
    LDA   SHIP_DIRECTION_300/FD00 ; Val direction
    BPL   DONT_SET_OTHER_BMP ; To right, true.
    LDU   #$F9CB ; BMP swap, ship going to left.
    STU   2,X ; To OBJ[2]
DONT_SET_OTHER_BMP: ; 0x00199D, $E99D
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Load callback.
    STX   7,U ; Store X to OBJ[7]
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP
    LDA   #$28 ; Setup callback once particled in.
    LDX   #$E9AC
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    LDX   7,U ; X from OBJ[7]
    JSR   REMOVE_X_FROM_LIST+OFFSCREEN ; JSR to
    JSR   GAME_STATE_CLEARED_HUMANOID_STATE_SET ; Game state modified.
    LDA   A0E0_RAND_WORD+1 ; Random data.
    CMPA  #$C0 ; If _ val
    LBHI  HYPERSPACE_DIED_ON_REENTRY ; >, goto. Death on reentry. 0xC1 - 0xFF = Death.
JMP_TO_CALLBACK_REMOVE: ; 0x0019BC, $E9BC
    JMP   CALLBACK_TASK_REMOVE ; Handled.
CALLBACK_ADVANCE_POOL_POINTERS: ; 0x0019BF, $E9BF
    LDX   PTR_TO_A162_POOL ; Ptr
    LEAX  1,X ; ++
    CMPX  #$A182 ; See if at end
    BLS   DONT_RESET_PTR_TO_A162 ; <=, goto.
    LDX   #$A162
DONT_RESET_PTR_TO_A162: ; 0x0019CB, $E9CB
    STX   PTR_TO_A162_POOL ; Store to
    LDX   POOL_A1A2_PTR_MINE_RELATED ; Ptr
    LEAX  1,X ; ++
    CMPX  #$A1BA ; Compare to
    BLS   DONT_RESET_PTR ; <=, goto.
    LDX   #$A1A2 ; Reset
DONT_RESET_PTR: ; 0x0019D9, $E9D9
    STX   POOL_A1A2_PTR_MINE_RELATED ; Store back
    LDA   #$04 ; Setup callback
    LDX   #$E9BF
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_ONSCREEN_HANDLE_IDK: ; 0x0019E3, $E9E3
    JSR   INIT_PROCESS_OBJ_INTO_ONSCREEN_LIST ; Put on screen in list.
    LDA   #$02
    LDX   #$E9EE
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Callback
CALLBACK_PROCESS_IDK: ; 0x0019EE, $E9EE
    JSR   PROCESS_OBJ_TO_OFFSCREEN ; Do
    JSR   BULLET_TIMER_COUNTDOWN ; Do
    LDA   #$02 ; Setup callback.
    LDX   #$E9FC
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_UPDATE_SCANNER: ; 0x0019FC, $E9FC
    JSR   BANKSWITCH_TO_1 ; To bank 1
    JSR   JMP_TO_RTN_UPDATE_SCANNER ; Call rtn
    LDA   #$04 ; Callback setup.
    LDX   #$E9E3
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
PROCESS_OBJ_TO_OFFSCREEN: ; 0x001A0A, $EA0A
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; D from
    SUBD  #$0C80 ; D -= val
    STD   A073_SCRATCHPAD_ADDR ; To scratch.
    LDX   #$A065 ; List PTR, on screen.
    BRA   PROCESS_NEXT
PROCESS_TO_OFFSCREEN_LOOP: ; 0x001A16, $EA16
    LDD   10,X ; D from XOBJ[10], HPOS?
    SUBD  A073_SCRATCHPAD_ADDR ; -= with scratch.
    CMPD  #$3E80 ; CMP to val.
    BCS   PROCESS_NEXT ; If D < CMP, is onscreen. So 0 to 3E80 is onscreen.
    LDU   X ; U = X.next
    STU   Y ; To PREV.next, removing item from list.
    LDU   LIST_OFFSCREEN ; Load list offscreen.
    STU   X ; X.next is list loaded.
    STX   LIST_OFFSCREEN ; Remove node to this list head.
    LEAX  Y ; X from prev obj.
PROCESS_NEXT: ; 0x001A2C, $EA2C
    LEAY  X ; Y is prev obj.
    LDX   X ; X to X.next
    BNE   PROCESS_TO_OFFSCREEN_LOOP
    RTS
INIT_PROCESS_OBJ_INTO_ONSCREEN_LIST: ; 0x001A33, $EA33
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load val
    SUBD  #$0C80 ; Subtract
    STD   A073_SCRATCHPAD_ADDR ; Store to scratchpad
    LDX   #$A06B ; List ptr, offscreen.
    BRA   PROCESS_OBJ_X
PROCESS_OBJ_INTO_ONSCREEN_LIST+MOVE: ; 0x001A3F, $EA3F
    LDD   16,X ; D from OBJ[16], VSPEED?
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ADDD  12,X ; Add with OBJ[12], VPOS?
    CMPA  #$2A ; If A _ #$2A
    BCC   DONT_WRAP_TO_F0 ; >=, goto.
    LDA   #$F0 ; If < val, load this.
DONT_WRAP_TO_F0: ; 0x001A50, $EA50
    CMPA  #$F0 ; If A _ #$F0
    BLS   DONT_WRAP_TO_2A
    LDA   #$2A ; Wrap to top of screen.
DONT_WRAP_TO_2A: ; 0x001A56, $EA56
    STD   12,X ; Store to OBJ[12], VPOS?
    LDD   14,X ; Load OBJ[14], h movement?
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ADDD  10,X ; Add to OBJ[10]
    STD   10,X ; Store to OBJ[10], HPOS?
    SUBD  A073_SCRATCHPAD_ADDR ; Subtrack calc'd.
    CMPD  #$3E80 ; Compare to val
    BCC   PROCESS_OBJ_X ; >=, skip adding to onscreen list.
    LDU   X ; Load X.next
    STU   Y ; Store to Y.next, removing from whatever list it is in.
    LDU   LIST_IN_WORLD ; Load list
    STU   X ; Store LIST.next to X.next
    STX   LIST_IN_WORLD ; Make X new head.
    LEAX  Y ; X from previous.
PROCESS_OBJ_X: ; 0x001A78, $EA78
    LEAY  X ; Previous in Y
    LDX   X ; X to X.next
    BNE   PROCESS_OBJ_INTO_ONSCREEN_LIST+MOVE ; Process if not NULL
    RTS ; Leave
    NEGA ; MISTAKE extra? ROM check value?
MAKE_BAITER_RTN?: ; 0x001A80, $EA80
    LDX   #$EAB4 ; Callback
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Not exactly sure good name for rtn.
    LEAU  X ; Callback X to U
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Fill out obj info.
    .db $F9 ; BMP PTR
    .db $A3
    .db $EB ; Destroy handler.
    .db $2B
    .db $33 ; Scanner pixels
    .db $33
    STX   7,U ; X to UOBJ[7]
    STU   6,X ; U to XOBJ[6]
    LDD   A0DF_RAND_BYTE ; Get random
    ANDA  #$1F ; Bottom bits.
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Add with
    STD   10,X ; Store to WORLD_H
    LSRB ; B >> 1, 0 to 7F
    ADDB  #$2A ; Add with
    STB   12,X ; VPOS
    CLRA ; Clear D
    CLRB
    STD   16,X ; VSPEED
    STD   14,X ; HSPEED
    LDA   #$08 ; Load
    STA   9,U ; To UOBJ[9]
    BSR   UPDATE_BAITER_MOVEMENT_ALWAYS ; Set init move values.
    JMP   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP ; Goto
CALLBACK_BAITER_HANDLER: ; 0x001AB4, $EAB4
    LDX   7,U ; X from U
    LDD   2,X ; D from XOBJ[2]
    CMPD  #$F8EC ; If A _ #$F8EC
    BEQ   SETUP_CALLBACK_AGAIN ; ==, goto.
    DEC   9,U ; Dec UOBJ[9]
    BNE   BULLET_NOT_SPAWNED ; Counter has to finish to shoot, don't spawn if not done.
    LDA   R_A110_BAITER_SHOOT_COUNTDOWN_MAX? ; Load val
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get lower.
    STA   9,U ; Store to UOBJ[9]
    JSR   SPAWN_BULLET_REQ ; Do IDK
    BEQ   BULLET_NOT_SPAWNED ; If Z ret, goto.
    LDD   #$D52F ; Bullet sound?
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play it only if we got a spawn success.
BULLET_NOT_SPAWNED: ; 0x001AD5, $EAD5
    LDU   2,X ; U from XOBJ[2]
    LEAU  10,U ; Next GFX
    CMPU  #$F9B7 ; If U _ #$F9B7, end GFX, 3 frames.
    BLS   USE_NEW_GFX ; <=, goto.
    LDU   #$F9A3 ; Reset
    BSR   UPDATE_BAITER_MOVEMENT_RANDOM ; Set move speeds.
USE_NEW_GFX: ; 0x001AE4, $EAE4
    STU   2,X ; Store U to XOBJ[2]
SETUP_CALLBACK_AGAIN: ; 0x001AE6, $EAE6
    LDA   #$06 ; Callback setup
    LDX   #$EAB4
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
UPDATE_BAITER_MOVEMENT_RANDOM: ; 0x001AEE, $EAEE
    LDA   A0DF_RAND_BYTE ; Random val
    CMPA  R_A111_BAITER_MOVE_ODDS? ; If _ addr
    BLS   RTS ; <=, leave.
UPDATE_BAITER_MOVEMENT_ALWAYS: ; 0x001AF5, $EAF5
    LDD   #$4001 ; Move
    STD   A073_SCRATCHPAD_ADDR
    LDD   10,X ; D from XOBJ[10]
    SUBD  R_A0CC_SHIP_W_POS? ; Sub with
    BMI   DONT_NEGATE_SCRATCH[0] ; If now negative, goto.
    NEG   A073_SCRATCHPAD_ADDR ; Invert scratch.
DONT_NEGATE_SCRATCH[0]: ; 0x001B02, $EB02
    ADDD  #$0280 ; Add val
    CMPD  #$0500 ; If D _ #$0500
    BLS   DONT_USE_SCRATCH[0]_TO_D? ; <=, goto.
    LDB   A073_SCRATCHPAD_ADDR ; B random
    SEX ; Extend sign
    ADDD  SCREEN_H_DELTA ; Add with addr
    STD   14,X ; To HSPEED
DONT_USE_SCRATCH[0]_TO_D?: ; 0x001B12, $EB12
    LDA   12,X ; A from OBJ[12]
    SUBA  SHIP_SCR_POS_XXYY+1 ; Sub with ship Y
    BMI   DONT_NEGATE_SCRATCH[1] ; If negative, goto.
    NEG   A073_SCRATCHPAD_ADDR+1 ; Invert scratch val
DONT_NEGATE_SCRATCH[1]: ; 0x001B1A, $EB1A
    ADDA  #$0A ; Add val
    CMPA  #$14 ; If A _ #$14
    BLS   RTS ; <=, goto.
    CLRB ; Clear B
    LDA   A073_SCRATCHPAD_ADDR+1 ; Load scratch[1]
    ADDD  PLAYER_V_MOMENTUM ; Add with V momentum of player.
    ASRA ; D >> 1, half val.
    RORB
    STD   16,X ; To SPEEDV
RTS: ; 0x001B2A, $EB2A
    RTS
CALLBACK_BAITER_DESTROYED: ; 0x001B2B, $EB2B
    DEC   R_A119_BAITER_ALIVE_COUNT ; Dec counter.
    JSR   REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST ; Shot, add to score.
    .db $01
    .db $20 ; 200 points.
    .db $D4
    .db $FD ; Sound
    RTS ; RTS
MAKE_NUMBER_OF_PODS?: ; 0x001B36, $EB36
    STA   A073_SCRATCHPAD_ADDR ; A to addr.
LOOP_MAKE_PODS: ; 0x001B38, $EB38
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Make obj
    .db $F8 ; BMP
    .db $F7
    .db $EB ; HIT HANDLER
    .db $74
    .db $CC ; Scanner pixels
    .db $CC
    JSR   RANDOM_VALUE_FWD+IN_A ; Get rand
    LDD   A0E0_RAND_WORD ; D random
    ANDA  #$3F ; Range D to 0011.1111 1111.1111
    ADDA  #$10 ; +0001.0000 in high byte
    STD   10,X ; To WORLD_H
    LSRB ; B >> 1
    ADDB  #$2A ; Add #$2A, top of screen avoid?
    STB   12,X ; B to WORLD_V
    LDB   A0DF_RAND_BYTE ; B random
    ANDB  #$3F ; Save 0011.1111
    ADDB  #$E0 ; += E0
    SEX ; Sign extend to D
    STD   14,X ; to HSPEED
    LDB   A0E0_RAND_WORD+1 ; B random
    ANDB  #$7F ; Make positive
    SUBB  #$40 ; -=40
    SEX ; Sign extend to D, can be pos or neg.
    BMI   L_001B67 ; If negative, goto.
    ORB   #$20 ; B |= val, adds to min speed.
    BRA   L_001B69 ; Goto
L_001B67: ; 0x001B67, $EB67
    ANDB  #$DF ; Keep 1101.1111, adds to min speed negative.
L_001B69: ; 0x001B69, $EB69
    STD   16,X ; To VSPEED
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP ; Do
    DEC   A073_SCRATCHPAD_ADDR ; Dec scratch.
    BNE   LOOP_MAKE_PODS
    RTS ; RTS
CALLBACK_POD_DESTROYED: ; 0x001B74, $EB74
    JSR   REMOVE_XOBJ_FROM_LISTS_A065|A06B_AND_SCORE+SOUND_FROM_4B_PAST_JSR ; Sub
    .db $02 ; 1000 points?
    .db $10
    .db $D4 ; Sound
    .db $F3
    LDA   #$06 ; A seed
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get lower
    LEAY  X ; Y = XOBJ
    JSR   MAKE_A#_SWARMERS_FROM_YOBJ_INFO ; Clone obj?
    DEC   R_A114_PODS_ALIVE_COUNT? ; Dec count? To make?
    RTS
RANDOM_WORD_TO_HSPEED+VSPEED: ; 0x001B89, $EB89
    JSR   RANDOM_VALUE_FWD+IN_A ; Move random
    LDB   A0DF_RAND_BYTE ; Get random in B
    SEX ; Extend B into A
    ASLB ; Shift
    ROLA ; Shift
    STD   16,X ; Store to OBJ[16]
    LDB   A0E0_RAND_WORD+1 ; Get random again
    ANDB  #$3F ; Get bottom bits.
    ADDB  #$E0 ; Add val
    SEX ; Extend again
    STD   14,X ; Store to OBJ[14]
    RTS
MAKE_A#_SWARMERS_FROM_YOBJ_INFO: ; 0x001B9E, $EB9E
    PSHS  U,Y,X,B,A
    STA   A073_SCRATCHPAD_ADDR ; Store A to loop count
LOOP_MAKE_SWARMERS: ; 0x001BA2, $EBA2
    LDA   R_A116_SWARMERS_ALIVE_COUNT? ; Load val
    INCA ; Inc
    CMPA  #$14 ; If A _ #$14
    BHI   RTS ; >, GOTO
    STA   R_A116_SWARMERS_ALIVE_COUNT? ; Store back
    LDX   #$EC17 ; Callback for swarmer?
    LDA   #$00 ; Type?
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Setup
    LEAU  X ; Callback to U
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS
    .db $F9 ; BMP
    .db $7B
    .db $EB ; HIT HANDLER
    .db $E9
    .db $24 ; Scanner pixels.
    .db $24
    LDD   10,Y ; Copy HWORLD from YOBJ. YOBJ is the pos destroyed.
    STD   10,X ; To XOBJ, swarmer.
    LDD   12,Y ; Same with VWORLD
    STD   12,X
    STX   7,U ; Swarmer OBJ to UOBJ[7]
    STU   6,X ; Callback to XOBJ[6], XOBJ is swarmer.
    BSR   RANDOM_WORD_TO_HSPEED+VSPEED ; Get random speed.
    LDD   A0E0_RAND_WORD ; Get random word.
    ANDB  R_A10E_SWARMER[9]AND_VAL ; And B
    STB   9,U ; Store to CALLBACK_SWRM[9]
    ANDA  #$1F ; Get 0001.1111 into A
    STA   4,U ; Store to CALLBACK_SWRM[4], timer to run code. Coming out reverse?
    LDA   R_A10D_SWARMER_CALLBACK[11]_UNK ; Load val
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get smaller.
    STA   11,U ; Store to CALLBACK_SWRM[11]
    STX   LIST_IN_WORLD ; Add to this list.
    DEC   A073_SCRATCHPAD_ADDR ; Dec loop counter.
    BNE   LOOP_MAKE_SWARMERS
RTS: ; 0x001BE7, $EBE7
    PULS  A,B,X,Y,U,PC ; Leave
SWARMER_HIT_HANDLER: ; 0x001BE9, $EBE9
    DEC   R_A116_SWARMERS_ALIVE_COUNT? ; Dec count
    JSR   REMOVE_X_FROM_LIST+OFFSCREEN ; Remove from list.
    PSHS  X ; Save obj
    JSR   REMOVE_CALLBACK_ATTACHED_TO_XOBJ ; Pull callback for obj.
    PULS  X ; Restory obj deleted.
    LDD   10,X ; D is HWORLD
    SUBD  #$0040 ; Subtract val
    STD   10,X ; Store back.
    LDD   12,X ; D from VWORLD
    SUBA  #$02 ; Sub upper byte.
    STA   12,X ; Store back.
    LDU   #$F8E2 ; Switch GFX
    STU   2,X
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP ; Setup.
    LDD   #$0115 ; Score add +150
    JSR   SCORE_ADD_AB_SETTINGS ; Add to score.
    LDD   #$D516 ; Sound
    JMP   SOUND_SET_SOUND_PRIORITIED ; Do.
SWARMER_AI_INIT_SET_DIRECTION: ; 0x001C17, $EC17
    LDX   7,U ; X from UOBJ[7]
    LDB   R_A10C_SWARMER_HSPEED_BASE ; B from addr
    LDY   R_A0CC_SHIP_W_POS? ; Y from addr. TODO: Swarmer not swarming issue here?
    CMPY  10,X ; CMPY XOBJ[10]
    BCC   SKIP_INVERT_INIT ; >=, goto.
    NEGB ; Invert B otherwise.
SKIP_INVERT_INIT: ; 0x001C25, $EC25
    SEX ; Extend to D
    STD   14,X ; D to HSPEED
    BRA   SWARMER_CALLBACK_SETUP ; Goto
CALLBACK_AI_CONTINUED: ; 0x001C2A, $EC2A
    LDB   9,U ; B from UOBJ[9]
    LDX   7,U ; X from UOBJ[7]
    LDA   SHIP_SCR_POS_XXYY+1 ; A from SHIP.X
    CMPA  12,X ; Cmp to XOBJ[12], POS_WORLDV
    BHI   SKIP_INVERT_2 ; >, goto.
    NEGB ; Invert
SKIP_INVERT_2: ; 0x001C35, $EC35
    SEX ; Extend to D
    ADDD  16,X ; ADD with XOBJ[16], VSPEED
    CMPD  #$0200 ; CMP to val
    BLT   DONT_CAP_D ; <, goto.
    LDD   #$0200 ; D cap positive.
DONT_CAP_D: ; 0x001C42, $EC42
    CMPD  #$FE00 ; CMP val
    BGT   CAP_NEGATIVE
    LDD   #$FE00 ; D cap negative.
CAP_NEGATIVE: ; 0x001C4B, $EC4B
    STD   16,X ; To XOBJ[16], VSPEED
    COMA ; Invert
    COMB
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    TFR   A>B ; A to B
    SEX ; Extend from B
    ADDD  16,X ; += XOBJ[16], VSPEED
    STD   16,X ; D to XOBJ[16]
    LDB   A0DF_RAND_BYTE ; Random 
    ANDB  #$1F ; Keep 0001.1111
    ADDB  #$F0 ; +=F0
    SEX ; Extend to D
    ADDD  16,X ; D += XOBJ[16]
    STD   16,X ; D to XOBJ[16]
    LDD   R_A0CC_SHIP_W_POS? ; D from, WPOS_SHIP
    SUBD  10,X ; D -= XOBJ[10], POS_WORLDH
    ADDD  #$12C0 ; += val
    CMPD  #$2580 ; CMP to val
    BHI   SWARMER_AI_INIT_SET_DIRECTION ; >, goto. This is swarmer reverse. TODO: Fix not swarming.
    DEC   11,U ; Dec UOBJ[11]
    BNE   SWARMER_CALLBACK_SETUP ; != 0, goto.
    JSR   SWARMER_SHOOT_BULLET ; Do sub
SWARMER_CALLBACK_SETUP: ; 0x001C7E, $EC7E
    LDA   #$03 ; Setup callback.
    LDX   #$EC2A
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
SWARMER_SHOOT_BULLET: ; 0x001C86, $EC86
    PSHS  X ; Save X
    LDD   R_A0CC_SHIP_W_POS? ; D from
    SUBD  10,X ; D -= XOBJ[10]
    EORA  14,X ; Invert on XOBJ[14]
    BMI   BULLET_NOT_SPAWNED ; Result negative, goto.
    LEAY  X ; Y = XOBJ
    JSR   SPAWNS_BULLET/MINE_WITH_6_PAST_JSR
    .db $E4 ; Handler
    .db $D9
    .db $F9 ; BMP
    .db $5B
    .db $E5 ; HIT PLAYER?
    .db $1E
    BEQ   BULLET_NOT_SPAWNED ; If spawn rejected, don't fill info.
    LDD   14,Y ; HSPEED
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    STD   14,X ; D to HSPEED of bullet.
    LDD   #$D534 ; D = val
    JSR   SOUND_SET_SOUND_PRIORITIED ; Do sound req.
    CLRB ; Clear B
    LDA   SHIP_SCR_POS_XXYY+1 ; Get ship Y pos.
    SUBA  12,X ; A -= VPOS
    ASRA ; D >> 5
    RORB
    ASRA
    RORB
    ASRA
    RORB
    ASRA
    RORB
    ASRA
    RORB
    STD   16,X ; D to VPOS
BULLET_NOT_SPAWNED: ; 0x001CBF, $ECBF
    LDA   R_A10D_SWARMER_CALLBACK[11]_UNK ; A from addr
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get A
    STA   11,U ; To UOBJ[11]
    PULS  X,PC ; Restore X, RTS
CALLBACK_HUMANOID_MOVE?: ; 0x001CC9, $ECC9
    LDX   7,U ; X from UOBJ[7]
    LEAX  2,X ; X+=2
    CMPX  #$A13A ; Cmp to pool end.
    BCS   DONT_RESET_POOL_PTR ; If lower, in range, dont reset.
    LDX   #$A11A ; Reset X to pool start.
DONT_RESET_POOL_PTR: ; 0x001CD5, $ECD5
    STX   7,U ; X from UOBJ[7]
    LDX   X ; X to X.next
    BEQ   SETUP_HUMANOIDS_CALLBACK ; If 0, goto.
    LDD   4,X ; D from XOBJ[4]
    BEQ   SETUP_HUMANOIDS_CALLBACK ; If 0, goto.
    LDD   8,X ; D from XOBJ[8]
    CMPD  #$ED70 ; If D _ val
    BNE   SETUP_HUMANOIDS_CALLBACK ; != val, goto.
    LDD   2,X ; D from XOBJ[2]
    CMPD  #$F90B ; If D _ val
    BHI   L_001D1E ; >, goto.
    LDA   A0DF_RAND_BYTE ; Get rand
    CMPA  #$08 ; If _ #$08
    BLS   MOVE_HUMANOID ; <=, goto.
    JSR   WORLD_HEIGHT_FROM_XOBJ[10]_IN_A ; Do sub
    ADDA  #$04 ; A += 4
    CMPA  #$E8 ; If _ #$E8
    BLS   CAP_TO_#$E8 ; <=, goto.
    LDA   #$E8 ; A cap
CAP_TO_#$E8: ; 0x001D00, $ED00
    LDB   #$01 ; B =
    CMPA  12,X ; If A _ XOBJ[12]
    BEQ   DONT_UPDATE_OBJ[12] ; ==, goto.
    BHI   DONT_INVERT_B ; >, goto.
    NEGB ; Invert
DONT_INVERT_B: ; 0x001D09, $ED09
    ADDB  12,X ; B += XOBJ[12]
    STB   12,X ; to XOBJ[12]
DONT_UPDATE_OBJ[12]: ; 0x001D0D, $ED0D
    LDU   2,X ; U from UOBJ[2]
    LEAU  10,U ; U+=10
    CMPU  #$F90B ; If U _ #$F90B
    BLS   DONT_RESET_U ; <=, goto.
L_001D17: ; 0x001D17, $ED17
    LDU   #$F901 ; Reset addr.
DONT_RESET_U: ; 0x001D1A, $ED1A
    LDB   #$E0 ; B =
    BRA   L_001D4A ; Goto.
L_001D1E: ; 0x001D1E, $ED1E
    LDA   A0DF_RAND_BYTE ; Random
    CMPA  #$08 ; If A _ #$08
    BLS   L_001D17 ; <=, goto.
    BSR   WORLD_HEIGHT_FROM_XOBJ[10]_IN_A ; Do
    ADDA  #$0F ; += #$0F
    CMPA  #$E8 ; CMP to val
    BLS   DONT_CAP_VAL
    LDA   #$E8 ; Cap, lowest value possible.
DONT_CAP_VAL: ; 0x001D2E, $ED2E
    LDB   #$01 ; B =
    CMPA  12,X ; If A _ XOBJ[12]
    BEQ   SKIP_UPDATED_OBJ[12] ; ==, goto.
    BHI   DONT_INVERT_B ; >, goto.
    NEGB ; Invert B
DONT_INVERT_B: ; 0x001D37, $ED37
    ADDB  12,X ; B += XOBJ[12]
    STB   12,X ; B to XOBJ[12]
SKIP_UPDATED_OBJ[12]: ; 0x001D3B, $ED3B
    LDU   2,X ; U from XOBJ[2]
    LEAU  10,U ; U += 10
    CMPU  #$F91F ; If U _ val
    BLS   DONT_SWITCH_BMP ; <=, goto.
MOVE_HUMANOID: ; 0x001D45, $ED45
    LDU   #$F915 ; Other BMP ptr
DONT_SWITCH_BMP: ; 0x001D48, $ED48
    LDB   #$20 ; B =
L_001D4A: ; 0x001D4A, $ED4A
    STU   2,X ; BMP change.
    SEX ; Extend B to D
    ADDD  10,X ; D += POS
    STD   10,X ; Store new pos.
SETUP_HUMANOIDS_CALLBACK: ; 0x001D51, $ED51
    LDA   #$02
    LDX   #$ECC9
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
WORLD_HEIGHT_FROM_XOBJ[10]_IN_A: ; 0x001D59, $ED59
    PSHS  X,B ; Save
    LDD   10,X ; D from XOBJ[10]
    LSRA ; D >> 6
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LDX   #$B300 ; Height buffer ptr.
    LDA   D,X ; A = $B300 + D
    PULS  B,X,PC ; RTS
NO_HUMANOIDS_ON_SHIP?: ; 0x001D70, $ED70
    LDA   R_A0DE_HUMANOID_KILL_FLAG ; Load addr
    BEQ   HUMANOID_KILLED ; If 0, do.
    CLRA ; Set CC.Z flag?
    PULS  A,B,PC ; pull UNK+RTS
HUMANOID_KILLED: ; 0x001D77, $ED77
    BSR   HUMANOID_SLOT_CLEAR? ; Do
    JSR   REMOVE_X_FROM_LIST+OFFSCREEN ; Remove and handle?
    LDD   #$F8D8 ; D =
    STD   2,X ; To XOBJ[2]
    LDD   10,X ; D from XOBJ[10]
    SUBD  #$0040 ; D -= val
    STD   10,X ; To XOBJ[10]
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP ; Setup.
    LDD   #$D4E4 ; Explosion sound?
    JMP   SOUND_SET_SOUND_PRIORITIED ; Do, leaves.
CALLBACK_HUMANOID_LAND_TEST: ; 0x001D91, $ED91
    LDU   6,X ; U from XOBJ[6], group ptr.
    BEQ   NO_HUMANOIDS_ON_SHIP? ; If NULL, goto.
    LDA   R_A0DE_HUMANOID_KILL_FLAG ; Load flag
    BEQ   CALLBACK_HUMANOID_KILLED ; If 0, goto.
    LDD   2,U ; D = UOBJ[2]
    CMPD  #$F24C ; If D _ val
    BEQ   CHANGE_GFX_AND_RTS ; ==, goto. Changed BMP.
    LDD   #$D4DA ; D =
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play sound.
    PSHS  X ; Save XOBJ
    LDX   #$EE73 ; Humanoid put to planet.
    LDA   #$00 ; ASAP?
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Callback
    LEAY  X ; Y = CALLBACK OBJ
    PULS  X ; Restore previous X
    STX   7,Y ; To YOBJ[7]
CHANGE_GFX_AND_RTS: ; 0x001DB7, $EDB7
    LDD   #$F24C ; D =
    STD   2,U ; D to UOBJ[2], GFX.
CALLBACK_HIT_UNUSED?: ; 0x001DBC, $EDBC
    CLRA ; Set CC.Z?
    PULS  A,B,PC ; RTS pulling two?
CALLBACK_HUMANOID_KILLED: ; 0x001DBF, $EDBF
    BSR   HUMANOID_KILLED
    JMP   REMOVE_CALLBACK_ATTACHED_TO_XOBJ
HUMANOID_SLOT_CLEAR?: ; 0x001DC4, $EDC4
    LEAY  X ; Y = X OBJ
    PSHS  U,X,A ; Save
    LDU   #$A11A ; U to pool
    LDA   #$40 ; A =
LOOP_ALL_HUMANOID_SLOTS: ; 0x001DCD, $EDCD
    CMPY  U++ ; If Y _ U++
    BEQ   DESTROY_THIS_HUMANOID? ; ==, goto.
    DECA ; A--
    BNE   LOOP_ALL_HUMANOID_SLOTS ; != 0, goto
    JSR   SYSTEM_PANIC ; Do
DESTROY_THIS_HUMANOID?: ; 0x001DD8, $EDD8
    CLRA ; Clear D
    CLRB
    STD   -2,U ; D to UOBJ triggered on.
    DEC   A0FA_HUMANOID_COUNT ; --
    BNE   DONT_SCHEDULE_PLANET_BLOWUP ; != 0, RTS
    LDX   #$EDEA ; Callback to below, blows up planet.
    LDA   #$00 ; Timer
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Do
DONT_SCHEDULE_PLANET_BLOWUP: ; 0x001DE8, $EDE8
    PULS  A,X,U,PC ; RTS
CALLBACK_PLANET_BLOWUP?: ; 0x001DEA, $EDEA
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    ORA   #$02 ; Set 0000.0010 true. Humanoids gone true flag.
    STA   A0BA_PLAYER_GAME_STATE ; Store back
    CLR   7,U ; Clear UOBJ[7]
    JSR   BANKSWITCH_TO_7 ; In bank 7
    JSR   JMP_TO_CLEAR_LAND_ONSCREEN? ; Do
    LDX   #$B125 ; X ptr
    LDU   #$0000 ; U ptr
    LDA   #$40 ; A =
LOOP_#$40_TIMES: ; 0x001E00, $EE00
    STU   [X++] ; U to @X,++
    DECA ; Loop--
    BNE   LOOP_#$40_TIMES ; != 0, loop. B125->B1A4
LOOP_CREATE_EXPLOSIONS?: ; 0x001E05, $EE05
    LDX   LIST_23B_LARGE_POOL ; Load list
    LDD   #$F9F1 ; Ptr to BMP
    STD   2,X ; D to XOBJ[2]
    LDB   #$02 ; = val
    STB   A073_SCRATCHPAD_ADDR ; B to scratch
LOOP_ON_SCRATCH: ; 0x001E10, $EE10
    JSR   RANDOM_VALUE_FWD+IN_A ; Get rand
    ANDA  #$3F ; Keep 0011.1111
    ADDD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; D += addr
    STD   10,X ; To XOBJ[10]
    JSR   WORLD_HEIGHT_FROM_XOBJ[10]_IN_A ; Get A
    STA   12,X ; A to XOBJ[12]
    SUBA  #$0A ; A -= #$0A
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP ; Do
    DEC   A073_SCRATCHPAD_ADDR ; Dec scratch loop
    BNE   LOOP_ON_SCRATCH ; != 0, goto.
    LDA   A0DF_RAND_BYTE ; Get random
    ANDA  #$1F ; Keep 0001.1111
    LDX   #$E799 ; X ptr to color rotation table.
    LDA   A,X ; Get color
    STA   COLOR_PALETTE_RAM_COPY ; To color 10Store to palette.
    LDD   #$D4E4 ; Val
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play sound.
    LDX   #$EE44 ; Callback
    LDA   #$02
SEED+CALLBACK: ; 0x001E3D, $EE3D
    LDB   #$08 ; Seed value.
    STB   R_A05E_SLOWDOWN_FLAG? ; Store to slowdown.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Do
CALLBACK_CONTINUE_EXPLOSION?: ; 0x001E44, $EE44
    CLR   COLOR_PALETTE_RAM_COPY ; Clear palette val.
    LDA   7,U ; A from UOBJ[7]
    LSRA ; >> 3
    LSRA
    LSRA
    INCA ; A++
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get new random time.
    LDX   #$EE54 ; Callback
    BRA   SEED+CALLBACK ; Set
CALLBACK_RAND_TIMING: ; 0x001E54, $EE54
    INC   7,U ; UOBJ[7]++
    LDA   7,U ; Load it
    CMPA  #$10 ; If A _ #$10
    BNE   LOOP_CREATE_EXPLOSIONS? ; !=, keep doing.
    LDD   #$D4C7 ; D ptr to
    JSR   SOUND_SET_SOUND_PRIORITIED ; Final explosion sound?
    JMP   CALLBACK_TASK_REMOVE ; Done.
HUMANOID_FELL_TO_PLANET: ; 0x001E65, $EE65
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Do
    .db $F9 ; BMP, 250
    .db $DD
    .db $ED ; HIT HANDLER
    .db $BC
    .db $00 ; Scanner pixels.
    .db $00
    LDD   #$0125 ; + 250
    BRA   SCORE_ADD+SETUP_BONUS_TEXT_WORLD_OBJ ; Goto
HUMANOID_SHIP_TO_PLANET?: ; 0x001E73, $EE73
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS
    .db $F9 ; BMP, 500
    .db $E7
    .db $ED ; HIT HANDLER
    .db $BC
    .db $00 ; Scanner pixels.
    .db $00
    LDD   #$0150 ; +500, putting humanoid down?
SCORE_ADD+SETUP_BONUS_TEXT_WORLD_OBJ: ; 0x001E7F, $EE7F
    JSR   SCORE_ADD_AB_SETTINGS ; Add D setting to score, 250 or 500.
    LDY   7,U ; Load humanoid pointer.
    LDD   SCREEN_H_DELTA ; Load move delta.
    STD   14,X ; Store to score HSPEED
    LDD   #$0000 ; Clear D
    STD   16,X ; Clear VSPEED
    LDA   #$11 ; 11
    STA   20,X ; Set ATTR
    LDD   10,Y ; Load HWORLD from humanoid.
    STD   10,X ; To points HWORLD
    LDD   12,Y ; VWORLD
    BMI   MOVE_UP_IF_AT_BOTTOM ; If negative, goto.
    ADDD  #$1800 ; Move down by adding.
    BRA   SKIP_SUB_WAS_POSITIVE ; Goto
MOVE_UP_IF_AT_BOTTOM: ; 0x001EA1, $EEA1
    SUBD  #$2000 ; Move up by subbing.
SKIP_SUB_WAS_POSITIVE: ; 0x001EA4, $EEA4
    STD   12,X ; Moved to VWORLD
    STX   LIST_IN_WORLD ; Put in world.
    STX   7,U ; Obj to callback.
    LDA   #$32 ; Callback
    LDX   #$EEB2 ; Callback addr
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_REMOVE_BONUS_TEXT: ; 0x001EB2, $EEB2
    LDX   7,U ; Load OBJ made.
    JSR   REMOVE_X_FROM_LIST+OFFSCREEN ; Destroy.
    JMP   CALLBACK_TASK_REMOVE
SPAWN_BULLET_REQ: ; 0x001EBA, $EEBA
    PSHS  X ; Save X obj. REQ because can fail. CC.Z 0 = Fail.
    JSR   SPAWNS_BULLET/MINE_WITH_6_PAST_JSR ; Do IDK
    .db $E4 ; UPDATE HANDLER?
    .db $D9
    .db $F9 ; BMP
    .db $5B
    .db $E5 ; HIT PLAYER HANDLER?
    .db $1E
    BEQ   RTS ; No objs available, leave.
    LDB   A0DF_RAND_BYTE ; Get rand
    ANDB  #$1F ; Get 0001.1111
    ADDB  #$F0 ; += F0
    ADDB  SHIP_SCR_POS_XXYY ; +=
    SUBB  4,X ; B -= X[4]
    SEX ; Extend to D
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    STD   14,X ; D is HSPEED
    LDB   A0DF_RAND_BYTE ; B rand
    CMPB  #$78 ; If B _ #$78
    BLS   B_IS_<=_#$78 ; <=, goto.
    LDD   SCREEN_H_DELTA ; D from
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    ADDD  14,X ; D += HSPEED
    STD   14,X ; Store HSPEED
B_IS_<=_#$78: ; 0x001EE8, $EEE8
    LDB   A0E0_RAND_WORD+1 ; B from rand+1
    ANDB  #$1F ; Keep 0001.1111
    ADDB  #$F0 ; += #$F0
    ADDB  SHIP_SCR_POS_XXYY+1 ; B += SHIP.Y
    SUBB  5,X ; B -= X[5]
    SEX ; Extend to D
    ASLB ; D >> 2
    ROLA
    ASLB
    ROLA
    STD   16,X ; D to VSPEED
    LDA   #$01 ; True
RTS: ; 0x001EFC, $EEFC
    PULS  X,PC
SHOOT_BULLET_IF_U[13]--==0: ; 0x001EFE, $EEFE
    DEC   13,U ; Dec UOBJ[13]
    BNE   RTS
    LDA   R_A105_MAX_BULLET_TIMER_LANDER ; A from addr
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get <= val
    STA   13,U ; To UOBJ[13]
    BSR   SPAWN_BULLET_REQ ; Ask for bullet.
    BEQ   RTS ; If not successful, rts.
    LDD   #$D525 ; D from
    JSR   SOUND_SET_SOUND_PRIORITIED
RTS: ; 0x001F14, $EF14
    RTS
MAKE_NUMBER_OF_ENEMIES_MUTANT?: ; 0x001F15, $EF15
    PSHS  A ; Save A
    STA   A073_SCRATCHPAD_ADDR ; Loop counter
LOOP_MAKE_ENEMY_MUTANT: ; 0x001F19, $EF19
    LDX   #$F15E ; Handler
    LDA   #$00 ; Type
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Make obj
    LEAU  X ; Obj to U
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Data to it.
    .db $F8 ; BMP
    .db $CE
    .db $EF ; HIT HANDLER
    .db $6D
    .db $CC ; Scanner pixels.
    .db $33
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load
    SUBD  #$2580 ; Subtract
    STD   R_A075_ABDUCT_POS_TEST? ; Store
    LDD   A0E0_RAND_WORD ; Loasd
    SUBD  R_A075_ABDUCT_POS_TEST? ; Sub
    CMPD  #$4B00 ; Compare to val
    BCC   DONT_ADD_8000
    ADDD  #$8000 ; Add
DONT_ADD_8000: ; 0x001F43, $EF43
    ADDD  R_A075_ABDUCT_POS_TEST? ; Add always
    STD   10,X ; Store to OBJ[10]
    LDA   A0DF_RAND_BYTE ; Random
    LSRA ; Shift
    ADDA  #$2A ; Add
    STA   12,X ; Store to OBJ[12]
    CLRA ; Clear D
    CLRB
    STD   16,X ; Clear OBJ[16]
    STD   14,X ; Clear OBJ[14]
    LDA   R_A10B_BAITER|MUTANT_SHOOT_TIMER ; Load val
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get <= val
    STA   7,U ; Store to OBJ[7]
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP ; Particle in?
    STU   6,X ; Store OBJ U to OBJ[6]@X
    STX   7,U ; Store OBJ X to OBJ[7]@U
    INC   R_A115_MUTANT_ALIVE_COUNT? ; Inc enemy count
    DEC   A073_SCRATCHPAD_ADDR
    BNE   LOOP_MAKE_ENEMY_MUTANT
    PULS  A,PC
HANDLER_MUTANT_HIT: ; 0x001F6D, $EF6D
    DEC   R_A115_MUTANT_ALIVE_COUNT?
    JSR   REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST
    .db $01 ; Points 150?
    .db $15
    .db $D4 ; Sound
    .db $F8
    RTS
RAN_IF_HUMANOIDS,TEST_ABDUCT?: ; 0x001F78, $EF78
    PSHS  X ; Save
    LDA   A0FA_HUMANOID_COUNT ; Get count
    BEQ   RTS ; If 0, RTS.
    LDX   HUMANOID_LAST_MARKED_PTR ; X from val
LOOP_FIND_NEXT_HUMANOID_SLOT: ; 0x001F80, $EF80
    LEAX  2,X ; +=2, next pointer.
    CMPX  #$A15A ; Humanoid data end.
    BCS   DONT_RESET
    LDX   #$A11A ; Reset, humanoid data ptr.
DONT_RESET: ; 0x001F8A, $EF8A
    LDD   X ; Load from
    BNE   A09B_UPDATED,WRITE_OBJ_[9]_[11] ; Not cleared, goto.
    CMPX  HUMANOID_LAST_MARKED_PTR ; X _ ADDR
    BNE   LOOP_FIND_NEXT_HUMANOID_SLOT ; !=, goto.
    PULS  X,PC ; RTS if wrapped.
A09B_UPDATED,WRITE_OBJ_[9]_[11]: ; 0x001F94, $EF94
    STX   HUMANOID_LAST_MARKED_PTR ; Store last updated.
    STD   9,U ; D to UOBJ[9], idk val
    STX   11,U ; X to UOBJ[11], PTR to humanoid data.
RTS: ; 0x001F9A, $EF9A
    PULS  X,PC ; RTS
SPAWN_WAVE_OF_ENEMIES_LANDER/MUTANT: ; 0x001F9C, $EF9C
    PSHS  A ; Save A, request value.
    STA   A073_SCRATCHPAD_ADDR ; To loop counter scratch, as is our max.
LOOP_MAKE_LANDERS|MUTANTS: ; 0x001FA0, $EFA0
    TST   A0FA_HUMANOID_COUNT ; Test humanoid alive.
    BNE   MAKE_LANDERS ; Don't turn to mutants if has humanoids.
    JMP   LOOP_MAKE_ENEMY_MUTANT ; Makes mutants instead.
MAKE_LANDERS: ; 0x001FA7, $EFA7
    LDX   #$EFF6 ; Handler
    LDA   #$00 ; Timer
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Setup
    LEAU  X ; Obj X to U, callback made for obj.
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Fill out info past.
    .db $F9 ; BMP
    .db $85
    .db $F2 ; HIT HANDLER
    .db $0B
    .db $44 ; Scanner pixels.
    .db $33
    JSR   RANDOM_VALUE_FWD+IN_A ; Random value
    LDD   A0E0_RAND_WORD ; Random word
    STD   10,X ; to OBJ[10], POS_HWORLD
    LDA   #$2C ; Val
    STA   12,X ; to OBJ[12], POS_VWORLD
    LDD   R_A103_LANDER_VSPEED ; Val
    STD   16,X ; to VSPEED
    LDA   R_A105_MAX_BULLET_TIMER_LANDER ; Val
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Manipulate
    STA   13,U ; Shoot countdown to callback.
    LDA   R_A102_LANDER_ATTR_SPEED ; Val
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Manip
    TFR   A>B ; Rand manip to B
    CLRA ; Clear A
    BITB  #$01 ; Test bit
    BEQ   DONT_NEGATE_TO_NEGATIVE ; If 0, don't invert.
    COMB ; Invert
    COMA
DONT_NEGATE_TO_NEGATIVE: ; 0x001FE2, $EFE2
    STD   14,X ; To HSPEED
    STU   6,X ; Callback to OBJ[6]
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP ; Spawn in.
    STX   7,U ; OBJ to CALLBACK[6]
    BSR   RAN_IF_HUMANOIDS,TEST_ABDUCT? ; Idk
    INC   R_A112_LANDER_COUNT? ; Inc count
    DEC   A073_SCRATCHPAD_ADDR ; Loop count
    BNE   LOOP_MAKE_LANDERS|MUTANTS
    PULS  A,PC ; RTS
HANDLER_LANDER_BASE: ; 0x001FF6, $EFF6
    LDX   7,U ; OBJ to X from callback.
    LDY   9,U ; Y from UOBJ[9]
    LDD   [11,U] ; D from UOBJ[11] ptr, humanoid data.
    BEQ   HUMANOID_DATA_BLANKED ; If 0, goto.
    LDA   9,Y ; A = YOBJ[9]
    CMPA  #$70 ; if _ #$70
    BNE   HUMANOID_DATA_BLANKED ; !=, goto.
    LDA   10,X ; A from XOBJ[10]
    ANDA  #$FC ; Keep 1111.1100
    STA   A073_SCRATCHPAD_ADDR ; To scratch
    LDA   10,Y ; A from YOBJ[10]
    ANDA  #$FC ; Keep 1111.1100
    CMPA  A073_SCRATCHPAD_ADDR ; If _ to other val
    BEQ   CALLBACK_ABDUCTING? ; ==, goto.
    BRA   L_002025 ; Otherwise, goto. TODO: Name well.
HUMANOID_DATA_BLANKED: ; 0x002016, $F016
    LDA   20,X ; A from XOBJ[20]
    ANDA  #$FE ; Keep 1111.1110
    STA   20,X ; To XOBJ[20]
    JSR   RAN_IF_HUMANOIDS,TEST_ABDUCT? ; Do
    LBEQ  CALLBACK_UNK_LANDER_TO_MUTANT?ABDUCTING? ; If 0 ret, goto.
L_002025: ; 0x002025, $F025
    JSR   WORLD_HEIGHT_FROM_XOBJ[10]_IN_A ; Get height under obj
    SUBA  #$32 ; Make higher
    SUBA  12,X ; -= XOBJ[12]
    BHI   LANDER_VSPEED_TOWARDS_PLANET ; > signed, goto.
    CMPA  #$EC ; If A _ #$EC
    BLT   LANDER_VSPEED_TOWARDS_SCANNER ; <, goto.
    CLRA ; No change.
    CLRB
    BRA   LANDER_VSPEED_FROM_D ; Goto
LANDER_VSPEED_TOWARDS_SCANNER: ; 0x002036, $F036
    LDD   R_A103_LANDER_VSPEED ; D from
    COMA ; Invert
    COMB
    BRA   LANDER_VSPEED_FROM_D ; Goto
LANDER_VSPEED_TOWARDS_PLANET: ; 0x00203D, $F03D
    LDD   R_A103_LANDER_VSPEED ; D from
LANDER_VSPEED_FROM_D: ; 0x002040, $F040
    STD   16,X ; D to VSPEED
    LDD   2,X ; D from XOBJ[2], GFX
    CMPD  #$F8EC ; If GFX
    BEQ   SETUP_OBJ_CALLBACK ; ==, goto.
    JSR   SHOOT_BULLET_IF_U[13]--==0 ; Shoot maybe.
    LDU   2,X ; OBJ GFX to U
    LEAU  10,U ; Next BMP
    CMPU  #$F999 ; If U _ #$F999
    BLS   DONT_RESET_ANIMATION ; <=, goto.
    LDU   #$F985 ; Reset GFX on 4th frame.
DONT_RESET_ANIMATION: ; 0x00205B, $F05B
    STU   2,X ; Animate GFX
SETUP_OBJ_CALLBACK: ; 0x00205D, $F05D
    LDA   #$06 ; Ticks
    LDX   #$EFF6 ; CB
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Test abduct callback?
CALLBACK_ABDUCTING?: ; 0x002065, $F065
    CLRA ; CLRD
    CLRB
    INC   20,X ; XOBJ[20]++
    STD   14,X ; Clear XOBJ[14]
    STD   16,X ; Clear XOBJ[16]
    LDD   #$F985 ; D =
    STD   2,X ; D to XOBJ[2]
CALLBACK_ABDUCT_CONTINUE?: ; 0x002074, $F074
    LDX   7,U ; X to UOBJ[7]
    LDY   9,U ; Y = UOBJ[9]
    LDD   [11,U] ; D from UOBJ[11] ptr
    BEQ   HUMANOID_DATA_BLANKED ; If 0, goto.
    LDA   9,Y ; A from YOBJ[9]
    CMPA  #$70 ; If A _ #$70
    BNE   HUMANOID_DATA_BLANKED ; !=, goto.
    LDD   10,Y ; D from YOBJ[10]
    ANDB  #$E0 ; Keep 1110.0000
    STD   R_A075_ABDUCT_POS_TEST? ; D to addr
    LDD   10,X ; D from XOBJ[10]
    ANDB  #$E0 ; Keep 1110.0000
    CMPD  R_A075_ABDUCT_POS_TEST? ; If D _ addr
    BEQ   DONT_REASSIGN_HPOS? ; ==, goto.
    BLT   B_POSITIVE ; <, goto.
    LDB   #$E0 ; Seed FFE0
    BRA   USE_B_ASIS ; Goto, Negative B
B_POSITIVE: ; 0x002099, $F099
    LDB   #$20 ; Seed 0020
USE_B_ASIS: ; 0x00209B, $F09B
    SEX ; Extend to D
    ADDD  10,X ; D += XOBJ[10]
    STD   10,X ; Back to XOBJ[10]
DONT_REASSIGN_HPOS?: ; 0x0020A0, $F0A0
    LDA   12,Y ; A from YOBJ[12]
    SUBA  #$0C ; -= #$0C
    CMPA  12,X ; CMP XOBJ[12]
    BEQ   ABDUCT_SUCCESSFUL ; ==, goto.
    LDD   R_A103_LANDER_VSPEED ; D from reg
    BCC   DONT_INVERT_D ; If cond, goto.
    COMA ; Invert D
    COMB
DONT_INVERT_D: ; 0x0020AF, $F0AF
    ADDD  12,X ; D += XOBJ[12]
    STD   12,X ; D += XOBJ[12]
L_0020B3: ; 0x0020B3, $F0B3
    JSR   SHOOT_BULLET_IF_U[13]--==0 ; Do sub
    LDA   #$01 ; Callback continue abducting.
    LDX   #$F074
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
ABDUCT_SUCCESSFUL: ; 0x0020BE, $F0BE
    LDD   10,X ; D from XOBJ[10]
    ADDD  #$0040 ; +=
    SUBD  10,Y ; D -= YOBJ[10]
    CMPD  #$0080 ; If D _ val
    BHI   L_0020B3 ; >, goto.
    LDD   #$F1E0 ; Lander with humanoid shot code.
    STD   8,X ; Replace shot handler.
    LDD   R_A103_LANDER_VSPEED ; D from
    COMB ; Invert vspeed for abduct.
    COMA
    STD   16,X ; To XOBJ[16]
    STD   16,Y ; To YOBJ[16]
    LDD   #$D50C ; Play sound.
    JSR   SOUND_SET_SOUND_PRIORITIED ; Do
    LDD   #$ED91 ; Ptr to humanoid landed code?
    STD   8,Y ; To YOBJ[8]
CALLBACK_IDK: ; 0x0020E6, $F0E6
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Restor ptr to task.
    LDX   7,U ; X from UOBJ[7]
    LDA   12,X ; A from XOBJ[12]
    CMPA  #$32 ; If A _ #$32
    BLS   HUMANOID_PROBE_READY ; <=, goto.
    JSR   SHOOT_BULLET_IF_U[13]--==0 ;  If not, don't forget to shoot.
    LDA   #$04 ; Callback setup.
    LDX   #$F0E6
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
HUMANOID_PROBE_READY: ; 0x0020FB, $F0FB
    LDD   #$D511 ; About to be probed sound.
    JSR   SOUND_SET_SOUND_PRIORITIED ; Play sound.
CALLBACK_PROBE_TEST: ; 0x002101, $F101
    LDX   7,U ; X from UOBJ[7]
    LDY   9,U ; Y from UOBJ[9]
    LDD   [11,U] ; D from list pointed to by U[11]
    BNE   VALID_HUMANOID_PTR? ; If valid, goto.
    JSR   REMOVE_X_FROM_LIST+OFFSCREEN
    DEC   R_A112_LANDER_COUNT? ; One less lander?
    INC   R_A0FB_ENEMY_LANDER_TO_SPAWN_COUNT? ; Respawn.
    JMP   CALLBACK_TASK_REMOVE ; Do
VALID_HUMANOID_PTR?: ; 0x002116, $F116
    CLRA ; Clear D
    CLRB
    STD   16,X ; Clear enemy VSPEED
    STD   16,Y ; Clear human VSPEED
    LDA   12,Y ; Load VWORLD of human
    CMPA  12,X ; If HUM.VWORLD _ ENEMY
    BLS   HUM_<=_ENEMY ; <=, goto, probe action.
    DEC   12,Y ; Move humanoid closer.
    LDA   #$12 ; Sound?
    JSR   OUTPUT_B_TO_SOUND_BOARD ; Output val.
    LDA   #$01 ; Callback to above test.
    LDX   #$F101
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
HUM_<=_ENEMY: ; 0x002133, $F133
    LEAX  Y ; X obj humanoid.
    LDD   4,Y ; Load SCR_POS
    ADDA  #$01 ; XPOS+1
    STD   R_A0F8_PARTICLE_CENTRAL_POINT ; Particle central point store.
    JSR   HUMANOID_KILLED ; Destroy humanoid.
CALLBACK_UNK_LANDER_TO_MUTANT?ABDUCTING?: ; 0x00213E, $F13E
    DEC   R_A112_LANDER_COUNT? ; Change lander count.
    INC   R_A115_MUTANT_ALIVE_COUNT? ; Change mutant count.
    LDX   7,U ; X from callback, enemy ptr.
    CLR   20,X ; Clear ATTR for offscreen.
    LDD   #$F8CE ; GFX ptr, mutant.
    STD   2,X ; To obj
    LDD   #$CC33 ; Scanner pixels.
    STD   18,X
    LDD   #$EF6D ; Mutant destroyed handler.
    STD   8,X
    LDA   R_A10B_BAITER|MUTANT_SHOOT_TIMER ; Shoot timer from baiter.
    STA   9,U
CALLBACK_MUTANT_AI?: ; 0x00215E, $F15E
    LDX   7,U ; X from YOBJ[U]
    LDB   R_A10A_MUTANT_HSPEED? ; B from addr
    LDY   R_A0CC_SHIP_W_POS? ; Y from addr
    CMPY  10,X ; CMPY to XOBJ[10]
    BGE   DONT_INVERT_B ; >=, goto. TODO: Mutant line issue here?
    NEGB
DONT_INVERT_B: ; 0x00216C, $F16C
    SEX ; Extend to D
    STD   14,X ; To XOBJ[14]
    LDD   R_A0CC_SHIP_W_POS? ; D from addr
    SUBD  10,X ; D -= XOBJ[10]
    ADDD  #$017C ; += val
    CMPD  #$0700 ; CMP to val
    BLS   D_LTE_TO_0700 ; <=, goto.
    LDA   SHIP_SCR_POS_XXYY+1 ; A from ship Y
    SUBA  12,X ; -= XOBJ[12]
    BLS   L_00218D ; sub'd <= val, goto.
    CMPA  #$08 ; CMP to val
    BHI   CLEAR_D ; >, goto.
    LDD   R_A108_BAITER_VSPEED_BASE? ; D from
    COMA ; Invert
    COMB
    BRA   COMMIT_D_TO_XOBJ[16](VSPEED) ; Goto
L_00218D: ; 0x00218D, $F18D
    CMPA  #$F8 ; If A _ #$F8
    BGT   VSPEED_A108_INSTEAD ; >, goto.
CLEAR_D: ; 0x002191, $F191
    CLRA ; Clear D
    CLRB
    BRA   COMMIT_D_TO_XOBJ[16](VSPEED) ; Commit
VSPEED_A108_INSTEAD: ; 0x002195, $F195
    LDD   R_A108_BAITER_VSPEED_BASE? ; Commit this value
COMMIT_D_TO_XOBJ[16](VSPEED): ; 0x002198, $F198
    STD   16,X ; To XOBJ[16], VSPEED
    BRA   VSPEED_WAS_BASED_SKIP_AHEAD ; Goto
D_LTE_TO_0700: ; 0x00219D, $F19D
    LDA   SHIP_SCR_POS_XXYY+1 ; A from ship Y
    CMPA  12,X ; CMP to XOBJ[12]
    LDD   R_A108_BAITER_VSPEED_BASE? ; D seed.
    BCC   DONT_INVERT_D ; A >= val, goto.
    COMA ; Invert
    COMB
DONT_INVERT_D: ; 0x0021A8, $F1A8
    STD   16,X ; D to XOBJ[16]
    LDD   4,X ; D from XOBJ[4]
    BEQ   SETUP_CALLBACK ; If 0, goto.
VSPEED_WAS_BASED_SKIP_AHEAD: ; 0x0021AF, $F1AF
    LDB   R_A107_UNK_ENEMY_VSPEED_MODIFY_BAITER? ; B from
    LDA   A0DF_RAND_BYTE ; Get rand
    BMI   B_NOT_NEGATED ; If random is negative, goto. Not negating B.
    NEGB ; Make negative.
B_NOT_NEGATED: ; 0x0021B7, $F1B7
    ADDB  12,X ; B += XOBJ[12]
    CMPB  #$2A ; If B _ #$2A
    BCC   DONT_ROLL_TO_BOTTOM_OF_SCREEN ; >=, goto.
    LDB   #$F0 ; Roll?
DONT_ROLL_TO_BOTTOM_OF_SCREEN: ; 0x0021BF, $F1BF
    STB   12,X ; To XOBJ[12], Y pos.
    DEC   9,U ; UOBJ[9]--
    BNE   SETUP_CALLBACK ; Not 0, goto.
    LDA   R_A10B_BAITER|MUTANT_SHOOT_TIMER ; A from, difficulty?
    JSR   GET_NEW_A_THAT_IS_<=_OR_1_MORE_THAN_CURRENT ; Get new
    STA   9,U ; Store to UOBJ[9], new timer for bullet.
    JSR   SPAWN_BULLET_REQ ; Spawn
    BEQ   SETUP_CALLBACK ; Not successful, skip sound.
    LDD   #$D52A ; Set sound. Bullet.
    JSR   SOUND_SET_SOUND_PRIORITIED
SETUP_CALLBACK: ; 0x0021D8, $F1D8
    LDA   #$03 ; Setup callback.
    LDX   #$F15E
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
LANDER_WITH_HUMANOID_SHOT: ; 0x0021E0, $F1E0
    LDU   6,X ; Load enemy from callback.
    LDD   [11,U] ; Load humanoid data from callback.
    BEQ   NO_HUMANOID_ATTACHED_TO_LANDER ; If NULL, goto.
    LDD   #$0000 ; D = 0
    LDD   #$0000 ; D = 0, again. Mistake?
    PSHS  X ; Save X obj.
    LDX   #$F216 ; Code, humanoid falling.
    LDA   #$00 ; Callback
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Setup for this rtn
    LDU   9,U ; Load DATA_PTR_ADDR
    STU   7,X ; To CALLBACK_7
    LDD   #$D4E9 ; Humanoid falling sound.
    JSR   SOUND_SET_SOUND_PRIORITIED
    LDD   #$0000 ; D = 0, again.
    STD   16,U ; Clear UOBJ[16]
    STX   6,U ; X to UOBJ[16]
    PULS  X ; Get X obj
NO_HUMANOID_ATTACHED_TO_LANDER: ; 0x00220B, $F20B
    DEC   R_A112_LANDER_COUNT? ; Landers--
    JSR   REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST ; Do
    .db $01 ; Score of 150, lander, mutant, swarmer.
    .db $15
    .db $D5 ; Sound
    .db $07
    RTS ; Leave?
CALLBACK_HUMANOID_FALLING: ; 0x002216, $F216
    LDX   7,U ; Load humanoid ptr.
    LDD   #$0008 ; VSPEED to add.
    ADDD  16,X ; Add to VSPEED
    CMPD  #$0300 ; Cap val
    BCC   VSPEED_CAPPED ; If >=, don't store.
    STD   16,X ; Store non-capped.
VSPEED_CAPPED: ; 0x002227, $F227
    JSR   WORLD_HEIGHT_FROM_XOBJ[10]_IN_A ; Get height under obj.
    CMPA  12,X ; If A _ XOBJ[12], VPOS
    BHI   HUMANOID_FALLING_CALL_CONTINUE ; >, goto, reschedule as not landed.
    LDD   16,X ; D from XOBJ[16]
    CMPD  #$00E0 ; If D _ val
    BLS   HUMANOID_FELL_SAFELY ; <=, goto, landed safely.
    LDD   4,X ; Load SCR_POS
    ADDD  #$0107 ; Move point.
    STD   R_A0F8_PARTICLE_CENTRAL_POINT ; Store to particle.
    JSR   HUMANOID_KILLED ; Killed from falling.
    JMP   CALLBACK_TASK_REMOVE ; Remove callback.
HUMANOID_FALLING_CALL_CONTINUE: ; 0x002244, $F244
    LDA   #$04
    LDX   #$F216
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_HUMANOID_LAND_CHECK_FALL+ONSHIP: ; 0x00224C, $F24C
    LDX   7,U ; X from UOBJ[7]
    LDD   #$0000 ; Clear XOBJ[16]
    STD   16,X ; Clear, VSPEED
    LDA   SHIP_VPOS ; Get ship pos.
    ADDA  #$0A ; += VAL
    STA   12,X ; To humanoid VPOS
    LDD   R_A0CC_SHIP_W_POS? ; D from
    ADDD  #$0080 ; += val
    STD   10,X ; To humanoid HPOS
    JSR   WORLD_HEIGHT_FROM_XOBJ[10]_IN_A ; Get height of ship pos.
    CMPA  12,X ; If A _ XOBJ[12]
    BCS   HUMANOID_SET_DOWN ; GRND < HUM, set down.
    LDA   #$01 ; Setup callback to put down check otherwise.
    LDX   #$F24C
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
HUMANOID_FELL_SAFELY: ; 0x002270, $F270
    PSHS  X ; Save humanoid obj.
    LDX   #$EE65 ; Ptr to fell handler.
    BRA   SKIP_OTHER_LOAD
HUMANOID_SET_DOWN: ; 0x002277, $F277
    PSHS  X ; Save humanoid obj.
    LDX   #$EE73 ; Ptr to put down handler.
SKIP_OTHER_LOAD: ; 0x00227C, $F27C
    LDA   #$00 ; Callback counter, asap.
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Schedule callback.
    LEAY  X ; Callback made to Y
    PULS  X ; Recover obj passed.
    STX   7,Y ; Humanoid to callback.
    LDD   #$0000 ; Clear
    STD   6,X ; Clear group
    STD   16,X ; Clear VSPEED
    LDD   #$ED70 ; Ptr to destroy code.
    STD   8,X ; Destroy handler.
    LDD   #$D4DF ; Sound, 250/500 points sound?
    JSR   SOUND_SET_SOUND_PRIORITIED ; Do sound.
    JMP   CALLBACK_TASK_REMOVE ; Handled.
MAKE_#_BOMBERS_GROUP: ; 0x00229D, $F29D
    STA   A073_SCRATCHPAD_ADDR ; A to scratch.
    LDB   R_A106_BOMBERS_SPEED ; B from addr.
    COM   R_A0AA_BOMBERS_GROUP_DIR ; Invert addr.
    BMI   DONT_INVERT_B ; If addr now minus, goto.
    NEGB ; Invert B
DONT_INVERT_B: ; 0x0022A7, $F2A7
    STB   A073_SCRATCHPAD_ADDR+1 ; B to scratch+1, used for all group.
    LDX   #$F2F7 ; Handler, bomber AI?
    LDA   #$00 ; Count
    JSR   SCHEDULE_23B_CALLBACK_TYPE=A_CB=X_NEXT_TICK ; Get 23B callback.
    LEAU  X ; U is new obj returned.
    LDA   A073_SCRATCHPAD_ADDR ; A from scratch
    STA   15,U ; To UOBJ[15]
    CLRA ; Clear D
    CLRB
    STD   7,U ; Clear UOBJ[7] to UOBJ[14], obj pointers in callback.
    STD   9,U
    STD   11,U
    STD   13,U
MAKE_BOMBER_GROUP: ; 0x0022C1, $F2C1
    JSR   23B_OBJ_BMP,HIT_HANDLER,SCANNER_PIXELS ; Fill with info.
    .db $F9 ; BMP
    .db $29
    .db $F3 ; Destroy handler.
    .db $BC
    .db $88 ; Scanner pixels.
    .db $88
    LDB   A073_SCRATCHPAD_ADDR+1 ; B from scratch, group hspeed.
    SEX ; Extend to 16-bit.
    STD   14,X ; To HSPEED
    CLRA
    CLRB
    STD   16,X ; Clear VSPEED
    LDA   A073_SCRATCHPAD_ADDR ; A from num left to make.
    LSRA ; D >> 1, half value.
    RORB
    ADDA  A073_SCRATCHPAD_ADDR ; Add original.
    ADDD  R_A0CC_SHIP_W_POS? ; D += addr
    ADDA  #$80 ; Other side of world.
    STD   10,X ; D to HWORLD pos.
    LDA   #$50 ; Add to A, keeping B intact.
    STA   12,X ; to VWORLD. Probs supposed to be STD? TODO: What if.
    STA   16,U ; And UOBJ[16], unsure.
    STU   6,X ; Callback to object.
    STX   LIST_IN_WORLD ; X now in world.
    LDA   A073_SCRATCHPAD_ADDR ; A from scratch
    ASLA ; A << 1, *2, make index.
    ADDA  #$05 ; += 5, 7 minimum, 13 max.
    STX   A,U ; OBJ made to U[7/9/11/13] based on index.
    DEC   A073_SCRATCHPAD_ADDR ; ToMake--
    BNE   MAKE_BOMBER_GROUP ; Make more.
    RTS ; Leave when all made.
CALLBACK_BOMBER_GROUP_AI_TASK: ; 0x0022F7, $F2F7
    LDA   A0DF_RAND_BYTE ; Get random val
    ANDA  #$06 ; Keep 0000.1010, slot. 0/2/4/6
    ADDA  #$07 ; += 7, slot index in callee for object to modify.
    LDX   A,U ; Xobj from UOBJ[A], ptr to bomber obj.
    LBEQ  SETUP_CALLBACK_BOMBER_AI ; If not a valid ptr to obj, reschedule.
    LDB   A0DF_RAND_BYTE ; Get random
    LDA   #$0A ; A = val
    ANDB  #$3F ; B keep 0011.1111
    ADDB  #$E0 ; += #$E0
    BMI   DONT_INVERT_A ; If result is negative, goto. Don't invert.
    NEGA ; Invert A, sub instead of add.
DONT_INVERT_A: ; 0x00230E, $F30E
    LDY   2,X ; Load GFX PTR.
    LEAY  A,Y ; Modify with A.
    CMPY  #$F929 ; If Y _ val
    BCC   Y_IN_RANGE_1 ; >=, goto.
    LDY   #$F929 ; Reset otherwise.
Y_IN_RANGE_1: ; 0x00231D, $F31D
    CMPY  #$F947 ; If Y _ val
    BLS   Y_IN_RANGE_2 ; <=, goto.
    LDY   #$F947 ; Reset otherwise.
Y_IN_RANGE_2: ; 0x002327, $F327
    STY   2,X ; Change GFX.
    SEX ; Extend B from before.
    ADDD  16,X ; Modify VSPEED.
    STD   16,X ; Store
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    TFR   A>B ; A to B
    NEGB ; Invert B
    SEX ; Extend B
    ADDD  16,X ; D += VSPEED
    STD   16,X ; D to VSPEED
    LDA   5,X ; A from SCR_YPOS
    BNE   YPOS_ZERO_ALTERNATE_PATH ; Not 0, goto.
    LDA   A0DF_RAND_BYTE ; Get rand
    CMPA  #$40 ; If _ #$40
    BHI   DONT_UPDATE_CALLBACK[16] ; >, goto.
    ANDA  #$03 ; Get 0000.0011
    ADDA  #$FE ; += #$FE
    ADDA  16,U ; A += U[16], unk use.
    CMPA  #$40 ; If A _ #$40
    BCC   SKIP_MOD_A_0x40 ; <, goto. Use A as-is.
    LDA   #$40 ; A =
SKIP_MOD_A_0x40: ; 0x002358, $F358
    CMPA  #$68 ; If A _ val
    BCS   SKIP_MOD_A_0x68 ; <, goto.
    LDA   #$68 ; A =
SKIP_MOD_A_0x68: ; 0x00235E, $F35E
    STA   16,U ; A to U[16]
DONT_UPDATE_CALLBACK[16]: ; 0x002361, $F361
    LDA   16,U ; Load U[16]
    SUBA  12,X ; -= VPOS
    ADDA  #$10 ; A +=
    CMPA  #$20 ; If A _ val
    BLS   SETUP_CALLBACK_BOMBER_AI ; <=, goto.
    SUBA  #$10 ; A -= 10
    BMI   LOAD_D_WITH_#$0010 ; If goes negative, go down with adding VSPEED.
    LDD   #$FFF0 ; VSPEED, going up on the screen.
    BRA   ADD_D_TO_VSPEED
LOAD_D_WITH_#$0010: ; 0x002375, $F375
    LDD   #$0010 ; D =
ADD_D_TO_VSPEED: ; 0x002378, $F378
    ADDD  16,X ; Modify VSPEED.
    STD   16,X ; Store modified.
    BRA   SETUP_CALLBACK_BOMBER_AI ; Setup callback if modifying VSPEED.
YPOS_ZERO_ALTERNATE_PATH: ; 0x002380, $F380
    SUBA  SHIP_SCR_POS_XXYY+1 ; A -= SHIP.Y
    BMI   SHIP_LOWER_THAN_BOMBER ; If negative (ship lower on screen), goto.
    CMPA  #$20 ; If A _ val
    BCS   BOMBER_ABOVE_SHIP_BY_0x20 ; <, goto.
    LDD   #$FFF0 ; Going up on screen.
    BRA   MODIFY_VSPEED_BY_D
BOMBER_ABOVE_SHIP_BY_0x20: ; 0x00238D, $F38D
    CMPA  #$10 ; If A _ #$10
    BHI   DONT_MOD_VSPEED ; >, ship above by more than 0x10.
    LDD   #$0010 ; Going down VSPEED, avoiding ship.
    BRA   MODIFY_VSPEED_BY_D
SHIP_LOWER_THAN_BOMBER: ; 0x002396, $F396
    CMPA  #$E0 ; If A _ val
    BGT   NEGATIVE_ABOVE_0xE0 ; >, goto.
    LDD   #$0010 ; Going up VSPEED, avoiding ship.
    BRA   MODIFY_VSPEED_BY_D
NEGATIVE_ABOVE_0xE0: ; 0x00239F, $F39F
    CMPA  #$F0 ; If A _ val
    BLT   DONT_MOD_VSPEED ; <, goto.
    LDD   #$FFF0 ; Going up?
MODIFY_VSPEED_BY_D: ; 0x0023A6, $F3A6
    ADDD  16,X ; D += VSPEED
    STD   16,X ; To VSPEED
DONT_MOD_VSPEED: ; 0x0023AC, $F3AC
    LDA   A0E0_RAND_WORD+1 ; Get rand
    ANDA  #$07 ; Get bottom bits.
    BNE   SETUP_CALLBACK_BOMBER_AI ; 1 in 8 chance of skipping sub.
    BSR   MAKE_MINE_IF_SLOTS_AVAILABLE ; Drop mine.
SETUP_CALLBACK_BOMBER_AI: ; 0x0023B4, $F3B4
    LDA   #$01 ; Setup callback.
    LDX   #$F2F7
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_BOMBER_DESTROYED?: ; 0x0023BC, $F3BC
    JSR   REMOVE_XOBJ_FROM_LISTS_A065|A06B_AND_SCORE+SOUND_FROM_4B_PAST_JSR ; Score+Sound
    .db $01 ; Points 250? Bomber?
    .db $25
    .db $D5 ; Sound
    .db $02
    DEC   R_A113_BOMBER_ALIVE_COUNT? ; Dec count
    LDU   6,X ; U from XOBJ[6]
    LEAY  7,U ; Y = U+7
NULL_X_PTR_IN_Y: ; 0x0023CA, $F3CA
    CMPX  Y++ ; CMPX Y
    BNE   NULL_X_PTR_IN_Y
    CLRA ; Clear D
    CLRB
    STD   -2,Y ; D to PTR we've deleted.
    DEC   15,U ; Dec UOBJ[15]
    BNE   RTS ; Not 0, RTS.
    LEAX  U ; X = U
    JSR   XOBJ_REMOVED_FROM_CALLBACKS ; Remove group callback.
RTS: ; 0x0023DB, $F3DB
    RTS
MAKE_MINE_IF_SLOTS_AVAILABLE: ; 0x0023DC, $F3DC
    LDA   BULLET/MINE_SPAWNED_COUNT
    CMPA  #$0A
    BCC   RTS ; Don't spawn bullet?
    JSR   SPAWNS_BULLET/MINE_WITH_6_PAST_JSR
    .db $E4 ; Handler.
    .db $98
    .db $F9 ; GFX
    .db $5B
    .db $E5 ; Hit player.
    .db $1E
    BEQ   RTS ; If nothing spawned, RTS.
    LDB   A0E0_RAND_WORD ; Otherwise, do this. Random speed?
    SEX ; Extend to D
    ASLB ; D << 1
    ROLA
    LDA   A0DF_RAND_BYTE ; Random
    ANDA  #$1F ; Keep 0001.1111
    INCA ; 0x01 to 0x20
    STA   21,X ; Store only A after making B? Mistake?
RTS: ; 0x0023FA, $F3FA
    RTS
REMOVE_X_FROM_LIST+OFFSCREEN: ; 0x0023FB, $F3FB
    JSR   REMOVE_X_FROM_LIST_ONSCREEN/OFFSCREEN
CLEAR_XOBJ_GFX_OFF_SCREEN: ; 0x0023FE, $F3FE
    PSHS  U,Y,X,B,A ; Save
    JSR   BANKSWITCH_TO_2 ; Switch to bank 2. Ensure gfx info all available.
    LDD   4,X ; D from OBJ[4], POS
    LDY   2,X ; Y from OBJ[2], GFX_DATA
    JSR   [8,Y] ; JSR to ADDR at GFX_DATA[8], Clear off screen subrtn.
    PULS  A,B,X,Y,U,PC ; RTS+Restore
UNUSED_CALLBACK?: ; 0x00240D, $F40D
    PSHS  X
    JSR   REMOVE_CALLBACK_ATTACHED_TO_XOBJ
    PULS  X
    BRA   ADD_TO_SCORE+SOUND_FROM_4_BYTES_PAST
REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST: ; 0x002416, $F416
    PSHS  X ; Save obj ptr
    JSR   REMOVE_CALLBACK_ATTACHED_TO_XOBJ ; Remove it
    PULS  X ; Restore obj ptr
REMOVE_XOBJ_FROM_LISTS_A065|A06B_AND_SCORE+SOUND_FROM_4B_PAST_JSR: ; 0x00241D, $F41D
    JSR   REMOVE_X_FROM_LIST_ONSCREEN/OFFSCREEN ; Remove from list.
ADD_TO_SCORE+SOUND_FROM_4_BYTES_PAST: ; 0x002420, $F420
    PSHS  U,B,A
    LDU   4,S ; U from S[4], aka addr that called us.
    PULU  A,B ; Pull add from first 2 bytes past JSR.
    JSR   SCORE_ADD_AB_SETTINGS ; Add val pulled. Generic rtn this is?
    BSR   CLEAR_ENEMY_MAKE_PARTICLES ; Particle effect+Cleared
    PULU  A,B ; Pull sound from 2nd bytes past JSR.
    STU   4,S ; Code position to RTS to.
    JSR   SOUND_SET_SOUND_PRIORITIED ; Set sound data from data past.
    PULS  A,B,U,PC ; RTS.
CLEAR_ENEMY_MAKE_PARTICLES: ; 0x002434, $F434
    PSHS  U,Y,X,B,A ; Save
    BSR   CLEAR_XOBJ_GFX_OFF_SCREEN ; Take off screen
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP ; Make particles?
    PULS  A,B,X,Y,U,PC
CALLBACK_PALETTE_ROTATE_13/15_INIT: ; 0x00243D, $F43D
    LDX   #$F45B ; Palette ptr
RESETUP_CALLBACK_CONTINUED: ; 0x002440, $F440
    STX   7,U ; To UOBJ[7]
    LDA   #$06 ; Setup callback
    LDX   #$F44A
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_PALETTE_ROTATE_13/15: ; 0x00244A, $F44A
    LDX   7,U ; X from UOBJ[7]
    LDD   X++ ; D from X++
    STD   COLOR_PALETTE_RAM_COPY+13
    LDA   X+
    STA   COLOR_PALETTE_RAM_COPY+15
    CMPX  #$F464 ; End ptr.
    BCS   RESETUP_CALLBACK_CONTINUED ; Store ptr as-is.
    BRA   CALLBACK_PALETTE_ROTATE_13/15_INIT ; Reset ptr
PALETTE_ROTATE_BOMBERS: ; 0x00245B, $F45B
    .db $81 ; This is a guess but it's next to the bomber stuff.
    .db $81
    .db $2F
    .db $81
    .db $2F
    .db $07
    .db $2F
    .db $81
    .db $07
CALLBACK_WHITE_AND_CLEAR_LOGO_COLOR_ROTATE: ; 0x002464, $F464
    LDA   #$FF ; White
    STA   COLOR_PALETTE_RAM_COPY+10
CALLBACK_CLEAR_PALETTE[12]_SCHEDULE_RANDOM: ; 0x002468, $F468
    CLR   COLOR_PALETTE_RAM_COPY+12 ; Clear
    LDA   #$03 ; Setup callback.
    LDX   #$F472
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_DEFENDER_LOGO_COLOR_ROTATE: ; 0x002472, $F472
    LDA   A0DF_RAND_BYTE ; Random
    ANDA  #$1F ; Range 0 to 1F
    LDX   #$E799 ; Color rotation table.
    LDA   A,X ; Get A from X+A
    STA   COLOR_PALETTE_RAM_COPY+10 ; Store to palette.
    STA   COLOR_PALETTE_RAM_COPY+12
    LDX   #$CCB0 ; Idk val
    CMPX  RANDOM_PALETTE_ROTATION_DEFENDER_LOGO ; If X _ addr
    BNE   DONT_SWAP_PTR ; !=, use ptr as-is.
    LDX   #$CCBC ; Swap val otherwise.
DONT_SWAP_PTR: ; 0x002489, $F489
    STX   RANDOM_PALETTE_ROTATION_DEFENDER_LOGO ; Store to
    LDA   #$06 ; Schedule above.
    LDX   #$F464
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_UPDATE_UI: ; 0x002493, $F493
    LDA   R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT? ; Load addr
    BNE   REMOVE_OBJ_END? ; Not 0, goto.
    LDX   #$0F1C ; P1_SCORE_LOC
    LDA   A08B_CURRENT_PLAYER
    DECA
    BEQ   CLEARING_P2_SCORE
    LDX   #$711C ; P2_SCORE_LOC
CLEARING_P2_SCORE: ; 0x0024A2, $F4A2
    LDD   #$1808 ; Clear WWHH
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear
    LDA   #$08 ; Callback
    LDX   #$F4B0
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    JSR   CURRENT_PLAYER_SCORE_TO_SCREEN ; Put score to screen.
    LDA   #$0C
    LDX   #$F493
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
REMOVE_OBJ_END?: ; 0x0024BB, $F4BB
    JMP   CALLBACK_TASK_REMOVE
SCHEDULE_BANKED_CALLBACK_IN_CURRENT: ; 0x0024BE, $F4BE
    LDU   R_A063_CALLBACK_LIST/CURRENT ; Ptr from here
    STX   13,U ; X to OBJ[13], banked callback.
    LDB   CURRENT_BANK ; Bank to OBJ[12]
    STB   12,U
    LDX   #$F4CC ; Callback for bank specifically.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_HANDLER_BANKED: ; 0x0024CC, $F4CC
    LDA   12,U ; Load bank
    BSR   BANKSWITCH_TO_A ; switch to bank
    JMP   [13,U] ; JMP to OBJ[13]
GOTO_PAST_JSR: ; 0x0024D3, $F4D3
    LEAS  -3,S ; Save 3 bytes of stack. FORMAT: [ptr,bank]
    PSHS  U,A ; STACK S 0:A 2:U 3-5:RSV 6:RTS
    LDA   CURRENT_BANK ; Get current bank.
    STA   5,S ; Save bank up stack.
    LDU   6,S ; Pull location from.
    LDA   2,U ; Pull bank going to into A.
    LDU   U ; Get ptr past JSR.
    STU   3,S ; Save on stack.
    BSR   BANKSWITCH_TO_A ; Goto bank past JSR.
    PULS  A,U ; Pull saved.
    JSR   [S] ; JSR to location past original JSR.
    PSHS  U,A ; Save new info.
    LDA   5,S ; Load bank from up stack.
    BSR   BANKSWITCH_TO_A ; Switch back to it.
    LDU   6,S ; Load location from.
    LEAU  3,U ; Add 3 to skip data.
    STU   6,S ; Store new RTS location.
    PULS  A,U ; Pull saved.
    LEAS  3,S ; Unreserve stack.
    RTS ; RTS
GOTO_B7-C000,DRAW_LAND: ; 0x0024FA, $F4FA
    BSR   BANKSWITCH_TO_7
    JMP   JMP_TO_DRAW_LAND_INITIALIZATION?
BANKSWITCH_TO_7: ; 0x0024FF, $F4FF
    LDA   #$07
    BRA   BANKSWITCH_TO_A
BANKSWITCH_TO_2: ; 0x002503, $F503
    LDA   #$02
    BRA   BANKSWITCH_TO_A
BANKSWITCH_TO_3: ; 0x002507, $F507
    LDA   #$03
    BRA   BANKSWITCH_TO_A
BANKSWITCH_TO_1: ; 0x00250B, $F50B
    LDA   #$01
BANKSWITCH_TO_A: ; 0x00250D, $F50D
    STA   CURRENT_BANK
    STA   BANKSWITCH
    RTS
GOTO_B2-C002_SENTENCE_TO_SCREEN: ; 0x002513, $F513
    PSHS  U,Y,X,DP,B,A,CC
    BSR   BANKSWITCH_TO_2
    JSR   JMP_SENTENCE_TO_SCREEN
    PULS  CC,A,B,DP,X,Y,U,PC
GOTO_B3-C00F_BOOKKEEP_UPDATE_+1: ; 0x00251C, $F51C
    BSR   BANKSWITCH_TO_3
    JMP   JMP_BOOKKEEP_UPDATE_+1
    RTS
GFX_BANK2_CHR_TO_SCREEN: ; 0x002522, $F522
    PSHS  U,Y,X,B,A ; Save state
    TFR   D>X ; TFR location to X
    LDA   CURRENT_BANK ; Get bank
    PSHS  A ; Save
    LDA   #$02 ; Switch to bank 2.
    STA   CURRENT_BANK
    STA   BANKSWITCH
    LDD   Y ; Get WWHH?
    LDY   2,Y ; LDY from Y
    PSHS  B,A ; Save from Y
    BITB  #$01 ; Test lowest bit...
    BNE   LOOP_ON_BBOUNDRY
LOOP_ON_WBOUNDRY: ; 0x00253C, $F53C
    SUBB  #$02 ; Taking 2
LOOP_NO_OFFSET: ; 0x00253E, $F53E
    LDU   B,Y ; Get data from Y+B
    STU   B,X ; Store to X+B
    SUBB  #$02
    BPL   LOOP_NO_OFFSET ; If next data exists.
    LDB   1,S ; Get A pushed to stack.
    LEAX  256,X ; Add 256 to X
    LEAY  B,Y ; Add offset from B, height?
    DECA ; Dec A normally.
    BNE   LOOP_ON_WBOUNDRY ; Loop if not done.
    BRA   POST_COL_DATA_MOVED
LOOP_ON_BBOUNDRY: ; 0x002553, $F553
    DECB ; -= consumed
    LDA   B,Y ; Get byte
    STA   B,X ; Store byte
    SUBB  #$02 ; Sub 2
    BMI   END_MOVE_COL
LOOP_ON_BBOUNDRY_WORD: ; 0x00255C, $F55C
    LDU   B,Y ; Get word
    STU   B,X ; Store word
    SUBB  #$02
    BPL   LOOP_ON_BBOUNDRY_WORD
END_MOVE_COL: ; 0x002564, $F564
    LDB   1,S ; Get A pushed onto stack.
    LEAX  256,X ; Add 256 to X
    LEAY  B,Y ; Y+=B
    DEC   S ; Decrease A on stack
    BNE   LOOP_ON_BBOUNDRY ; Loop if not written
POST_COL_DATA_MOVED: ; 0x002570, $F570
    LEAS  2,S ; Fix stack
    PULS  A ; Pull bank from.
    STA   CURRENT_BANK
    STA   BANKSWITCH ; Switch to bank.
    PULS  A,B,X,Y,U,PC ; RTS
GFX_BANK2_CHR_CLEAR: ; 0x00257B, $F57B
    PSHS  U,X,B,A ; Save
    TFR   D>X ; D is location on screen.
    LDA   CURRENT_BANK ; Get bank in.
    PSHS  A ; Save
    LDA   #$02 ; Switch to bank 2.
    STA   CURRENT_BANK ; Store val.
    STA   BANKSWITCH ; Switch
    LDD   Y ; Load with Y ptr, WWHH of obj
CLR_SCRN_SLOW_X=POS,A=W,B=H: ; 0x00258C, $F58C
    LDU   #$0000 ; Clearing value.
    PSHS  B ; Save loaded B, height
    BITB  #$01 ; Test bottom bit.
    BNE   B_BOUNDARY ; Is on byte boundary.
W_BOUNDARY: ; 0x002595, $F595
    SUBB  #$02 ; Taking 2
LOOP_CLEAR_W: ; 0x002597, $F597
    STU   B,X ; Clear X[B]
    SUBB  #$02 ; Wrote 2 rows.
    BPL   LOOP_CLEAR_W
    LDB   S ; Reset Y addition.
    LEAX  256,X ; Next col.
    DECA ; Dec A
    BNE   W_BOUNDARY ; Not done.
    BRA   EXIT_RESTORE_BANK ; Exit
B_BOUNDARY: ; 0x0025A8, $F5A8
    DECB ; One byte clearing.
    CLR   B,X ; Clear
    SUBB  #$02
    BMI   ONE_GOOD_ENOUGH ; If we under flow, one was all that was needed, since we said -2
MORE_ROWS_BYTE_WORD: ; 0x0025AF, $F5AF
    STU   B,X ; Clear 2 rows.
    SUBB  #$02 ; Did 2
    BPL   MORE_ROWS_BYTE_WORD ; Loop clear.
ONE_GOOD_ENOUGH: ; 0x0025B5, $F5B5
    LDB   S ; Reset Y addition.
    LEAX  256,X ; Next col.
    DECA ; More width?
    BNE   B_BOUNDARY ; Yes, loop this.
EXIT_RESTORE_BANK: ; 0x0025BE, $F5BE
    PULS  A,B ; Pull A=Y Off, B=Bank from. Expected.
    STB   CURRENT_BANK ; Store bank.
    STB   BANKSWITCH
    PULS  A,B,X,U,PC ; Restore state, RTS.
CLEAR_SCREEN_FLEX_SETUP: ; 0x0025C7, $F5C7
    PSHS  U,X,B,A ; Save. X=POS,A=W,B=H,U gets clobbered so save too.
    LDA   CURRENT_BANK ; RTN expects this.
    PSHS  A
    LDA   1,S ; Get A pushed onto stack originally.
    BRA   CLR_SCRN_SLOW_X=POS,A=W,B=H
CLEAR_ALL_SCREEN: ; 0x0025D1, $F5D1
    PSHS  U,Y,X,B,A
    LDU   #$9C00
    LDX   #$0000
    TFR   X>Y
    TFR   X>D
CLEAR_SCREEN_ALL_LOOP: ; 0x0025DD, $F5DD
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  X
    CMPU  #$0000 ; All cleared
    BNE   CLEAR_SCREEN_ALL_LOOP ; If not end of screen.
    PULS  A,B,X,Y,U,PC ; restore, RTS
CLEAR_GAME_SCREEN: ; 0x0025F1, $F5F1
    PSHS  U,Y,X,DP,B,A
    LDU   #$9C00
    LDX   #$0000
    TFR   X>Y
    TFR   X>D
    TFR   A>DP
CLEAR_GAME_SCREEN_COL_LOOP: ; 0x0025FF, $F5FF
    LDB   #$08 ; loop count
CLEAR_COUNT_LOOP: ; 0x002601, $F601
    PSHU  Y,X,DP,A ; 6 rows.
    PSHU  Y,X,DP,A
    PSHU  Y,X,DP,A
    PSHU  Y,X,DP,A ; 24 rows.
    DECB
    BNE   CLEAR_COUNT_LOOP ; 192 rows.
    PSHU  Y,X,DP,A ; 198
    PSHU  Y,X,DP,A
    PSHU  Y,X,DP,A ; 210
    PSHU  Y,X ; 214
    LEAU  -42,U ; 256. Adjust to miss scanner, 0x2A/42.
    CMPU  #$0000 ; Is end?
    BNE   CLEAR_GAME_SCREEN_COL_LOOP ; No, keep looping.
    PULS  A,B,DP,X,Y,U,PC
DEFENDER_BOOTUP: ; 0x00261F, $F61F
    CLR   BANKSWITCH ; Set bankswitch to 0.
    LDX   #$CC00 ; Set to PIA's.
    CLR   1,X ; Clear data ctrl registers.
    CLR   3,X
    CLR   5,X
    CLR   7,X
    LDA   #$C0 ; Set top two bits. 1=Input, 0=Output.
    STA   X ; PIA-ROM-A-DATA
    LDA   #$FF ; Set all bits to input.
    STA   2,X ; PIA-ROM-B-DATA
    CLR   4,X ; PIA-WIG-A-DATA
    CLR   6,X ; PIA-WIG-B-DATA
    LDA   #$04 ; Set data to report.
    STA   3,X ; PIA-ROM-B-CTRL
    STA   5,X ; PIA-WIG-A-CTRL
    STA   7,X ; PIA-WIG-B-CTRL
    ORA   #$10 ; Set CTRL to interrupt on 0->1 transition.
    STA   1,X ; PIA-ROM-A-CTRL
    LDX   #$C000 ; Ptr, IO space.
    LDA   #$C0 ; Seed palette gen.
INITIAL_PALETTE_LOAD: ; 0x00264A, $F64A
    STA   X+ ; Store A/D Upper to palette.
    LDB   #$B5 ; Seed B
    MUL ; Figure next palette byte.
    CMPX  #$C010 ; Compare to end.
    BNE   INITIAL_PALETTE_LOAD
    ORCC  #$80 ; Set entire flag.
    ANDCC #$EF ; Enable IRQs, unmask.
    LDY   #$0002 ; Set number of times to do pattern.
    CLRA ; Clear A.
    TFR   A>DP ; Set DP to 0.
    ANDCC #$BF ; Enable FIRQs, unmask.
    CLRB
RUG_PATTERN_SETUP: ; 0x002662, $F662
    TFR   D>U ; Save D to U
    LDX   #$0000 ; Set X to screen memory.
RUG_PATTERN_LOOP: ; 0x002667, $F667
    COMB ; Invert B
    BITB  #$09 ; Test bits.
    BNE   BITS_SET
    COMB ; Re-invert
    RORA ; rotate
    RORB
    BRA   STR_D_TO_SCR[X]
BITS_SET: ; 0x002671, $F671
    COMB ; re-invert
    BITB  #$09 ; Test bits.
    BNE   BITS_SET2
    RORA ; rotate
    RORB
    BRA   STR_D_TO_SCR[X]
BITS_SET2: ; 0x00267A, $F67A
    LSRA ; rotate in 0.
    RORB
STR_D_TO_SCR[X]: ; 0x00267C, $F67C
    STD   X++ ; Store D to screen.
    EXG   X-D ; Screen loc to D
    TSTB ; Test if column
    BNE   RUG_DISP_NOT_COL
    LDB   #$38
    STB   WATCHDOG ; Set watchdog.
    TFR   CC>B ; CC to B
    BITB  #$10 ; Test if IRQ mask
    BEQ   IRQ_NO_MASK
    CLR   BANKSWITCH ; Set to IO bank.
    LDB   PIA_ROM_DATA_A ; Get switches from coin door. 1=Active
    COMB ; Invert, active low.
    BITB  #$03 ; Test if auto/man or adv weren't set.
    BEQ   RUG_BOTH_INPUTS_ACTIVE ; Both active.
IRQ_NO_MASK: ; 0x002699, $F699
    CLRB ; Set init to proper val.
RUG_DISP_NOT_COL: ; 0x00269A, $F69A
    EXG   X-D ; Put screen location back to X.
    CMPX  #$C000 ; End of screen.
    BNE   RUG_PATTERN_LOOP ; Not done, loop.
    TFR   U>D ; D=0
    LDX   #$0000 ; Set X.
COMPARE_RUG_LOOP: ; 0x0026A6, $F6A6
    COMB
    BITB  #$09
    BNE   BITS_SET
    COMB
    RORA
    RORB
    BRA   COMPARE_RUG
BITS_SET: ; 0x0026B0, $F6B0
    COMB
    BITB  #$09
    BNE   BITS_SET2
    RORA
    RORB
    BRA   COMPARE_RUG
BITS_SET2: ; 0x0026B9, $F6B9
    LSRA
    RORB
COMPARE_RUG: ; 0x0026BB, $F6BB
    CMPD  X++ ; Test what is on screen.
    BEQ   RUG_MATCH
    EXG   D-Y ; Save value to Y.
    TFR   CC>A
    BITA  #$10 ; Test if IRQ mask.
    BEQ   RUG_MISMATCH_IRQ_NOMASK
    LDA   #$03
    STA   CURRENT_BANK
    STA   BANKSWITCH
    JMP   JMP_RUG_MISMATCH
RUG_MISMATCH_IRQ_NOMASK: ; 0x0026D2, $F6D2
    CLRA ; Start over by clearing the top byte?
    EXG   Y-D ; Put screen value back to D.
    ORCC  #$40 ; Mask FIRQ
RUG_MATCH: ; 0x0026D7, $F6D7
    EXG   X-D ; Save screen pos to X.
    TSTB ; See if at column.
    BNE   NOT_COLUMN_RUG_MATCH
    TFR   CC>B
    BITB  #$10 ; Test if IRQ mask.
    BEQ   RUG_MATCH_NOT_ADMIN_MENU ; No mask goes here.
    LDB   PIA_ROM_DATA_A ; Get coin door buttons. 1=Active
    COMB ; Active low.
    BITB  #$03 ; Test auto/man and adv switch.
    BNE   WATCHDOG+RUG_REENTER ; If neither active, reenter.
RUG_BOTH_INPUTS_ACTIVE: ; 0x0026EA, $F6EA
    LDA   #$03 ; Otherwise, leave. Bank val.
    STA   CURRENT_BANK
    STA   BANKSWITCH ; Switch
    JMP   JMP_RUG_NO_RAM_ERRORS_DETECTED ; Leave to admin menu.
RUG_MATCH_NOT_ADMIN_MENU: ; 0x0026F4, $F6F4
    TFR   CC>B
    BITB  #$40 ; Test if FIRQ mask.
    BEQ   WATCHDOG+RUG_REENTER ; Not set, reenter.
    ANDCC #$BF ; Clear FIRQ mask.
    TFR   DP>B ; DP to B...
    TFR   A>DP ; A to DP. Val?
SUB_LOOP: ; 0x002700, $F700
    SUBA  #$03 ; A-=3
    BCC   SUB_LOOP ; Loop until underflow.
    INCA ; Test if was 2
    BNE   A_NOT_FF ; Skip setting DP.
    ORB   #$02 ; A=FF, set.
    BRA   COMMIT_DP
A_NOT_FF: ; 0x00270B, $F70B
    INCA ; Test if was 1
    BNE   A_IS_FD ; No, was 0, take this.
    ORB   #$01 ; A=FE, set.
    BRA   COMMIT_DP ; Always taken.
A_IS_FD: ; 0x002712, $F712
    ORB   #$04 ; A=FD, set.
COMMIT_DP: ; 0x002714, $F714
    TFR   DP>A ; Put A back.
    TFR   B>DP ; Failure value to DP.
WATCHDOG+RUG_REENTER: ; 0x002718, $F718
    LDB   #$38 ; Reset watchdog.
    STB   WATCHDOG
    CLRB ; Set B back to value.
NOT_COLUMN_RUG_MATCH: ; 0x00271E, $F71E
    EXG   X-D ; Put screen back to X.
    CMPX  #$C000 ; Is end of screeen.
    LBNE  COMPARE_RUG_LOOP ; No, loop.
    LEAY  -1,Y ; Rug pattern finished, minus 1 loop.
    LBNE  RUG_PATTERN_SETUP ; Repeat if not 0.
    TFR   CC>B ; RUG PATTERN CONFIRMED HERE.
    TSTB ; Test CC
    BMI   RUG_POST_ENTIRE_SET(BOOTUP?) ; If bit 7 set
    LDB   #$03 ; If not bootup do this?
    STB   BANKSWITCH
    JSR   SETUP_TEXT+MENU+MISC ; Idk
    JMP   JUMP_RUG_AUDIO_TEST ; Exit
RUG_POST_ENTIRE_SET(BOOTUP?): ; 0x00273D, $F73D
    BITB  #$10 ; Test for IRQ mask.
    LBNE  RUG_PATTERN_SETUP ; IRQ masked, keep going. In menu call?
    LDA   #$9E ; Init A, eventually gets put to stack?
    TFR   DP>B ; Put marks to B
    TSTB ; Test if was failures?
    BEQ   NO_DP_MARKS ; No marks, use A as-is.
BIT_0_WAS_SET: ; 0x00274A, $F74A
    INCA ; ++, 1>+1,2=+1,3=+2
    LSRB ; Get bit off B (DP)
    BCS   BIT_0_WAS_SET ; If bit 0 was 1, repeat.
NO_DP_MARKS: ; 0x00274E, $F74E
    TFR   A>DP ; Write A to DP. 0x9E to 0xA6.
    ADDA  #$01 ; ++
    CLRB ; D=##00
    TFR   D>S ; Put S stack there.
    JSR   SETUP_TEXT+MENU+MISC ; Setup stuff.
ROM_CHECK_START: ; 0x002758, $F758
    LDU   #$F86E ; Load U stack.
BANK_TEST_CHECK_LOOP: ; 0x00275B, $F75B
    CLR   BANKSWITCH ; Set to IO
    LDA   #$38 ; Set watchdog.
    STA   WATCHDOG
    LDA   U ; Load pointed data.
    LDB   U ; Load pointed.
    BEQ   CORRECT_CHECKSUM ; If is 0, skip check.
    ANDB  #$0F ; Get bank bits.
    STB   BANKSWITCH ; Switch to bank
    ANDA  #$70 ; Get upper bits.
    LSRA ; Shift once.
    ADDA  #$C0 ; Add value to get offset.
    CLRB ; Clear bottom byte of D.
    TFR   D>X ; Addr made to X
    LDY   #$0800 ; Set Y to check size
    TFR   U>D ; Tfr location for check...
    SUBB  #$6C ; location.lower - 2
    LSRB ; Divide by 2. This is init value.
    CLRA ; Clear A
LOOP_0x800: ; 0x002780, $F780
    ADCB  X+ ; +=, w/ carry
    LEAY  -1,Y ; --
    BNE   LOOP_0x800
    CMPB  #$80 ; If B ends up being #$80...
    BEQ   CORRECT_CHECKSUM
    TFR   CC>A ; Incorrect here.
    BITA  #$10 ; Test IRQ mask
    BEQ   WRONG_CHECKSUM_NO_IRQ ; No IRQ Mask.
RTS_INTO_BANK3_FROM_CHECK: ; 0x002790, $F790
    JMP   BANKSWITCH_TO_3 ; Go back to system menu.
CORRECT_CHECKSUM: ; 0x002793, $F793
    LEAU  1,U ; Ptr += 1
    CMPU  #$F886 ; End
    BNE   BANK_TEST_CHECK_LOOP ; Not at end.
    TFR   CC>A ; Get CC. All passed here.
    BITA  #$10 ; Test IRQ
    BNE   RTS_INTO_BANK3_FROM_CHECK ; Go back into menu?
    TFR   DP>A ; Get DP
    CMPA  #$9E ; Check if DP was originally 0
    BNE   DP_ORIGINALLY_NOT_0 ; If taken, original DP!=0
    JSR   BANKSWITCH_TO_3 ; Switch to bank.
    JSR   JMP_BOOTUP_UNIT_OK ; UNIT OK.
    BRA   RUG_PASS_SRAM_CHECK ; NOTE: Goes to main loop here!
DP_ORIGINALLY_NOT_0: ; 0x0027AF, $F7AF
    LDB   #$40 ; LED 4+2
    BSR   WRITE_B_TO_ROM_DATA_PIA_REGS+BANK3 ; Turn on.
    JSR   JMP_BOOTUP_RAM_FAILURE
    BRA   RUG_PASS_SRAM_CHECK
WRITE_B_TO_ROM_DATA_PIA_REGS+BANK3: ; 0x0027B8, $F7B8
    LDX   #$CC00
    STB   X ; Write to ROM_DATA_A
    STB   2,X ; And B
    CLR   BANKSWITCH ; Change to IO bank.
DISPLAY_MESSAGE_WAIT: ; 0x0027C2, $F7C2
    LDA   #$38
    STA   WATCHDOG ; Clear watchdog...
    LEAX  -1,X
    BNE   DISPLAY_MESSAGE_WAIT
    JMP   BANKSWITCH_TO_3 ; Switch to bank 3, abuse RTS
WRONG_CHECKSUM_NO_IRQ: ; 0x0027CE, $F7CE
    LDB   #$80 ; LED 3+1
    BSR   WRITE_B_TO_ROM_DATA_PIA_REGS+BANK3 ; Turn on.
    JSR   JMP_BOOTUP_ROM_FAILURE
RUG_PASS_SRAM_CHECK: ; 0x0027D5, $F7D5
    JSR   JMP_SRAM_CHECK_UNK ; SRAM check to see if menu? Can take over the flow and not come back.
    JMP   DEFENDER_GAME_INIT,ATTRACT ; Goto game if we got back.
STORE_B[X]_BANK0: ; 0x0027DB, $F7DB
    PSHS  A,CC ; Save A,CC
    LDA   CURRENT_BANK ; Load bank
    PSHS  A ; Push to the stack to save.
    CLR   CURRENT_BANK ; Set to bank 0
    CLR   BANKSWITCH
    STB   X ; Store B to X
RESTORE_BANK+A+CC_@S: ; 0x0027E8, $F7E8
    PULS  A
    STA   CURRENT_BANK
    STA   BANKSWITCH
    PULS  CC,A,PC ; Restore regs. RTS
LOAD_B[X]_BANK0: ; 0x0027F1, $F7F1
    PSHS  A,CC ; Save A,CC. NOTE: Does not modify X pos in rtn.
    LDA   CURRENT_BANK ; Loaded because restores.
    PSHS  A ; Push current bank to save.
    CLR   CURRENT_BANK ; Set to bank 0.
    CLR   BANKSWITCH
    LDB   X ; Load B
    BRA   RESTORE_BANK+A+CC_@S ; Restore last bank
SETUP_TEXT+MENU+MISC: ; 0x002800, $F800
    PSHS  B,A ; Save B,A
    CLR   SENTENCE_PTR_WORD_ON ; Clear
    CLR   UNK_$49_SYS_MENU_FLAG? ; Clear, not in menu?
    LDA   #$03
    STA   CURRENT_BANK ; Bank info without switching?
    STA   UNK_$48_AUTO+ADV ; Set
    LDD   #$FFFF
    STD   TEXT_PTR_UNK ; Set
    PULS  A,B,PC ; Get reg, RTS.
GET_DATA_FROM_SRAM(IN_A): ; 0x002813, $F813
    LDA   1,X ; Get val at X+1
    ANDA  #$0F ; Bottom bits.
    PSHS  A ; Save
    LDA   X++ ; Get val, X+=2
    ASLA ; Lower bits higher.
    ASLA
    ASLA
    ASLA
    ADDA  S+ ; Get bottom bits, fix stack too.
    RTS ; RTS
GET_DATA_FROM_SRAM[X]_IN_A: ; 0x002822, $F822
    PSHS  B ; Save B.
    LDB   CURRENT_BANK ; Get bank.
    PSHS  B ; Save
    CLR   CURRENT_BANK ; Bank 0.
    CLR   BANKSWITCH ; Bank 0.
    BSR   GET_DATA_FROM_SRAM(IN_A) ; Get data. X+=2
    PULS  B
    STB   CURRENT_BANK ; Restore bank from stack.
    STB   BANKSWITCH
    PULS  B,PC ; Rest+ret, data in A.
GET_DATA_FROM_SRAM[X]_IN_AB: ; 0x002838, $F838
    BSR   GET_DATA_FROM_SRAM[X]_IN_A
GET_DATA_FROM_SRAM[X]_IN_B: ; 0x00283A, $F83A
    PSHS  A ; INFO: X+=2
    BSR   GET_DATA_FROM_SRAM[X]_IN_A
    TFR   A>B
    PULS  A,PC
STORE_A_TO_SRAM[X]: ; 0x002842, $F842
    PSHS  A ; Store low bits.
    STA   1,X ; above
    LSRA ; Shift high bits low
    LSRA
    LSRA
    LSRA
    STA   X++ ; Store at X
    PULS  A,PC ; Return
STORE_A_TO_SRAM[X]_BANKED: ; 0x00284E, $F84E
    PSHS  B ; Save B
    LDB   CURRENT_BANK ; Get bank
    PSHS  B ; Save bank
    CLR   CURRENT_BANK
    CLR   BANKSWITCH ; Set to IO bank.
    BSR   STORE_A_TO_SRAM[X] ; Write
    PULS  B ; Restore bank.
    STB   CURRENT_BANK
    STB   BANKSWITCH
    PULS  B,PC ; RTS
STORE_D_TO_SRAM[X]: ; 0x002864, $F864
    BSR   STORE_A_TO_SRAM[X]_BANKED ; Store A
STORE_B_TO_SRAM[X]: ; 0x002866, $F866
    PSHS  A ; Save A
    TFR   B>A ; Put B to SRAM.
    BSR   STORE_A_TO_SRAM[X]_BANKED ; Store.
    PULS  A,PC ; RTS.
BANK_CHECK_DATA: ; 0x00286E, $F86E
    .db $20 ; BANK CHECK ARRAY, FMT[-AAABBBB, A=Addr*0x200+0xC000,B=BANK]
    .db $00
    .db $40
    .db $50
    .db $60
    .db $70
    .db $30
    .db $00
    .db $00
    .db $00
    .db $07
    .db $00
    .db $03
    .db $00
    .db $02
    .db $00
    .db $01
    .db $00
    .db $13
    .db $00
    .db $12
    .db $00
    .db $11
    .db $00 ; END OF DATA
CONTROL_PANEL_BUTTON_PRESS_DATA: ; 0x002886, $F886
    .db $E5 ; FIRE BUTTON STUFF. FMT:[CALLBACK_PTR,TIMER,STATE_INVALID]
    .db $91
    .db $00
    .db $E8
    .db $00 ; THRUST STUFF
    .db $00
    .db $00
    .db $00
    .db $E8 ; SMARTBOMB STUFF
    .db $C1
    .db $00
    .db $F8
    .db $E9 ; HYPERSPACE STUFF
    .db $1F
    .db $00
    .db $F8
    .db $D8 ; 2P START STUFF
    .db $4E
    .db $00
    .db $00
    .db $D8 ; 1P START STUFF
    .db $39
    .db $00
    .db $00
    .db $E8 ; REVERSE STUFF
    .db $97
    .db $00
    .db $E8
COINDOOR_BUTTON_PRESS_DATA: ; 0x0028A2, $F8A2
    .db $00 ; FMT: Same as above.
    .db $00
    .db $00
    .db $00
    .db $00 ; Button IDK
    .db $00
    .db $00
    .db $00
    .db $D4 ; Button IDK
    .db $4C
    .db $00
    .db $00
    .db $D4 ; Button IDK
    .db $75
    .db $02
    .db $00
    .db $D4 ; Button IDK
    .db $3D
    .db $00
    .db $00
    .db $D4 ; Button IDK
    .db $6E
    .db $02
    .db $00
    .db $D4 ; Button IDK
    .db $7C
    .db $02
    .db $00
GAMEPLAY_PALETTE: ; 0x0028BE, $F8BE
    .db $00 ; 0x10 bytes
    .db $00
    .db $07
    .db $28
    .db $2F
    .db $81
    .db $A4
    .db $15
    .db $C7
    .db $FF
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
BMP_IDK: ; 0x0028CE, $F8CE
    .db $05 ; Bitmaps start here. WIDTH_BYTES, 2x for pixels.
    .db $08 ; HEIGHT
    .db $F9 ; PTR to BMP_EVEN
    .db $FB
    .db $FA ; PTR to BMP_ODD
    .db $23
    .db $D1 ; PTR to PUT_ON_SCREEN RTN
    .db $93
    .db $D1 ; PTR to CLEAR_FROM_SCREEN RTN
    .db $1F
BMP_IDK: ; 0x0028D8, $F8D8
    .db $04
    .db $08
    .db $FA
    .db $4B
    .db $FA
    .db $4B
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_IDK: ; 0x0028E2, $F8E2
    .db $04
    .db $08
    .db $FA
    .db $6B
    .db $FA
    .db $6B
    .db $D1
    .db $39
    .db $D1
    .db $6B
DATA_SPAWN_IN_IDK: ; 0x0028EC, $F8EC
    .db $01
    .db $01
    .db $F8 ; PTR to Spawn In
    .db $F6
    .db $F8
    .db $F6
    .db $D8 ; PTR to RTS
    .db $DB
    .db $D8
    .db $DB
    .db $00
BMP_IDK: ; 0x0028F7, $F8F7
    .db $04
    .db $08
    .db $FA
    .db $8B
    .db $FA
    .db $AB
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_HUMANOID_1: ; 0x002901, $F901
    .db $02
    .db $08
    .db $FA
    .db $CB
    .db $FA
    .db $DB
    .db $D0
    .db $F9
    .db $D1
    .db $0B
BMP_IDK: ; 0x00290B, $F90B
    .db $02
    .db $08
    .db $FA
    .db $EB
    .db $FA
    .db $FB
    .db $D0
    .db $F9
    .db $D1
    .db $0B
BMP_HUMANOID_OFFSET?: ; 0x002915, $F915
    .db $02
    .db $08
    .db $FB
    .db $0B
    .db $FB
    .db $1B
    .db $D0
    .db $F9
    .db $D1
    .db $0B
BMP_HUMANOID_UNK: ; 0x00291F, $F91F
    .db $02
    .db $08
    .db $FB
    .db $2B
    .db $FB
    .db $3B
    .db $D0
    .db $F9
    .db $D1
    .db $0B
BMP_IDK: ; 0x002929, $F929
    .db $04
    .db $08
    .db $FB
    .db $4B
    .db $FB
    .db $6B
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_IDK: ; 0x002933, $F933
    .db $04
    .db $08
    .db $FB
    .db $8B
    .db $FB
    .db $AB
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_IDK: ; 0x00293D, $F93D
    .db $04
    .db $08
    .db $FB
    .db $CB
    .db $FB
    .db $EB
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_IDK: ; 0x002947, $F947
    .db $04
    .db $08
    .db $FC
    .db $0B
    .db $FC
    .db $2B
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_IDK: ; 0x002951, $F951
    .db $04
    .db $08
    .db $CC
    .db $90
    .db $CC
    .db $90
    .db $D1
    .db $39
    .db $D1
    .db $6B
BMP_IDK: ; 0x00295B, $F95B
    .db $02
    .db $03
    .db $CC
    .db $B0
    .db $CC
    .db $B6
    .db $D1
    .db $F1
    .db $D2
    .db $0D
BMP_IDK: ; 0x002965, $F965
    .db $02
    .db $03
    .db $CC
    .db $BC
    .db $CC
    .db $C2
    .db $D1
    .db $F1
    .db $D2
    .db $0D
SELF_CONTAINED_THING?: ; 0x00296F, $F96F
    .db $08
    .db $01
    .db $F9
    .db $73
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
BMP_IDK: ; 0x00297B, $F97B
    .db $03
    .db $04
    .db $CC
    .db $C8
    .db $CC
    .db $D4
    .db $D1
    .db $AD
    .db $D1
    .db $D7
BMP_LANDER?: ; 0x002985, $F985
    .db $05
    .db $08
    .db $CC
    .db $E0
    .db $CD
    .db $08
    .db $D1
    .db $93
    .db $D1
    .db $1F
BMP_IDK: ; 0x00298F, $F98F
    .db $05
    .db $08
    .db $CD
    .db $30
    .db $CD
    .db $58
    .db $D1
    .db $93
    .db $D1
    .db $1F
BMP_IDK: ; 0x002999, $F999
    .db $05
    .db $08
    .db $CD
    .db $80
    .db $CD
    .db $A8
    .db $D1
    .db $93
    .db $D1
    .db $1F
BMP_IDK: ; 0x0029A3, $F9A3
    .db $06
    .db $04
    .db $CD
    .db $D0
    .db $CD
    .db $E8
    .db $D2
    .db $1F
    .db $D2
    .db $60
BMP_IDK: ; 0x0029AD, $F9AD
    .db $06
    .db $04
    .db $CE
    .db $00
    .db $CE
    .db $18
    .db $D2
    .db $1F
    .db $D2
    .db $60
BMP_IDK: ; 0x0029B7, $F9B7
    .db $06
    .db $04
    .db $CE
    .db $30
    .db $CE
    .db $48
    .db $D2
    .db $1F
    .db $D2
    .db $60
BITMAP_SHIP_FACING_RIGHT?: ; 0x0029C1, $F9C1
    .db $08
    .db $06
    .db $CE
    .db $60
    .db $CE
    .db $90
    .db $D2
    .db $8E
    .db $D2
    .db $DF
BITMAP_SHIP_FLYING_LEFT?: ; 0x0029CB, $F9CB
    .db $08
    .db $06
    .db $CE
    .db $C0
    .db $CE
    .db $F0
    .db $D2
    .db $8E
    .db $D2
    .db $DF
BMP_SHIP: ; 0x0029D5, $F9D5
    .db $05 ; Player ship.
    .db $04
    .db $CF
    .db $20
BMP_SMARTBOMB: ; 0x0029D9, $F9D9
    .db $03 ; Smartbomb graphic here.
    .db $03
    .db $CF
    .db $34
BMP_IDK: ; 0x0029DD, $F9DD
    .db $06
    .db $06
    .db $CF
    .db $3D
    .db $CF
    .db $61
    .db $D3
    .db $3D
    .db $D3
    .db $50
BITMAP_IDK: ; 0x0029E7, $F9E7
    .db $06
    .db $06
    .db $CF
    .db $85
    .db $CF
    .db $A9
    .db $D3
    .db $3D
    .db $D3
    .db $50
BMP_IDK: ; 0x0029F1, $F9F1
    .db $08
    .db $06
    .db $CF
    .db $CD
    .db $CF
    .db $CD
    .db $F5
    .db $22
    .db $F5
    .db $7B
GFX_BMP_SET_START: ; 0x0029FB, $F9FB
    .db $00 ; BMP data here. Not all but a few.
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $0C
    .db $3C
    .db $0C
    .db $08
    .db $38
    .db $30
    .db $00
    .db $00
    .db $C0
    .db $C0
    .db $C8
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $00
    .db $30
    .db $03
    .db $03
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $03
    .db $30
    .db $30
    .db $03
    .db $03
    .db $30
    .db $00
    .db $CC
    .db $CC
    .db $CC
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $00
    .db $03
    .db $80
    .db $80
    .db $83
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $00
    .db $0D
    .db $6C
    .db $6C
    .db $0D
    .db $00
    .db $00
    .db $06
    .db $E6
    .db $C8
    .db $83
    .db $82
    .db $C8
    .db $EC
    .db $06
    .db $60
    .db $6D
    .db $8C
    .db $28
    .db $28
    .db $8C
    .db $6D
    .db $60
    .db $00
    .db $00
    .db $E0
    .db $C6
    .db $C6
    .db $E0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $02
    .db $22
    .db $24
    .db $02
    .db $00
    .db $00
    .db $02
    .db $22
    .db $44
    .db $44
    .db $24
    .db $42
    .db $22
    .db $00
    .db $20
    .db $22
    .db $44
    .db $44
    .db $24
    .db $42
    .db $22
    .db $00
    .db $00
    .db $00
    .db $20
    .db $22
    .db $22
    .db $20
    .db $00
    .db $00
    .db $00
    .db $0E
    .db $00
    .db $D8
    .db $00
    .db $0E
    .db $00
    .db $00
    .db $0F
    .db $08
    .db $8C
    .db $C8
    .db $8C
    .db $08
    .db $0F
    .db $00
    .db $00
    .db $0E
    .db $80
    .db $C8
    .db $80
    .db $0E
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $E0
    .db $08
    .db $8C
    .db $08
    .db $E0
    .db $00
    .db $00
    .db $F0
    .db $80
    .db $C8
    .db $8C
    .db $C8
    .db $80
    .db $F0
    .db $00
    .db $00
    .db $E0
    .db $00
    .db $8D
    .db $00
    .db $E0
    .db $00
    .db $00
    .db $33
    .db $43
    .db $43
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $03
    .db $04
    .db $04
    .db $08
    .db $08
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $38
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $33
    .db $43
    .db $43
    .db $87
    .db $87
    .db $77
    .db $77
    .db $77
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $03
    .db $04
    .db $04
    .db $08
    .db $08
    .db $07
    .db $07
    .db $07
    .db $30
    .db $30
    .db $38
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $03
    .db $03
    .db $83
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $30
    .db $40
    .db $40
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $08
    .db $08
    .db $08
    .db $00
    .db $00
    .db $00
    .db $33
    .db $34
    .db $34
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $03
    .db $03
    .db $83
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $30
    .db $40
    .db $40
    .db $80
    .db $80
    .db $70
    .db $70
    .db $70
    .db $00
    .db $00
    .db $08
    .db $08
    .db $08
    .db $00
    .db $00
    .db $00
    .db $33
    .db $34
    .db $34
    .db $78
    .db $78
    .db $77
    .db $77
    .db $77
    .db $08
    .db $08
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $88
    .db $88
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $00
    .db $88
    .db $88
    .db $D8
    .db $D8
    .db $D8
    .db $D0
    .db $D0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $88
    .db $88
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $00
    .db $88
    .db $88
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $08
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $00
    .db $88
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $88
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $D0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $00
    .db $88
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $88
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $88
    .db $00
    .db $00
    .db $D0
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $88
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $88
    .db $00
    .db $00
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $88
    .db $00
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP: ; 0x002C60, $FC60
    JMP   XOBJ_SPAWNING_IN_PARTICLE_SETUP
JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP: ; 0x002C63, $FC63
    JMP   XOBJ_BLOWN_UP_PARTICLE_SETUP
JMP_TO_PARTICLE_FORWARD: ; 0x002C66, $FC66
    JMP   PARTICLE_FORWARD?
XOBJ_SPAWNING_IN_PARTICLE_SETUP: ; 0x002C69, $FC69
    PSHS  U,Y,B,A ; Save
    LDD   2,X ; Load OBJ[2], handler.
    PSHS  B,A ; Save to stack.
    LDD   DATA_W_#$F8EC_PARTICLE_HANDLER ; Get data from ROM
    STD   2,X ; Store to handler.
    STX   LIST_IN_WORLD ; Store obj to list.
    LDD   10,X ; Load OBJ[10]
    SUBD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Sub with change.
    CMPD  #$2600 ; $2600 >> 5 = 304, screen width.
    BHI   ALL_PARTICLES_TAKEN_UP ; D >= val, goto. Off screen?
    LDY   PARTICLE_SLOT_POINTER ; Load Y from
    BEQ   SET_Y ; If 0, goto. Set up Y.
TO_NEXT_PARTICLE_SLOT: ; 0x002C85, $FC85
    LEAY  64,Y ; Y+=64
    CMPY  #$A000 ; If Y _ #$A000
    BNE   DONT_RESET_PARTICLE_SEARCH ; !=, goto
SET_Y: ; 0x002C8E, $FC8E
    LDY   #$9C00 ; Beginning particle ptr.
DONT_RESET_PARTICLE_SEARCH: ; 0x002C92, $FC92
    CMPY  PARTICLE_SLOT_POINTER ; Compare to original.
    BNE   PARTICLE_SLOT_AVAILABLE? ; !=, goto. If we roll to the same slot initial, fall out.
ALL_PARTICLES_TAKEN_UP: ; 0x002C97, $FC97
    PULS  A,B ; Get old handler.
    STD   2,X ; Restore
    BRA   RTS ; RTS
PARTICLE_SLOT_AVAILABLE?: ; 0x002C9D, $FC9D
    LDA   Y ; Load A from Y
    BMI   TO_NEXT_PARTICLE_SLOT ; If negative, taken.
    BEQ   DONT_CLEAR_SLOT ; If 0, dont clear.
    JSR   CLEAR_PARTICLE_SLOT_PASSED ; Clear slot.
DONT_CLEAR_SLOT: ; 0x002CA6, $FCA6
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$80 ; Test in game?
    BNE   QUEUE_PARTICLES_SPAWN_IN_NO_SOUND ; If set, goto.
    LDD   DATA_W_#$D4EE ; Load val
    JSR   JMP_SET_SOUND_PRIORITIED ; Sets sound for spawning?
QUEUE_PARTICLES_SPAWN_IN_NO_SOUND: ; 0x002CB2, $FCB2
    LDA   20,X ; Load OBJ[20]
    ORA   #$02 ; Set bit
    STA   20,X ; Store back. Set to not move off screen for slowdown comp.
    LDD   #$AF00 ; Load D, timer.
    STD   Y ; Store to PARTICLE[0]
    PULS  A,B ; Pull bitmap.
    STD   2,Y ; Bitmap to PARTICLE[2]
    LEAU  64,Y ; U = Y+64
    STU   4,Y ; Store to PARTICLE[4]
    STX   10,Y ; Store OBJ PTR to PRTCL[10] to update/get info from.
RTS: ; 0x002CCA, $FCCA
    PULS  A,B,Y,U,PC ; RTS+Restore
XOBJ_BLOWN_UP_PARTICLE_SETUP: ; 0x002CCC, $FCCC
    PSHS  U,Y,B,A ; Save
    LDD   10,X ; Load HWORLD
    SUBD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; Sub
    CMPA  #$26 ; See if on screen, <304, 0 to 303.
    BHI   RTS+RESTORE ; >, goto. Offscreen.
    STD   R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; D to, HSCREEN
    LDY   PARTICLE_SLOT_POINTER ; Y from
    BEQ   FIRST_PARTICLE_SLOT ; If 0, goto.
NEXT_PARTICLE_SLOT: ; 0x002CDD, $FCDD
    LEAY  64,Y ; += 64
    CMPY  #$A000 ; Cmp to 
    BNE   RANGED_SLOT ; !=, goto.
FIRST_PARTICLE_SLOT: ; 0x002CE6, $FCE6
    LDY   #$9C00 ; Cap val
RANGED_SLOT: ; 0x002CEA, $FCEA
    CMPY  PARTICLE_SLOT_POINTER ; Cmp Y to
    BEQ   RTS+RESTORE ; ==, goto. All slots done?
    LDA   Y ; Get PARTICLE[0]
    BMI   NEXT_PARTICLE_SLOT ; If minus, next slot, not valid.
    BEQ   SKIP_SUB ; If zero, already cleared.
    JSR   CLEAR_PARTICLE_SLOT_PASSED ; Clear slot.
SKIP_SUB: ; 0x002CF8, $FCF8
    STY   PARTICLE_SLOT_POINTER ; Store Y
    LDD   #$0100 ; D val
    STD   Y ; Store to PARTICLE[0]
    LDD   2,X ; D from XOBJ[2], GFX_PTR?
    STD   2,Y ; Store to PARTICLE[2].
    LEAU  64,Y ; U = Y+64
    STU   4,Y ; To PARTICLE[4], PARTICLE.next here?
    LDD   R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; D from, HSCREEN_FOCUS
    ASLB ; D << 2, *4
    ROLA
    ASLB
    ROLA ; A is now the HSCREEN_FOCUS?
    LDB   12,X ; B from VWORLD
    STD   8,Y ; D to PARTICLE[8]
    SUBD  R_A0F8_PARTICLE_CENTRAL_POINT ; D -= val
    LDU   2,Y ; U = GFX PTR
    ADDA  U ; Add A with GFX_WIDTH
    BCC   NO_OVERFLOW ; >= prev (unsigned), goto.
    ADDB  1,U ; Add B with GFX_HEIGHT
    BCC   NO_OVERFLOW ; >= prev, goto.
    LDD   R_A0F8_PARTICLE_CENTRAL_POINT ; Get particle pos in D?
    BRA   D_TO_PARTICLE[6] ; Always goto.
NO_OVERFLOW: ; 0x002D23, $FD23
    LDD   U ; D from @U, GFX_WIDTH,GFX_HEIGHT
    LSRA ; A >> 1, /2
    LSRB ; B >> 1, /2
    ADDD  8,Y ; Find H+V middle?
D_TO_PARTICLE[6]: ; 0x002D29, $FD29
    STD   6,Y ; Store calc'd or init to PARTICLE[6], focus calc'd?
RTS+RESTORE: ; 0x002D2B, $FD2B
    PULS  A,B,Y,U,PC ; RTS
PARTICLE_FORWARD?: ; 0x002D2D, $FD2D
    LDY   #$9C00 ; Y with val
PROCESS_PARTICLE_LOOP: ; 0x002D31, $FD31
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$04 ; Test state idk, alive?
    BEQ   CHECK_EACH_PARTICLE ; Do all if this is set.
    LDA   Y ; A from PARTICLE[0]
    BMI   PARTICLE_TIMER_NEGATIVE ; If negative, goto.
    LDD   #$0000 ; D=0
    STD   Y ; Store to PARTICLE[0]
    JMP   NEXT_PARTICLE_SLOT ; To next.
CHECK_EACH_PARTICLE: ; 0x002D43, $FD43
    LDD   Y ; D from Y
    LBEQ  NEXT_PARTICLE_SLOT ; If 0, goto.
    BMI   PARTICLE_TIMER_IS_NEGATIVE ; If negative, goto.
    ADDD  #$00AA ; D +=, advancing timer.
    STD   Y ; Store timer back.
    CMPA  #$30 ; Timeout for destroy.
    BLS   DONT_DESTROY_PARTICLE ; <=, goto.
    JSR   CLEAR_PARTICLE_SLOT_PASSED ; Clear particle.
    LDD   #$0000 ; D=0
    STD   Y ; Clear PARTICLE[0], really destroyed.
    BRA   NEXT_PARTICLE_SLOT
DONT_DESTROY_PARTICLE: ; 0x002D5E, $FD5E
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; D from
    ANDB  #$C0 ; Get bits 1100.0000
    PSHS  B,A ; Save val
    LDD   R_A022_SCREEN_POS_HORIZ_2_TRGT? ; D from
    ANDB  #$C0 ; Get bits 1100.0000
    SUBD  S++ ; Sub D with pushed.
    ASLB ; D << 2, *4
    ROLA
    ASLB
    ROLA
    PSHS  A ; Save X pos.
    LDA   6,Y ; A from PARTICLE[6]
    ADDA  S ; Add with X*4
    STA   6,Y ; Store to PARTICLE[6]
    LDA   8,Y ; A from PARTICLE[8]
    ADDA  S+ ; Add with multiplied upper.
    STA   8,Y ; Store to PARTICLE[8]
    BRA   CLEAR_PARTICLE+UNK ; Goto
PARTICLE_TIMER_IS_NEGATIVE: ; 0x002D7E, $FD7E
    SUBD  #$0100 ; D -= val
    STD   Y ; D to PARTICLE[0]
    BPL   PARTICLE_TIMER_NEGATIVE ; Now positive, goto.
    LDX   10,Y ; PARTICLE[10] is the object attached to this particulation.
    LDD   10,X ; D from XOBJ[10], OBJ pos?
    SUBD  R_A020_SCREEN_POS_HORIZ_1_CURR? ; D -= val
    ADDA  #$0C ; A += #$0C
    BITA  #$C0 ; Test 1100.0000
    BEQ   A:7-A:6_NOT_SET ; If not set, goto.
PARTICLE_TIMER_NEGATIVE: ; 0x002D91, $FD91
    LDD   #$0000 ; D = 0
    STD   Y ; D to PARTICLE[0], timer.
    LDD   2,Y ; D from PARTICLE[2], BMP replaced.
    LDX   10,Y ; X from PARTICLE[10], OBJ ptr
    STD   2,X ; D to XOBJ[2], BMP restore.
    LDA   20,X ; A from XOBJ[20], OBJ attrs
    ANDA  #$FD ; Save 1111.1101, clearing unmovable bit.
    STA   20,X ; Store back
    JSR   CLEAR_PARTICLE_SLOT_PASSED ; Clear particle.
    BRA   NEXT_PARTICLE_SLOT
A:7-A:6_NOT_SET: ; 0x002DA9, $FDA9
    SUBA  #$0C ; A -= #$0C
    ASLB ; D << 2, /2
    ROLA
    ASLB
    ROLA
    LDB   12,X ; B from XOBJ[12]
    STD   8,Y ; D to PARTICLE[8]
    LDB   #$DA ; Mul seed.
    MUL ; A*B
    ASLA ; << 1, *2
    LDU   2,Y ; U from PARTICLE[2]
    LDB   U ; B from PTR
    MUL ; A*B
    LDB   1,U ; B from UOBJ[1]
    LSRB ; >> 1
    ADDD  8,Y ; D += PARTICLE[8]
    STD   6,Y ; D to PARTICLE[6]
CLEAR_PARTICLE+UNK: ; 0x002DC3, $FDC3
    JSR   CLEAR_PARTICLE_SLOT_PASSED ; Clear particle.
    JSR   PARTICLE_PUT_DOWN/REDO_CALCS ; Put new particle down?
NEXT_PARTICLE_SLOT: ; 0x002DC9, $FDC9
    LEAY  64,Y ; Y += 64
    CMPY  #$A000 ; CMP
    LBNE  PROCESS_PARTICLE_LOOP ; !=, goto.
    RTS ; RTS
CLEAR_PARTICLE_SLOT_PASSED: ; 0x002DD5, $FDD5
    PSHS  X,B,A ; Save
    LDD   #$0000 ; D = 0
    LEAX  64,Y ; X = Y + 64
    STX   R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; Calc'd to here.
    LDX   4,Y ; PARTICLE[4], PARTICLE.next from making?
    CMPX  R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; If _ as calc'd when created.
    BEQ   NO_PARTICLES_DOWN ; ==, goto.
LOOP_CLEAR_ALL_PARTICLE_PTRS: ; 0x002DE5, $FDE5
    STD   [X++] ; Clear *X
    CMPX  R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; Cmp to final addr.
    BNE   LOOP_CLEAR_ALL_PARTICLE_PTRS
    STX   4,Y ; X final to Y[4], should be end of particle.
NO_PARTICLES_DOWN: ; 0x002DED, $FDED
    PULS  A,B,X,PC
PARTICLE_PUT_DOWN/REDO_CALCS: ; 0x002DEF, $FDEF
    PSHS  U,Y,X,B,A ; Save
    STY   R_A0F6_PARTICLE_PTR_STORE? ; Y to addr, particle usually in Y.
    LDA   Y ; A from Y, counter.
    ANDA  #$7F ; Mask 0111.111
    STA   R_A0E7_PARTICLE_SETTING?MULTIPLIER? ; Store to
    LEAU  64,Y ; U = Y + 64, next particle/end start?
    CLR   R_A0E6_PARTICLE_EXP_DIR?UNK? ; Clear addr
    LDX   2,Y ; X from PARTICLE[2], GFX PTR
    LDD   2,X ; D from XOBJ[2], GFX_BMP_PTR_EVEN
    STD   R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; Store BMP_PTR here.
    LDD   X ; D from GFX[0], [W,H]
    STA   R_A0F1_PARTICLE_WIDTH_TODO ; A to.
    STB   R_A0F2_PARTICLE_HEIGHT_TODO ; B to. Idk why not STD above. Mistake?
    BITB  #$01 ; Test bit, for odd height.
    BNE   LOAD_ODD_HEIGHT_PTR ; If set, aka odd, goto.
    LDX   #$FF27 ; Ptr to even height code.
    BRA   SKIP_OTHER_PTR_LOAD ; Goto
LOAD_ODD_HEIGHT_PTR: ; 0x002E14, $FE14
    LDX   #$FEF3 ; Ptr to even height code.
SKIP_OTHER_PTR_LOAD: ; 0x002E17, $FE17
    STX   R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL ; Code ptr store.
    LDD   6,Y ; D from PARTICLE[6], get focus.
    SUBD  8,Y ; D -= PARTICLE[8], Sub OG ref?
    STA   R_A0E4_PARTICLE_WIDTH_CALC ; A to, width? MISTAKE: LSRB here, STD to output.
    LSRB ; B >> 1, /2
    STB   R_A0E5_PARTICLE_HEIGHT_GROUPS?/2? ; B to. Height divided by 2.
    ROL   R_A0E6_PARTICLE_EXP_DIR?UNK? ; << 1 addr
    LDA   R_A0E7_PARTICLE_SETTING?MULTIPLIER? ; A from setting?
    LDB   R_A0E4_PARTICLE_WIDTH_CALC ; B width
    MUL ; Multiply setting with width
    STD   R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; D to
    LDB   6,Y ; B from PARTICLE[6], HFOCUS_FINAL
    CLRA ; Clear A. Important because tests ranging for on-screen test.
    SUBD  R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; D -= move amount from setting calc'd.
    STD   R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; Store it.
LOOP_A_TEST: ; 0x002E32, $FE32
    TSTA ; Test A. If on screen, will be 00, a OOB would be 1/FF
    BEQ   PARTICLE_HPASS ; == 0, goto. Particle IS on screen, possibly.
    LDD   R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; D from, GFX PTR.
    ADDB  R_A0F2_PARTICLE_HEIGHT_TODO ; B += addr
    ADCA  #$00 ; Carry to upper.
    STD   R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; Store back.
    DEC   R_A0F1_PARTICLE_WIDTH_TODO ; Dec addr
    LBEQ  LEAVE_PARTICLE_RTN ; If 0, goto.
    LDD   R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; D from
    ADDB  R_A0E7_PARTICLE_SETTING?MULTIPLIER? ; B += addr
    ADCA  #$00 ; Carry to upper.
    STD   R_A0E9_PARTICLE_FOCUS/MULTIUSE? ; D to.
    BRA   LOOP_A_TEST ; Loop until A is 0.
PARTICLE_HPASS: ; 0x002E4D, $FE4D
    CMPB  #$98 ; If B _ #$98
    LBHI  LEAVE_PARTICLE_RTN ; >, goto. MISTAKE? Should be LBGE? Or 97? TODO
    LDA   R_A0E7_PARTICLE_SETTING?MULTIPLIER? ; Load
    ASLA ; << 1, *2
    STA   R_A0E8_PARTICLE_SETTINGS_DOUBLED ; To. Horizontal modifier is 2x as much.
    LDB   R_A0E5_PARTICLE_HEIGHT_GROUPS?/2? ; Load doing?
    MUL ; A * B
    STD   R_A0EB_PARTICLE_VMOD ; D to, group * multiplier, VMOD
    LDB   7,Y ; B from YOBJ[7], VFOCUS_MIDDLE
    CLRA ; Clear A
    SUBD  R_A0EB_PARTICLE_VMOD ; -= VMOD
    SUBB  R_A0E6_PARTICLE_EXP_DIR?UNK? ; B -= addr
    ADCA  #$00 ; Add 1 to A if sub borrowed to bit 7.
    CLR   R_A0F5_PARTICLE_ADDED_TO_BMP_PTR? ; Clear idk
LOOP_TEST_A: ; 0x002E68, $FE68
    TSTA ; Test A
    BNE   PARTICLE_VFAIL ; != 0, goto.
    CMPB  #$2A ; B _ #$2A
    BCC   PARTICLE_VALID_SCREEN_RANGE ; B >= #$2A, goto.
PARTICLE_VFAIL: ; 0x002E6F, $FE6F
    INC   R_A0F5_PARTICLE_ADDED_TO_BMP_PTR? ; Addr += 1
    DEC   R_A0F2_PARTICLE_HEIGHT_TODO ; We do 2 height, so -=2
    DEC   R_A0F2_PARTICLE_HEIGHT_TODO
    LBLE  LEAVE_PARTICLE_RTN ; If (signed) val < 0, goto.
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    ADCA  #$00 ; Carry into high byte.
    BRA   LOOP_TEST_A ; Goto
PARTICLE_VALID_SCREEN_RANGE: ; 0x002E7F, $FE7F
    STD   R_A0EB_PARTICLE_VMOD ; D to
    LDA   R_A0F2_PARTICLE_HEIGHT_TODO ; A from
    ANDA  #$FE ; A = Math.floor(A)
    LDX   #$FF48 ; Ptr table.
    LDX   A,X ; Move to PTR[A]
    STX   R_A0EF_PARTICLE_CODE_PTR ; Change ptr.
    LDX   R_A0F3_PARTICLE_SCRATCHPAD_BMP/LOOP ; Load BMP PTR to X
    ASL   R_A0F5_PARTICLE_ADDED_TO_BMP_PTR? ; addr << 1
    LDA   R_A0EA_PARTICLE_UNK ; A from addr
PARTICLE_STUFF_SETUP_ALREADY?: ; 0x002E92, $FE92
    LDB   R_A0F5_PARTICLE_ADDED_TO_BMP_PTR? ; B from
    ABX ; X += B
    LDB   R_A0EC_PARTICLE_UNK ; B from
    JMP   [R_A0EF_PARTICLE_CODE_PTR] ; Goto addr pointed by.
TABLE_PTR_ENTRY_7: ; 0x002E9B, $FE9B
    STD   --U ; Screen pos store to particle end.
    LDY   X++ ; Data from BMP. 2 Bytes. 2x2 pixels.
    STY   [U] ; BMP_GFX to screen ptr we just stored.
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=12_JMP ; If overflow, forward BMP PTR this much to re-align.
TABLE_PTR_ENTRY_6: ; 0x002EA7, $FEA7
    STD   --U ; D to --U
    LDY   X++ ; Y from X
    STY   [U] ; Y to @U
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=10_JMP ; If lower, goto.
TABLE_PTR_ENTRY_5: ; 0x002EB3, $FEB3
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=8_JMP ; If lower, goto.
TABLE_PTR_ENTRY_4: ; 0x002EBF, $FEBF
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=6_JMP ; If lower, goto.
TABLE_PTR_ENTRY_3: ; 0x002ECB, $FECB
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=4_JMP ; If lower, goto.
TABLE_PTR_ENTRY_2: ; 0x002ED7, $FED7
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=2_JMP ; If lower, goto.
TABLE_PTR_ENTRY_1: ; 0x002EE3, $FEE3
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  R_A0E8_PARTICLE_SETTINGS_DOUBLED ; B += addr
    BCS   BMP_PTR+=0_JMP ; If lower, goto. MISTAKE: Useless? Fall through would be OK.
TABLE_PTR_ENTRY_0: ; 0x002EEF, $FEEF
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL] ; Goto @Addr
ODD_HEIGHT_ENTRY_HERE_FROM_PTR: ; 0x002EF3, $FEF3
    BCS   BMP_PTR+=1_OTHER ; Callback? If lower, goto.
    STD   --U ; D to --U
    LDB   X+ ; B from X+
    STB   [U] ; B to @U
    BRA   EVEN_HEIGHT_ENTRY_HERE_FROM_PTR ; Goto
BMP_PTR+=12_JMP: ; 0x002EFD, $FEFD
    LEAX  12,X
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=10_JMP: ; 0x002F03, $FF03
    LEAX  10,X
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=8_JMP: ; 0x002F09, $FF09
    LEAX  8,X
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=6_JMP: ; 0x002F0F, $FF0F
    LEAX  6,X
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=4_JMP: ; 0x002F15, $FF15
    LEAX  4,X
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=2_JMP: ; 0x002F1B, $FF1B
    LEAX  2,X
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=0_JMP: ; 0x002F21, $FF21
    JMP   [R_A0ED_PARTICLE_PTR_CODE_BMP_ADV/FAIL]
BMP_PTR+=1_OTHER: ; 0x002F25, $FF25
    LEAX  1,X ; X += 1
EVEN_HEIGHT_ENTRY_HERE_FROM_PTR: ; 0x002F27, $FF27
    DEC   R_A0F1_PARTICLE_WIDTH_TODO ; Dec width todo.
    BEQ   LEAVE_PARTICLE_RTN ; If 0, goto.
    ADDA  R_A0E7_PARTICLE_SETTING?MULTIPLIER? ; A += addr
    BCS   LEAVE_PARTICLE_RTN ; If (signed) lower, goto.
    CMPA  #$98 ; If A _ #$98, on screen?
    LBLS  PARTICLE_STUFF_SETUP_ALREADY? ; <=, goto. Next particle? Not sure.
LEAVE_PARTICLE_RTN: ; 0x002F35, $FF35
    LDX   R_A0F6_PARTICLE_PTR_STORE? ; X from addr
    STU   4,X ; PTR to slots taken up to PARTICLE[4]
    LDD   6,X ; D from XOBJ[6], SCREEN_FOCUS
    CMPA  #$98 ; If A _ #$98
    BHI   RTS ; If >, goto. MISTAKE? >= val should be used?
    SUBB  R_A0E6_PARTICLE_EXP_DIR?UNK? ; B -= addr, idk why.
    LDX   #$0000 ; X = 0
    STX   D,X ; 0 to D ptr.
RTS: ; 0x002F46, $FF46
    PULS  A,B,X,Y,U,PC ; RTS
PARTICLE_PTR_DATA: ; 0x002F48, $FF48
    .db $FE ; Entry 0
    .db $EF
    .db $FE ; Entry 1
    .db $E3
    .db $FE ; Entry 2
    .db $D7
    .db $FE ; Entry 3
    .db $CB
    .db $FE ; Entry 4
    .db $BF
    .db $FE ; Entry 5
    .db $B3
    .db $FE ; Entry 6
    .db $A7
    .db $FE ; Entry 7
    .db $9B
    .db $00 ; Unused here to next label?
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
DATA_W_#$F8EC_PARTICLE_HANDLER: ; 0x002F9D, $FF9D
    .db $F8
    .db $EC
DATA_W_#$F86E: ; 0x002F9F, $FF9F
    .db $F8
    .db $6E
JMP_GET_DATA_FROM_SRAM[X]_IN_A: ; 0x002FA1, $FFA1
    JMP   GET_DATA_FROM_SRAM[X]_IN_A
JMP_GET_DATA_FROM_SRAM@X_IN_B: ; 0x002FA4, $FFA4
    JMP   GET_DATA_FROM_SRAM[X]_IN_B
JMP_GET_DATA_FROM_SRAM@X_IN_AB: ; 0x002FA7, $FFA7
    JMP   GET_DATA_FROM_SRAM[X]_IN_AB
JMP_STORE_A_TO_SRAM_@X_BANKED: ; 0x002FAA, $FFAA
    JMP   STORE_A_TO_SRAM[X]_BANKED
JMP_STORE_B_TO_SRAM[X]: ; 0x002FAD, $FFAD
    JMP   STORE_B_TO_SRAM[X]
JMP_STORE_D_TO_SRAM[X]: ; 0x002FB0, $FFB0
    JMP   STORE_D_TO_SRAM[X]
JMP_GFX_BANK2_CHR_TO_SCREEN: ; 0x002FB3, $FFB3
    JMP   GFX_BANK2_CHR_TO_SCREEN ; Puts bank 2 char to screen.
JMP_GFX_BANK2_CHR_CLEAR: ; 0x002FB6, $FFB6
    JMP   GFX_BANK2_CHR_CLEAR ; Clears bank 2 char from screen.
JMP_CLEAR_SCREEN_FLEX_SETUP: ; 0x002FB9, $FFB9
    JMP   CLEAR_SCREEN_FLEX_SETUP
JMP_CLEAR_ALL_SCREEN: ; 0x002FBC, $FFBC
    JMP   CLEAR_ALL_SCREEN
JMP_ROM_CHECK_START: ; 0x002FBF, $FFBF
    JMP   ROM_CHECK_START
JMP_CORRECT_CHECKSUM: ; 0x002FC2, $FFC2
    JMP   CORRECT_CHECKSUM
JMP_RUG_SETUP: ; 0x002FC5, $FFC5
    JMP   RUG_PATTERN_SETUP
JMP_TO_RUG_PASS_SRAM_CHECK: ; 0x002FC8, $FFC8
    JMP   RUG_PASS_SRAM_CHECK
JMP_TO_GOTO_B7-C000,DRAW_LAND_UNK: ; 0x002FCB, $FFCB
    JMP   GOTO_B7-C000,DRAW_LAND
JMP_GOTO_PAST_JSR: ; 0x002FCE, $FFCE
    JMP   GOTO_PAST_JSR
JMP_SCHEDULE_BANKED_CALLBACK_IN_CURRENT_SUB: ; 0x002FD1, $FFD1
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
JMP_STORE_B@X_BANK0: ; 0x002FD4, $FFD4
    JMP   STORE_B[X]_BANK0
JMP_LOAD_B@X_BANK0: ; 0x002FD7, $FFD7
    JMP   LOAD_B[X]_BANK0
JMP_SET_SOUND_PRIORITIED: ; 0x002FDA, $FFDA
    JMP   SOUND_SET_SOUND_PRIORITIED
DATA_W_#$D4EE: ; 0x002FDD, $FFDD
    .db $D4
    .db $EE
    .db $2A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $F6 ; Interrupt vectors.
    .db $1F
    .db $F6
    .db $1F
    .db $F6
    .db $1F
    .db $F6
    .db $1F
    .db $A0 ; IRQ, Goes to $A08F in RAM.
    .db $8F
    .db $F6
    .db $1F
    .db $F6
    .db $1F
    .db $F6
    .db $1F

;Bank 1
	.org $C000

JMP_ATTRACT_START: ; 0x003000, $C000
    JMP   ATTRACT_START ; Main screen loop?
JMP_TO_RTN_UPDATE_SCANNER: ; 0x003003, $C003
    JMP   RTN_UPDATE_SCANNER
ATTRACT_START: ; 0x003006, $C006
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Sort
    LDA   #$FF ; Player state.
    STA   A0BA_PLAYER_GAME_STATE ; Game state to FF.
    JSR   INIT_ALL_STARS ; Init stars
    LDA   SRAM_C495-C496_PLAY_CREDITS ; Get sram val
    STA   PLAY_CREDITS_ATTRACT_START_VALUE_COPY ; Store
    CLRA
    STA   ATTRACT_GOTO_DEMO_FLAG ; Clear
    STA   R_A178_LEAVE_INITIAL_FLAG? ; Clear
    LDA   GAME_START_ENABLED_FLAG ; A from addr.
    LBEQ  FIRST_ATTRACT_INTRO_WILLIAMS ; If 0, goto.
    LDX   #$C8F4 ; Show credits handler.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Schedule task.
    LDY   #$A1C2 ; Score ptr?
    LDA   #$01 ; Normal.
PUT_IN_OTHER_PLAYER_INITIALS: ; 0x003030, $C030
    STA   R_A006_SCORE_POS_CHAR ; A to
    STY   R_A17B_PLAYER_DATA_PTR_SCR+INITIALS ; Y to.
    LDX   #$B2B4 ; Ptr to daily scores?
    JSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER
    LBCC  PLAYER_SCORE_LOWER_THAN_TABLE_ENTRY ; Table >=, goto.
    INC   R_A178_LEAVE_INITIAL_FLAG? ; Inc IDK
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    LDA   R_A006_SCORE_POS_CHAR ; Index into table?
    DECA ; -=1
    BNE   ENTERING_P2_INITIALS ; P2, flip.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED ; Set normal watchdog.
    BRA   SKIP_OTHER_WATCHDOG
ENTERING_P2_INITIALS: ; 0x003050, $C050
    JSR   SET_WATCHDOG_GAMEPLAY? ; Set possibly flipped watchdog.
SKIP_OTHER_WATCHDOG: ; 0x003053, $C053
    LDB   #$85 ; R=4/7,G=1/7,B=1/3, purple?
    STB   COLOR_PALETTE_RAM_COPY+1 ; Set color 1.
    LDA   #$3E ; Initials song.
    LDX   #$B260 ; Todays greatest list?
    JSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER
    BCC   SKIP_LOAD_A ; If D/A >= Y[1]/Y[3]
    LDA   #$3D ; Initials song
SKIP_LOAD_A: ; 0x003063, $C063
    LDX   #$CC02 ; X =
    LDB   #$3F ; Store 0011.1111
    JSR   JMP_STORE_B@X_BANK0
    LDB   #$24 ; Store 0010.0100
    JSR   JMP_STORE_B@X_BANK0
WAIT_A_LITTLE: ; 0x003070, $C070
    DECB ; B--
    BNE   WAIT_A_LITTLE ; For sound board to read val.
    LDB   #$3F ; Store 0011.1111
    JSR   JMP_STORE_B@X_BANK0
    TFR   A>B ; A from above, 3E or 3D.
    JSR   JMP_STORE_B@X_BANK0 ; Store to
    LDU   #$C0ED ; SENTENCE ELETRONICS INC. PRESENTS
    LDA   R_A006_SCORE_POS_CHAR ; Get val from
    ASLA ; << 1, *2
    LEAU  A,U ; U += A, U is now either PLAYER ONE or PLAYER TWO sentence ptrs.
    LDX   #$3E38
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $02
    .db $02
    LDU   #$C0FD ; SENTENCE YOU HAVE COMPLETED...
    LDX   #$1458
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $02
    .db $02
    LDD   #$412F ; Set up initial text with A-SPC-BLANK-SPC-BLANK-SPC
    STD   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; D to
    LDA   #$40 ; A =
    STD   R_A002_CURR_PLANET_GEN_HEIGHT ; D to
    STD   A003_CURR_PLANET_GEN_DATA_PTR+1 ; D to
    JSR   A000,A002,A004_TO_SCREEN ; To screen
    LDA   #$28 ; A to
    STA   INITIAL_ENTER_TIMER?
    LDX   #$C1DC ; Callback timer for input?
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$C1E7 ; Callback PALETTE[13] rotate
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$C1FA ; Callback char select.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    CLR   INITIAL_POS_INDEX ; Clear index.
    JSR   DRAW_INITIAL_UNDERLINES ; Do sub
RESCHEDULE_INITIAL_ENTERING_WITH_INIT: ; 0x0030CB, $C0CB
    CLRA ; Clear addr's.
    STA   R_A186_INITIAL_TIMER_FINE
    STA   R_A185_INITIAL_TIMER_LARGE
SCHEDULE_INITIAL_ENTERING: ; 0x0030D2, $C0D2
    LDA   #$01
    LDX   #$C0DA
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Setup callback for below.
CALLBACK_INITIAL_ENTER: ; 0x0030DA, $C0DA
    LDA   WGT_DATA_A_RAM_COPY ; Load widget A
    BITA  #$01 ; Test FIRE button
    BNE   FIRE_PRESSED ; Was set, do.
    TST   INITIAL_ENTER_TIMER? ; Test
    BEQ   TIMER_AT_ZERO ; If 0, goto.
    INC   R_A186_INITIAL_TIMER_FINE ; ++
    LDA   R_A186_INITIAL_TIMER_FINE ; Load
    CMPA  #$05 ; Cmp to
    BNE   SCHEDULE_INITIAL_ENTERING ; If not, schedule.
    STA   R_A185_INITIAL_TIMER_LARGE ; Store to
    BRA   SCHEDULE_INITIAL_ENTERING ; Schedule
FIRE_PRESSED: ; 0x0030F4, $C0F4
    CLR   R_A186_INITIAL_TIMER_FINE
    TST   R_A185_INITIAL_TIMER_LARGE
    BEQ   SCHEDULE_INITIAL_ENTERING ; If 0, schedule fire check.
    LDA   #$14
    STA   INITIAL_ENTER_TIMER? ; Reseed
    INC   INITIAL_POS_INDEX ; Initial++
    JSR   DRAW_INITIAL_UNDERLINES ; Draw lines.
    LDA   INITIAL_POS_INDEX ; Load new pos
    CMPA  #$03 ; If new _ 3
    BNE   RESCHEDULE_INITIAL_ENTERING_WITH_INIT ; !=, goto.
TIMER_AT_ZERO: ; 0x00310E, $C10E
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Deschedule callbacks.
    LDX   #$B2A8 ; End
    LDU   #$B254 ; Start
    JSR   SUB_SCORE_AT_Y_REPLACING_TABLE_U ; Insert score
    LDX   #$C471 ; Table
    BSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER ; Test if we replace this
    BCC   PLAYER_SCORE_LOWER_THAN_TABLE_ENTRY ; No, skip.
    LDX   #$C465 ; Replace this table, SRAM all time greatest.
    LDU   #$C411 ; Start
    JSR   SUB_SCORE_AT_Y_REPLACING_TABLE_U
PLAYER_SCORE_LOWER_THAN_TABLE_ENTRY: ; 0x00312A, $C12A
    LDY   #$A1FF ; Load P2 score ptr?
    LDA   R_A006_SCORE_POS_CHAR ; Load which player put in initials.
    INCA ; ++
    CMPA  #$03 ; If was 2, done.
    LBNE  PUT_IN_OTHER_PLAYER_INITIALS ; Wasn't 2, goto.
    TST   R_A178_LEAVE_INITIAL_FLAG? ; Test addr
    BNE   SKIP_SCHEDULE_TO_HERE ; Set, don't schedule.
    LDA   #$FF ; Schedule callback way into future.
    LDX   #$C144
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
SKIP_SCHEDULE_TO_HERE: ; 0x003144, $C144
    JMP   SHOW_HIGH_SCORE_TABLES
HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER: ; 0x003147, $C147
    PSHS  X,B,A ; Save
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Abuse to get X lower bits only?
    CMPD  1,Y ; If D _ Y[1]
    BNE   RTS ; !=, goto, got >= result val we need.
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get 3rd byte.
    CMPA  3,Y ; If A _ Y[3]
RTS: ; 0x003156, $C156
    PULS  A,B,X,PC ; RTS CMP results.
A000,A002,A004_TO_SCREEN: ; 0x003158, $C158
    LDX   #$46AC
    LDD   #$1408
    JSR   CLEAR_SCREEN_FLEX_SETUP
    LDU   #$C0FF ; PTR to A000, A002, A004
    JSR   JMP_GOTO_PAST_JSR ; To screen.
    .db $C0
    .db $02
    .db $02
    RTS ; RTS
DRAW_INITIAL_UNDERLINES: ; 0x00316B, $C16B
    CLR   POOL_A162_TO_A182/DRAW_CMD_TMP? ; Clear
    LDX   #$45B7 ; X =
LOOP_DRAW_UNDERLINES: ; 0x003171, $C171
    LDU   #$1111 ; Pixels
    LDA   POOL_A162_TO_A182/DRAW_CMD_TMP? ; A from
    CMPA  INITIAL_POS_INDEX ; If A _ addr
    BNE   DONT_LOAD_DIFF_PIXELS ; If not the same, dont load other.
    LDU   #$DDDD ; Different pixels.
DONT_LOAD_DIFF_PIXELS: ; 0x00317F, $C17F
    LDD   #$0400 ; A = Loop counter
LOOP_DRAW_LINE: ; 0x003182, $C182
    STU   D,X ; Pixels to X[D]
    DECA ; A--
    BNE   LOOP_DRAW_LINE ; Loop if not 0
    INC   POOL_A162_TO_A182/DRAW_CMD_TMP? ; ++
    LEAX  2048,X ; POSX += 8
    CMPX  #$5DB7 ; End pos
    BNE   LOOP_DRAW_UNDERLINES
    RTS
SUB_SCORE_AT_Y_REPLACING_TABLE_U: ; 0x003194, $C194
    STU   R_A164_HIGHSCORE_DATA_POS ; U to here
    LDY   R_A17B_PLAYER_DATA_PTR_SCR+INITIALS ; Player score pointer.
LOOP_TEST_REPLACE: ; 0x00319B, $C19B
    BSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER ; Test if replace.
    BCC   FOUND_REPLACED_SLOT ; Unsure if replace or not.
    BSR   SRAM_MOVEMENT_UNK ; Move SRAM?
    LEAX  -12,X ; Slot--
    CMPX  R_A164_HIGHSCORE_DATA_POS ; CMP TO U
    BHI   LOOP_TEST_REPLACE ; >, goto.
FOUND_REPLACED_SLOT: ; 0x0031A8, $C1A8
    LEAX  12,X ; Next slot.
    LDD   1,Y ; Store to SRAM
    JSR   STORE_D_TO_SRAM[X]
    LDA   3,Y ; This too
    JSR   STORE_A_TO_SRAM[X]_BANKED
    LDU   #$A000 ; Initials
LOOP_SAVE_INITIALS: ; 0x0031B7, $C1B7
    LDA   U ; Load initial
    JSR   STORE_A_TO_SRAM[X]_BANKED ; Store to SRAM
    LEAU  2,U ; U+=2
    CMPU  #$A006 ; End
    BNE   LOOP_SAVE_INITIALS
    RTS
SRAM_MOVEMENT_UNK: ; 0x0031C5, $C1C5
    PSHS  X ; Save X
LOOP_SRAM_MANIP: ; 0x0031C7, $C1C7
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Get SRAM data
    LEAX  8,X ; X += 8
    JSR   STORE_D_TO_SRAM[X] ; Loaded back to SRAM
    LEAX  -24,X ; x -= 24, 2 slots.
    CMPX  S ; CMP to original X
    BEQ   RTS ; ==, RTS
    LEAX  12,X ; X += 12
    BRA   LOOP_SRAM_MANIP
RTS: ; 0x0031DA, $C1DA
    PULS  X,PC
    DEC   INITIAL_ENTER_TIMER?
    LDA   #$3C ; Set callback.
    LDX   #$C1DC
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_COLOR_ROTATE: ; 0x0031E7, $C1E7
    LDA   COLOR_PALETTE_RAM_COPY+13
    BNE   CLEAR_COLOR
    LDA   COLOR_PALETTE_RAM_COPY+1 ; Color from slot 1
    BRA   COMMIT_A_T_COLOR
CLEAR_COLOR: ; 0x0031EF, $C1EF
    CLRA
COMMIT_A_T_COLOR: ; 0x0031F0, $C1F0
    STA   COLOR_PALETTE_RAM_COPY+13
    LDA   #$0F
    LDX   #$C1E7
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    CLR   PREV_CHAR_MOVEMENT ; Clear var.
    LDA   WGT_DATA_A_RAM_COPY ; Get input.
    BITA  #$80 ; Test DOWN
    BEQ   DOWN_NOT_PRESSED
    LDA   #$FF ; -1
    BRA   MOVE_CHAR
DOWN_NOT_PRESSED: ; 0x003207, $C207
    LDA   WGT_DATA_B_RAM_COPY ; Get input.
    BITA  #$01 ; Test UP.
    BEQ   UP_NOT_PRESSED
    LDA   #$01 ; +1
    BRA   MOVE_CHAR
UP_NOT_PRESSED: ; 0x003211, $C211
    CLR   PREV_CHAR_MOVEMENT ; Clear addr.
    BRA   SETUP_INITIAL_CHANGE_CALLBACK ; Goto
MOVE_CHAR: ; 0x003216, $C216
    CMPA  PREV_CHAR_MOVEMENT ; If A _ val
    BNE   INITIAL_MOVEMENT_SAME ; !=, goto.
    DEC   R_A17F_INITIAL_TIMER? ; Dec idk
    BNE   SETUP_INITIAL_CHANGE_CALLBACK ; If not 0, goto.
    LDX   #$A000 ; X ptr to initial index.
    LDB   INITIAL_POS_INDEX ; B from addr
    ASLB ; B << 1, *2
    ABX ; X += B
    LDA   X ; A from X
    ADDA  PREV_CHAR_MOVEMENT ; A += reg
    CMPA  #$3F ; If A _ #$3F
    BNE   DONT_ROLL_MAX ; !=, goto.
    LDA   #$5A ; ==, roll to max.
DONT_ROLL_MAX: ; 0x003233, $C233
    CMPA  #$5B ; !=, goto.
    BNE   OUTPUT_INITIAL ; !=, goto. roll to min if ==.
    LDA   #$40 ; ==, roll to min.
OUTPUT_INITIAL: ; 0x003239, $C239
    STA   X ; A (initial val) to ptr
    JSR   A000,A002,A004_TO_SCREEN ; Initials to screen.
    LDA   R_A17E_INITIAL_TIMER_RELATED?UNK ; A from addr
    LSRA ; >> 1, /2
    ADDA  #$05 ; += 5
    STA   R_A17E_INITIAL_TIMER_RELATED?UNK ; Store back to.
    STA   R_A17F_INITIAL_TIMER? ; Also store here?
SETUP_INITIAL_CHANGE_CALLBACK: ; 0x00324A, $C24A
    LDA   #$01 ; Callback for initial change.
    LDX   #$C1FD
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
INITIAL_MOVEMENT_SAME: ; 0x003252, $C252
    STA   PREV_CHAR_MOVEMENT ; Store
    LDA   #$37 ; Init
    STA   R_A17E_INITIAL_TIMER_RELATED?UNK
    LDA   #$03 ; Init
    STA   R_A17F_INITIAL_TIMER?
    BRA   SETUP_INITIAL_CHANGE_CALLBACK ; Setup callback.
    LDU   R_A0FF_SWARMERS_IN_POD_IDK
SHOW_HIGH_SCORE_TABLES: ; 0x003263, $C263
    CLR   POOL_A162_TO_A182/DRAW_CMD_TMP? ; Clear drawn last.
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Sort objs.
    JSR   DEFENDER_LOGO_TO_RAM ; Get logo in buffer.
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED ; Set to 1P pos.
    CLR   COLOR_PALETTE_RAM_COPY+1 ; Clear letter color.
    LDX   #$C8F4 ; Schedule showing credits.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    JSR   DISPLAY_PREVIOUS_GAMES_SCORES ; Display scores on the top left and right corners.
    LDU   #$C101 ; PTR to SENTENCE HALL OF FAME
    LDX   #$3854 ; Pos
    JSR   JMP_GOTO_PAST_JSR ; Put to screen.
    .db $C0
    .db $02
    .db $02
    LDU   #$1111
    LDX   #$1E7B ; Pos on screen min.
    LDD   #$5F00 ; Initial line pos.
LOOP_DRAW_LINE: ; 0x003294, $C294
    STU   D,X ; U to X+D
    CMPA  #$41 ; If ==, move.
    BNE   SKIP_MOVE_LINE_TO_LEFT ; Skip move.
    LDA   #$1F
SKIP_MOVE_LINE_TO_LEFT: ; 0x00329C, $C29C
    DECA ; X-1
    BPL   LOOP_DRAW_LINE ; Write to 0.
    LDA   #$2F ; End of text marker for groups.
    STA   R_A007_PLANET_DATA_PTR_HIGHER ; Store to
    STA   A00B_PLANET_GEN_DATA_PTR ; Store to
    STA   A012_PLANET_GEN_HEIGHT ; Store to.
    LDU   #$C103 ; Ptr to high score text data.
    LDX   #$1886 ; Screen pos?
    STX   R_A181_HIGHSCORE_SCR_POS
    LDX   #$B260 ; Table POS?
    STX   R_A164_HIGHSCORE_DATA_POS
    BSR   SUB_FIGURE+SHOW_SCORE_TEXT
    LDX   #$5986 ; Screen pos?
    STX   R_A181_HIGHSCORE_SCR_POS
    LDX   #$C41D ; Table POS?
    STX   R_A164_HIGHSCORE_DATA_POS
    BSR   SUB_FIGURE+SHOW_SCORE_TEXT
    LDA   #$3F
    STA   COLOR_PALETTE_RAM_COPY+12
    LDY   #$B300 ; Ptr to obj.
    LDD   #$3C18 ; Size
    STD   Y ; To pos.
    LDD   #$B412 ; Ptr
    STD   2,Y ; To fake obj.
    LDD   #$3038 ; Screen POS.
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Put DEFENDER to screen.
    LDX   #$E782 ; Schedule rotating color for text.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDA   #$3C
    STA   INITIAL_ENTER_TIMER? ; Timer for screen.
CALLBACK_WAIT_HIGH_SCORES: ; 0x0032EB, $C2EB
    TST   ATTRACT_GOTO_DEMO_FLAG ; Test addr.
    BNE   GO_TO_ATTRACT_DEMO ; If set, goto demo.
    TST   POOL_A162_TO_A182/DRAW_CMD_TMP?
    LBNE  SHOW_HIGH_SCORE_TABLES ; Keep showing tables.
    DEC   INITIAL_ENTER_TIMER? ; Timer--
    BEQ   GO_TO_ATTRACT_DEMO
    LDA   #$0A ; Callback to display high scores.
    LDX   #$C2EB
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
GO_TO_ATTRACT_DEMO: ; 0x003304, $C304
    BRA   ATTRACT_GAME_DEMO_INIT
SUB_FIGURE+SHOW_SCORE_TEXT: ; 0x003306, $C306
    LDA   #$31 ; "1" char val.
    STA   R_A006_SCORE_POS_CHAR ; Store pos.
LOOP_SCORES_TO_SCREEN: ; 0x00330A, $C30A
    CLRA ; Clear 
    LDY   #$A00C ; Ptr to loc.
    LDX   R_A164_HIGHSCORE_DATA_POS ; Initial pointer.
LOOP_CREATE_SCORE_STRING: ; 0x003312, $C312
    JSR   JMP_LOAD_B@X_BANK0 ; Get SRAM data.
    LEAX  1,X ; X++
    ANDB  #$0F ; Get bits.
    BNE   A++,B+=30 ; If not 0, show digit.
    TSTA ; Test A
    BNE   A++,B+=30 ; Not 0, display.
    LDB   #$40 ; Space val.
    BRA   SKIP_CHAR_WITH_SPACE
A++,B+=30: ; 0x003322, $C322
    INCA ; Flag displayed actual number.
    ADDB  #$30
SKIP_CHAR_WITH_SPACE: ; 0x003325, $C325
    STB   Y+ ; Write string.
    CMPY  #$A012
    BNE   LOOP_CREATE_SCORE_STRING ; Not done.
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB
    STD   HIGHSCORE_INITIALS_ADDR ; Write initials.
    JSR   GET_DATA_FROM_SRAM[X]_IN_A
    STA   A009_WORLD_HEIGHT_POS_LEFT?+1 ; 3x
    STX   R_A164_HIGHSCORE_DATA_POS
    LDX   R_A181_HIGHSCORE_SCR_POS ; Text ptr from
    JSR   JMP_GOTO_PAST_JSR ; Put strings to screen.
    .db $C0
    .db $02
    .db $02
    LEAX  10,X ; X += 10
    STX   R_A181_HIGHSCORE_SCR_POS ; X to
    INC   R_A006_SCORE_POS_CHAR ; ++
    LDA   R_A006_SCORE_POS_CHAR ; A from
    CMPA  #$39 ; If A _ val
    BNE   LOOP_SCORES_TO_SCREEN ; !=, loop. 1 to 8 score loop?
    RTS
ATTRACT_GAME_DEMO_INIT: ; 0x003351, $C351
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Sort tasks.
    JSR   ATTRACT_GAME_DEMO_INIT_2 ; Init data.
    LDA   #$D9
    STA   A0BA_PLAYER_GAME_STATE ; Store new state. TODO: Make happen in outer space, lol.
    JSR   DISPLAY_PREVIOUS_GAMES_SCORES ; Show last game scores in scanner.
    LDX   #$C8F4 ; Schedule show credits.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    JSR   DRAW_SCANNER_OUTLINES ; Scanner to the screen.
    LDX   #$CC63
    STX   R_A196_ATTRACT_TEXT_CURRENT
    LDX   #$E782 ; Schedule rotating color.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$F464 ; Schedule rotating color 2.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$F43D ; Schedule rotating color 3.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$E9E3 ; Schedule onscreen handling.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$C64F ; Schedule text to screen.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    JSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get 23B obj onscreen.
    LDD   #$0000 ; Clear
    STD   14,X ; OBJ[14]
    STD   16,X ; OBJ[16]
    LDD   #$1E00 ; World pos?
    STD   10,X ; To OBJ[10]
    LDD   #$DB00 ; Not sure of val.
    STD   12,X ; To OBJ[12]
    LDD   #$F901 ; PTR to BMP?
    STD   2,X ; OBJ[2]
    STX   LIST_IN_WORLD ; Object is root onscreen.
    LDD   #$6666 ; Idk val
    STD   18,X ; OBJ[18]
    STX   R_A189_OBJ_PTR_HUMANOID? ; Store obj pointer here.
    JSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get next obj.
    LDD   #$0000 ; Clear
    STD   14,X ; OBJ[14]
    STD   16,X ; OBJ[16]
    LDD   #$0800 ; World pos?
    STD   10,X ; OBJ[10]
    LDD   #$5000 ; Val
    STD   12,X ; OBJ[12]
    LDD   #$F9C1 ; Bitmap IDK
    STD   2,X ; BMP ptr?
    STX   LIST_IN_WORLD ; Add to screen list.
    LDD   #$0000
    STD   18,X ; Clear OBJ[18]
    STX   R_A18B_OBJ_PTR_SHIP? ; Store OBJ to
    JSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get another onscreen.
    LDD   #$F985 ; Bitmap IDK
    STD   2,X ; OBJ[2]
    LDD   #$1DA0 ; World pos?
    STD   10,X ; OBJ[10]
    LDD   #$4000 ; IDK
    STD   12,X ; OBJ[12]
    LDD   #$00A0 ; Idk val
    STD   16,X ; OBJ[16]
    LDD   #$0000 ; Idk val
    STD   14,X ; OBJ[14]
    LDD   #$4433 ; Idk val
    STD   18,X ; OBJ[18]
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP
    STX   R_A18D_OBJ_PTR_ENEMY? ; Store obj here.
    LDA   #$E6 ; Schedule code below.
    LDX   #$C412
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDD   #$FF50 ; Vertical movement value?
    LDX   R_A18D_OBJ_PTR_ENEMY? ; Object ptr
    STD   16,X
    LDX   R_A189_OBJ_PTR_HUMANOID? ; Object ptr.
    STD   16,X
    LDA   #$A0 ; Setup callback below.
    LDX   #$C429
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   #$C5F5
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Schedule task idk.
    STX   R_A187_OBJ_TMP_LASER_PTR? ; New obj to. Laser?
    LDA   #$15
    LDX   #$C475
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
ATTRACT_GAME_DEMO_INIT_2: ; 0x00343C, $C43C
    LDA   #$FF
    STA   A0BA_PLAYER_GAME_STATE ; Set state
    JSR   CHAIN_LIST_23B_LARGE_POOL_AND_NULL_OTHERS ; Setup enemies?
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    LDD   #$0000
    STD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Clear
    STD   R_A022_SCREEN_POS_HORIZ_2_TRGT? ; Clear
    JSR   JMP_GOTO_PAST_JSR ; Draw land.
    .db $F4
    .db $FA
    .db $00
    JSR   SETUP_GAMEPLAY_PALETTE ; Setup idk
    LDA   #$DB ; Change state
    STA   A0BA_PLAYER_GAME_STATE
    LDX   #$1030
    STX   SHIP_SCR_POS_XXYY ; Ship pos.
    RTS
ATTRACT_REMOVE_LASER: ; 0x003460, $C460
    LDX   R_A187_OBJ_TMP_LASER_PTR? ; OBJ 4 slot.
    LDU   DEMO_LASER_START_POS ; U from...
    CLRA ; Clear A
LOOP_ADD_256: ; 0x003467, $C467
    STA   U ; Clear U addr.
    LEAU  256,U ; Y += 256
    CMPU  7,X ; If U _ XOBJ[7]
    BLS   LOOP_ADD_256 ; <=, goto.
    JMP   XOBJ_REMOVED_FROM_CALLBACKS ; Give obj back. RTS's back to callee.
CALLBACK_ATTRACT_IDK: ; 0x003475, $C475
    BSR   ATTRACT_REMOVE_LASER
    LDX   R_A18D_OBJ_PTR_ENEMY? ; Obj 3
    JSR   REMOVE_X_FROM_LIST_ONSCREEN/OFFSCREEN ; Remove from list...
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP ; IDK
    LDX   R_A18B_OBJ_PTR_SHIP? ; X obj 2, ship?
    LDD   #$0040
    STD   14,X ; OBJ[14], H speed?
    LDD   #$00D4 ; V speed.
    STD   16,X ; OBJ[12], vspeed?
    LDA   #$2D ; Times to run
    STA   R_A18F_HUMANOID_LOOP_COUNTER
    LDX   R_A189_OBJ_PTR_HUMANOID? ; Root obj
    LDD   #$0000
    STD   16,X ; Clear Vspeed
CALLBACK_HUMANOID_FALL: ; 0x00349C, $C49C
    LDX   R_A189_OBJ_PTR_HUMANOID? ; Load root obj.
    LDD   16,X
    ADDD  #$0008 ; Add gravity for humanoid.
    STD   16,X ; Vspeed.
    DEC   R_A18F_HUMANOID_LOOP_COUNTER
    BEQ   ATTRACT_NEXT_PORTION ; If 0, goto.
    LDA   #$02 ; Set up humanoid fall callback.
    LDX   #$C49C
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
ATTRACT_NEXT_PORTION: ; 0x0034B5, $C4B5
    JSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get onscreen obj.
    LDD   #$0000
    STD   14,X ; Clear H speed.
    STD   16,X ; V speed
    LDD   #$1DFF ; World pos?
    STD   10,X
    LDD   #$9000 ; Idk
    STD   12,X
    LDD   #$F9E7 ; BMP
    STD   2,X
    STX   LIST_IN_WORLD ; Replace.
    LDD   #$0000
    STD   18,X ; Clear idk
    STX   R_A190_OBJ_PTR_INIT_LANDER/SCORE? ; Obj tmp
    LDD   #$0000 ; H speed
    LDU   #$00C0 ; V speed
    LDX   R_A18B_OBJ_PTR_SHIP? ; Get obj
    STD   14,X ; H speed
    STU   16,X ; V speed
    LDX   R_A189_OBJ_PTR_HUMANOID? ; Get obj.
    LDD   #$1E80
    STD   10,X ; SCR pos?
    LDD   #$A2E0 ; Idk
    STD   12,X
    STU   16,X ; V speed
    LDA   #$50 ; Schedule code below.
    LDX   #$C500
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_ATTRACT_SHIP_FLYBACK?: ; 0x003500, $C500
    LDX   R_A190_OBJ_PTR_INIT_LANDER/SCORE? ; Obj
    LDD   #$E000 ; Idk val
    STD   12,X
    LDD   #$1C00 ; Idk val
    STD   10,X
    LDX   R_A189_OBJ_PTR_HUMANOID? ; Root obj
    LDD   #$0000 ; No speed
    STD   16,X ; V speed
    LDX   R_A18B_OBJ_PTR_SHIP?
    LDD   #$F9CB ; Replace bitmap, flying left?
    STD   2,X
    LDD   #$FFC0 ; H speed
    STD   14,X
    LDD   #$FE80 ; V speed
    STD   16,X
    LDA   #$60 ; Schedule below.
    LDX   #$C531
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_SHIP_HOME?: ; 0x003531, $C531
    LDX   R_A18B_OBJ_PTR_SHIP?
    LDD   #$F9C1 ; Back to other bitmap.
    STD   2,X ; Bitmap change.
    LDD   #$0000
    STD   14,X ; H speed
    STD   16,X ; V speed
    LDX   R_A190_OBJ_PTR_INIT_LANDER/SCORE?
    LDD   4,X ; D from OBJ[4], save.
    JSR   REMOVE_X_FROM_LIST_ONSCREEN/OFFSCREEN ; Remove obj entirely.
    JSR   GFX_CLEAR_12X6 ; Clear manually.
    LDU   #$CC7D ; PTR to attract enemy data. BMP,POS,Scanpix
LOOP_ENEMIES: ; 0x00354F, $C54F
    JSR   LIST_GET_23B_ADDED_TO_INWORLD
    LDD   12,U ; D from U[12], val F985
    STD   2,X ; To bitmap.
    LDD   36,U ; D from U+36
    STD   18,X ; To OBJ[18]
    LDD   #$1F00 ; idk val
    STD   10,X
    LDD   #$A000 ; IDK val
    STD   12,X
    LDD   #$FF40
    STD   16,X ; V speed
    LDD   #$0000
    STD   14,X ; H speed
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP
    STU   R_A192_OBJ_PTR_SCRATCH
    STX   R_A18D_OBJ_PTR_ENEMY? ; Overwrite
    LDA   #$5F ; Callback below.
    LDX   #$C585
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   #$C5F5 ; Schedule laser.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    STX   R_A187_OBJ_TMP_LASER_PTR? ; Store new obj here.
    LDA   #$17 ; Schedule below.
    LDX   #$C598
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Schedule below.
    JSR   ATTRACT_REMOVE_LASER ; Idfk what it does.
    LDX   R_A18D_OBJ_PTR_ENEMY? ; Load OBJ 3
    JSR   REMOVE_X_FROM_LIST_ONSCREEN/OFFSCREEN ; Remove from list.
    JSR   LIST_GET_23B_ADDED_TO_INWORLD ; Get new obj on screen.
    JSR   JMP_TO_XOBJ_BLOWN_UP_PARTICLE_SETUP ; Particle IDK
    LDU   R_A192_OBJ_PTR_SCRATCH ; Load ptr
    LDD   24,U ; PTR+24
    STD   10,X ; To OBJ[10]
    LDD   U++ ; D from
    STD   12,X ; To OBJ[12]
    LDD   #$0000 ; No speed.
    STD   16,X
    STD   14,X
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP ; Spawn?
    STU   R_A192_OBJ_PTR_SCRATCH ; Store U back.
    LDA   #$20 ; Schedule below.
    LDX   #$C5CA
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_INC_TEXT_SHOWN: ; 0x0035CA, $C5CA
    LDX   R_A196_ATTRACT_TEXT_CURRENT ; Ptr to strings.
    LEAX  2,X ; Another string to display.
    STX   R_A196_ATTRACT_TEXT_CURRENT ; Store back.
    LDA   #$20 ; Schedule below.
    LDX   #$C5DA
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_WAIT: ; 0x0035DA, $C5DA
    LDU   R_A192_OBJ_PTR_SCRATCH ; Load ptr
    CMPU  #$CC89 ; U _ val
    LBNE  LOOP_ENEMIES ; !=, loop.
    LDA   #$FF ; Callback to below.
    LDX   #$C5ED
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_SCHEDULE_WILLIAMS_TITLESCREEN: ; 0x0035ED, $C5ED
    LDA   #$FF ; Callback williams title screen intro.
    LDX   #$C677
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_DEMO_LASERS_INIT: ; 0x0035F5, $C5F5
    LDX   R_A18B_OBJ_PTR_SHIP? ; Load OBJ
    LDX   4,X ; Load from XOBJ[4]
    LEAX  1796,X ; +=X-7,Y-4
    STX   7,U ; Val to UOBJ[7]
    STX   9,U ; UOBJ[9]
    STX   DEMO_LASER_START_POS ; Idk
CALLBACK_DEMO_LASERS_RERUN: ; 0x003605, $C605
    LDA   #$04 ; Loop cnt
    LDX   7,U ; X from UOBJ[7]
    LDB   #$11 ; Idk val
LOOP_A_TIMES: ; 0x00360B, $C60B
    STB   X ; B to XOBJ[0]
    LEAX  256,X ; POS+(1,0)
    DECA ; A--
    BNE   LOOP_A_TIMES ; Loop
    LDB   #$99 ; Pixels.
    STB   X ; B to X
    STX   7,U ; X to UOBJ[7]
    LDY   LASER_HOLES_POINTER_ADDR ; Ptr
    CMPY  #$A15F ; End of 00/01/10/11 Pool
    BCS   DONT_CHANGE_PTR_TO_LASER_HOLES
    LDY   #$A142 ; Laser holes pool start load.
DONT_CHANGE_PTR_TO_LASER_HOLES: ; 0x003627, $C627
    LDX   9,U ; To UOBJ[9]
    LDA   #$03 ; Loop
LOOP_LASER_HOLES: ; 0x00362B, $C62B
    LDB   Y+ ; B from pool
    STB   X ; B to laser
    LEAX  256,X ; Holes+(1,0)
    DECA ; A--
    BNE   LOOP_LASER_HOLES ; Loop 3x
    STY   LASER_HOLES_POINTER_ADDR
    STX   9,U ; Store laser to UOBJ[9]
    LDX   DEMO_LASER_START_POS ; Load start
    CLR   X ; Clear
    LEAX  256,X ; X+1
    STX   DEMO_LASER_START_POS ; Store back
    LDA   #$01 ; Schedule laser callback.
    LDX   #$C605
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_ALL_TEXT_TO_SCREEN: ; 0x00364F, $C64F
    LDY   #$CC61 ; Ptr to TEXT|POS data.
WRITE_NEW_ONLY: ; 0x003653, $C653
    LDU   14,Y ; Word ptr
    LDX   Y++ ; POS data.
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $02
    .db $02
    STY   R_A198_ATTRACT_NEXT_PTR ; New Y to.
    LDA   #$06 ; Schedule callback below.
    LDX   #$C66B
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
SCHEDULED_FROM_ABOVE: ; 0x00366B, $C66B
    LDY   R_A198_ATTRACT_NEXT_PTR ; Load ptr pos.
    CMPY  R_A196_ATTRACT_TEXT_CURRENT ; If PTR _ OTHER_PTR
    BNE   WRITE_NEW_ONLY ; !=, write new.
    BRA   CALLBACK_ALL_TEXT_TO_SCREEN ; Write all text when new text.
FIRST_ATTRACT_INTRO_WILLIAMS: ; 0x003677, $C677
    JSR   DESCHEDULE_CALLBACKS_NOT_TYPE_2 ; Clean up?
    CLR   ATTRACT_GOTO_DEMO_FLAG ; Clear addr
    LDA   #$FB ; State 1111.1011
    STA   A0BA_PLAYER_GAME_STATE
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    CLR   SENTENCE_PTR_WORD_ON ; Clear
    LDD   #$FFFF
    STD   TEXT_PTR_UNK ; Set to $FFFF
    LDX   #$E782 ; Schedule color rotation.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDX   #$F43D ; Schedule other color rotation.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDA   #$3F ; R = 1/7, G = 7/7, B = 3/3
    STA   COLOR_PALETTE_RAM_COPY+12 ; Set to yellow?
    JMP   SETUP_FIRST_INTRO_DATA ; Goto next line, rofl.
SETUP_FIRST_INTRO_DATA: ; 0x0036A2, $C6A2
    JSR   DEFENDER_LOGO_TO_RAM
    LDA   #$03
    STA   HANDWRITING_DRAW_STEPS ; Seed
    LDX   #$C941 ; Ptr to Williams handwritten logo.
    STX   HANDWRITING_WILLIAMS_DATA_PTR ; Store ptr.
DRAW_WILLIAMS_CALLBACK: ; 0x0036B0, $C6B0
    LDA   HANDWRITING_DRAW_STEPS ; Load val
    STA   DRAW_COUNTER_ACTUAL ; Store to
    LDY   HANDWRITING_WILLIAMS_DATA_PTR ; Y from ptr.
DRAW_LOOP: ; 0x0036BA, $C6BA
    LDA   Y+ ; A from Y
    CMPA  #$AA ; If A _ val
    BLS   NOT_CMD_MOVE_OUTPUT ; <=, goto.
    COMA ; Invert otherwise.
    BEQ   DRAW_LOOP ; Was FF, goto.
    DECA ; A--
    BNE   DRAWING_EOF ; Not FE, goto.
    LDD   Y++ ; D from Y
    STD   DRAW_PIXEL_POS_XXYY ; New pos writing.
    CLRA ; Clear A, command consumed.
    BRA   DRAW_PIXEL_NOW
NOT_CMD_MOVE_OUTPUT: ; 0x0036CE, $C6CE
    ASLA ; << 1
    BCC   DONT_DEC_66 ; Shift 0, goto.
    DEC   DRAW_PIXEL_POS_XXYY ; --
DONT_DEC_66: ; 0x0036D4, $C6D4
    ASLA
    BCC   DONT_INC_66
    INC   DRAW_PIXEL_POS_XXYY ; ++
DONT_INC_66: ; 0x0036DA, $C6DA
    ASLA
    BCC   DONT_DEC_67
    DEC   DRAW_PIXEL_POS_XXYY+1 ; --
DONT_DEC_67: ; 0x0036E0, $C6E0
    ASLA
    BCC   DRAW_PIXEL_NOW
    INC   DRAW_PIXEL_POS_XXYY+1 ; ++
DRAW_PIXEL_NOW: ; 0x0036E6, $C6E6
    STA   POOL_A162_TO_A182/DRAW_CMD_TMP? ; Store shifted A
    LDD   DRAW_PIXEL_POS_XXYY ; D from addr
    LSRA ; A >> 1, get if setting low nibble.
    TFR   D>X ; D to X
    LDB   X ; B from X
    BCS   SETTING_LOW_NIBBLE ; If shifted 1, goto.
    ORB   #$F0 ; Set high nibble.
    BRA   SKIP_SET_LOW
SETTING_LOW_NIBBLE: ; 0x0036F7, $C6F7
    ORB   #$0F ; Set low nibble.
SKIP_SET_LOW: ; 0x0036F9, $C6F9
    STB   X ; B to X
    LDA   POOL_A162_TO_A182/DRAW_CMD_TMP? ; A from
    BNE   NOT_CMD_MOVE_OUTPUT
    DEC   DRAW_COUNTER_ACTUAL ; Dec counter.
    BNE   DRAW_LOOP ; Not done.
    STY   HANDWRITING_WILLIAMS_DATA_PTR ; Save Y
    LDA   #$02 ; Schedule callback for logo trace.
    LDX   #$C6B0
    JSR   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; TODO: Mistake, kills stack. Should be JMP.
DRAWING_EOF: ; 0x003711, $C711
    STX   R_A168_COPY_PROTECTION_6245_VAL ; Screen draw pos? DRAW_WILLIAMS_CALLBACK comes here, from above.
    LDA   #$03
    CMPA  HANDWRITING_DRAW_STEPS ; 3 _ addr
    BNE   HAS_BEEN_RESEEDED ; !=, goto.
    LDA   #$0A ; Reseed to redraw faster
    STA   HANDWRITING_DRAW_STEPS
    LDX   #$C730 ; Schedule rtn below.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; RTS's
HAS_BEEN_RESEEDED: ; 0x003728, $C728
    LDX   #$C941
    STX   HANDWRITING_WILLIAMS_DATA_PTR ; Reset data ptr.
    BRA   DRAW_WILLIAMS_CALLBACK ; Keep drawing logo.
SCHEDULED_CALLBACK_FORWARD?: ; 0x003730, $C730
    LDX   #$C74C ; Receieve below.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; RTS's
RESCHEDULED_WRONG_CALLBACK_1: ; 0x003738, $C738
    LDX   #$3258 ; POS
    LDU   #$C0ED ; PTR to SENTENCE ELECTRONICS INC. PRESENTS
    JSR   JMP_GOTO_PAST_JSR ; To screen
    .db $C0
    .db $02
    .db $02
    LDA   #$05 ; Schedule text to screen every 5 ticks.
    LDX   #$C738
    JSR   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Schedule, also mistake.
CALLBACK_FORWARD_RECIEVE?: ; 0x00374C, $C74C
    LDA   #$30 ; Schedule below code in 30 ticks...
    LDX   #$C754
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Schedule.
SCHEDULED_PARTICLES_SPAWN_SETUP: ; 0x003754, $C754
    LDD   #$B3D6 ; Ptr to unk
    STD   LOGO_PARTICLES_PTR_A ; Ptr here
    LDD   #$B412 ; Another?
    STD   LOGO_PARTICLES_PTR_B ; Ptr to
    LDD   #$0000
    STD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Clear
    LDD   #$0C00 ; Not sure of val.
    STD   LOGO_PARTICLES_VAL_UNK
    LDD   #$B304 ; Yet another pointer idk.
    STD   LOGO_PARTICLES_PTR_C
LOOP_MAKE_LOGO_SPAWN_IN_PARTICLES?: ; 0x003771, $C771
    LDX   LOGO_PARTICLES_PTR_C ; B304 start
    LDY   LOGO_PARTICLES_PTR_A ; B3D6 start
    LDD   #$040C ; D from
    STD   Y ; To
    LDD   LOGO_PARTICLES_PTR_B ; B412 start, actual logo data pos it seems.
    STD   2,Y ; To
    ADDD  #$0060 ; D += #$60
    STD   LOGO_PARTICLES_PTR_B ; Save new D
    STY   2,X ; Y to X[2]
    LDD   LOGO_PARTICLES_VAL_UNK ; #$0C00 start
    STD   10,X ; Something location?
    ADDD  #$0100 ; D += 100
    STD   LOGO_PARTICLES_VAL_UNK ; Save new D
    LDD   #$9800 ; Idk val
    STD   12,X ; To OBJ[12]
    JSR   JMP_TO_XOBJ_SPAWNING_IN_PARTICLE_SETUP ; Spawn in with particles.
    LEAX  14,X ; X+=14
    STX   LOGO_PARTICLES_PTR_C ; Store to
    LEAY  4,Y ; Y += 4
    STY   LOGO_PARTICLES_PTR_A ; Store to
    CMPY  #$B412 ; 0x3C bytes, 60 bytes, /4 = 15 things.
    BNE   LOOP_MAKE_LOGO_SPAWN_IN_PARTICLES?
    LDA   #$2E ; Schedule code below.
    LDX   #$C7B7
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_MOVE_LOGO_TO_SCREEN: ; 0x0037B7, $C7B7
    LDX   #$B300 ; Ptr to data buffer.
    LDD   #$3C18 ; WWHH to LARGE_BUF[0]
    STD   X ; To buffer.
    LDD   #$B412 ; Ptr to gfx, even.
    STD   2,X ; To LARGE_BUF[2]
    LDX   #$C848 ; Schedule this.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDA   #$28 ; Setup callback for code below.
    LDX   #$C7D4
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_START_ROTATING_LOGO_COLORS: ; 0x0037D4, $C7D4
    LDX   #$F464 ; Schedule palette rotate for logo.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
COPY_PROTECTION_STUFF: ; 0x0037DC, $C7DC
    LDU   R_A168_COPY_PROTECTION_6245_VAL ; Copy protection load.
    LDY   #$CC11 ; Data ptr idk. This code is probably a red herring for the result, the STU D,X.
    LDX   #$3BD0 ; X =
LOOP_NEW_DATA_IN_REGS: ; 0x0037E6, $C7E6
    LDD   Y++ ; D from Y
    STD   R_A164_HIGHSCORE_DATA_POS ; D to addr
    LDA   #$01 ; Seed times.
LOOP_MAKE_B_1: ; 0x0037ED, $C7ED
    CLRB ; Clear B
    BITA  R_A164_HIGHSCORE_DATA_POS ; Test val at addr
    BEQ   DONT_SEED_B ; Not set dont seed
    LDB   #$10 ; B =
DONT_SEED_B: ; 0x0037F5, $C7F5
    BITA  R_A164_HIGHSCORE_DATA_POS+1 ; Test
    BEQ   DONT_OR_B_1 ; If 0, dont set bit.
    ORB   #$01 ; B | 0x1
DONT_OR_B_1: ; 0x0037FC, $C7FC
    STB   X+ ; Store to X ptr
    ASLA ; A << 1
    BNE   LOOP_MAKE_B_1 ; !0, goto.
    LEAX  248,X ; 8 tall, so add 8 less.
    CMPY  #$CC61 ; End
    BNE   LOOP_NEW_DATA_IN_REGS ; Not end, loop with new bytes.
    LDX   #$A026 ; Ptr to palette.
    LDB   DATA_W_0FE7 ; B from addr, index into palette, 15.
    LDA   B,X ; A from X+B
    COMA ; Invert A. Init is 0x00. TODO: Find out when bottom 3 bits cleared.
    ANDA  #$07 ; Get bits.
    BNE   ANY_BITS_SET ; If any set, skip.
    LDX   #$8018 ; Copy protection store to A0B8.
    LDD   #$20A0
    STU   D,X ; U to A0B8, U is 6245 here.
ANY_BITS_SET: ; 0x003820, $C820
    LDA   #$01
    STA   GAME_START_ENABLED_FLAG ; Enable starting of a game now. Copy protection value in place.
    LDX   #$C8F4 ; Schedule credits to screen.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X
    LDA   #$3C
    STA   INITIAL_ENTER_TIMER? ; Seed timer.
    TST   ATTRACT_GOTO_DEMO_FLAG ; Test addr
    LBNE  ATTRACT_GAME_DEMO_INIT ; != 0, goto.
    DEC   INITIAL_ENTER_TIMER? ; Dec timer.
    BEQ   JMP_TO_SHOW_HIGH_SCORE_TABLES ; If 0, goto.
    LDA   #$0A ; Callback to wait.
    LDX   #$C831
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
JMP_TO_SHOW_HIGH_SCORE_TABLES: ; 0x003845, $C845
    JMP   SHOW_HIGH_SCORE_TABLES
CALLBACK_MOVE_LOGO_TO_SCREEN: ; 0x003848, $C848
    LDY   #$B300 ; GFX data ptr. Is setup by previous calls.
    LDD   #$3090 ; Pos
    JSR   GFX_BANK2_CHR_TO_SCREEN ; To screen.
    TST   $9C00 ; Test loc
    BNE   RESCHEDULE_MOVE_LOGO ; !0, goto.
    TST   $9C40 ; Test addr
    BNE   RESCHEDULE_MOVE_LOGO ; !-, goto.
    LDX   #$C921 ; Schedule replace drawn williams logo.
    LDA   #$00
    JSR   SCHEDULE_15B_CALLBACK_TYPE=A_CB=X_NEXT_TICK_SUB_RET_X ; Do callback.
    JMP   CALLBACK_TASK_REMOVE ; We're done.
RESCHEDULE_MOVE_LOGO: ; 0x003867, $C867
    LDA   #$01 ; Set up callback again.
    LDX   #$C848
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
DEFENDER_LOGO_TO_RAM: ; 0x00386F, $C86F
    LDX   #$B412 ; Ptr to RAM data?
    LDY   #$CAA0 ; Ptr to ROM data?
    CLRA
    STA   R_LOGO_PAIR_LOWER
    STA   R_LOGO_PAIR_UPPER
LOAD_FROM_Y+IDK: ; 0x00387D, $C87D
    LDA   Y ; A from Y ptr
    LSRA ; A >> 4
    LSRA
    LSRA
    LSRA
    BSR   SUB_DO_ON_A ; Do sub on bits.
    LDA   Y+
    ANDA  #$0F ; Now bottom bits.
    BSR   SUB_DO_ON_A ; Do sub.
    CMPY  #$CC0E ; End
    BNE   LOAD_FROM_Y+IDK ; Not end.
SUB_DO_ON_A: ; 0x003891, $C891
    BITA  #$0C ; Test 0000.1100
    BNE   BOTTOM_NIB_TOP_SET ; If set, goto.
    ADDA  R_LOGO_PAIR_UPPER ; A += VAL
    ASLA ; A << 2
    ASLA
    STA   R_LOGO_PAIR_UPPER ; To val.
    RTS
BOTTOM_NIB_TOP_SET: ; 0x00389E, $C89E
    PSHS  A ; Save reg.
    ANDA  #$03 ; Get bottom bits.
    ADDA  R_LOGO_PAIR_UPPER ; Addr += A
    STA   R_LOGO_PAIR_UPPER
    PULS  A ; Get value again
    ANDA  #$0C ; Get 0000.1100
    LSRA ; >> 2
    LSRA
    LDU   #$CC0D
    LDB   A,U ; B from U to U+3
    STB   DEFENDER_LOGO_USED_TO_STORE_VAR ; To addr
    CMPX  #$B9B2
    BCS   SKIP_MINUS_ALOT ; If X <, goto.
    LEAX  -1439,X ; X -=
SKIP_MINUS_ALOT: ; 0x0038BF, $C8BF
    LDA   R_LOGO_PAIR_LOWER ; Load val
    BEQ   PAIR_LOWER_IS_ZERO
    LDA   X ; A from X
    ANDA  #$F0 ; Get top bits.
    STA   X ; Store back to X
    LDA   DEFENDER_LOGO_USED_TO_STORE_VAR ; Load from
    ANDA  #$0F ; Get lower bits.
    ORA   X ; Or with X
    STA   X ; Store to X
    LDA   DEFENDER_LOGO_USED_TO_STORE_VAR ; Get A from
    BRA   X_PLUS_24
PAIR_LOWER_IS_ZERO: ; 0x0038D8, $C8D8
    COM   R_LOGO_PAIR_LOWER ; 0 to FF
    LDA   DEFENDER_LOGO_USED_TO_STORE_VAR ; A from
STORE_A_TO_X: ; 0x0038DE, $C8DE
    STA   X ; To X
    DEC   R_LOGO_PAIR_UPPER ; Dec val
    BMI   CLEAR_UPPER+RTS ; If minus, goto.
X_PLUS_24: ; 0x0038E5, $C8E5
    LEAX  24,X ; X += 24
    DEC   R_LOGO_PAIR_UPPER ; Dec again
    BPL   STORE_A_TO_X ; If positive, goto.
    CLR   R_LOGO_PAIR_LOWER ; Clear upper
CLEAR_UPPER+RTS: ; 0x0038F0, $C8F0
    CLR   R_LOGO_PAIR_UPPER ; Clear lower.
    RTS
SHOW_CREDITS_CALLBACK: ; 0x0038F4, $C8F4
    LDB   SRAM_C495-C496_PLAY_CREDITS ; B from SRAM
    BEQ   SCHEDULE_SHOW_CREDITS ; No credits, reschedule.
    CMPB  PLAY_CREDITS_ATTRACT_START_VALUE_COPY ; CMP to prev.
    BLS   PUT_CREDITS_ON_SCREEN ; Load <=, dont goto attract.
    STB   PLAY_CREDITS_ATTRACT_START_VALUE_COPY ; Store higher.
    INC   ATTRACT_GOTO_DEMO_FLAG ; Goto attract.
PUT_CREDITS_ON_SCREEN: ; 0x003903, $C903
    LDU   #$C0E9 ; CREDITS:
    LDX   #$28E5 ; POS
    JSR   JMP_GOTO_PAST_JSR ; To screen.
    .db $C0
    .db $02
    .db $02
    CLRA ; A = 0
    LDX   #$48E5 ; Pos
    JSR   JMP_GOTO_PAST_JSR ; Put AB #'s to screen.
    .db $C0
    .db $0E
    .db $02
SCHEDULE_SHOW_CREDITS: ; 0x003919, $C919
    LDA   #$10 ; Shedule show credits.
    LDX   #$C8F4
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_REDRAW_WILLIAMS_ALOT: ; 0x003921, $C921
    LDA   #$FF
    STA   HANDWRITING_DRAW_STEPS ; Lots of draw steps for logo.
    LDA   #$02
    LDX   #$C92E
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_REDRAW_WILLIAMS_MEDIUM: ; 0x00392E, $C92E
    LDA   #$0A
    STA   HANDWRITING_DRAW_STEPS ; Seed to lower value now since rewritten.
    JMP   CALLBACK_TASK_REMOVE ; We're done here.
DISPLAY_PREVIOUS_GAMES_SCORES: ; 0x003936, $C936
    LDA   A08C_CURRENT_PLAYER_COUNT_1/2
LOOP_SHOW_SCORES: ; 0x003938, $C938
    BEQ   RTS ; Don't show none.
    JSR   PLAYER_PASSED_SCORE_TO_SCREEN
    DECA
    BRA   LOOP_SHOW_SCORES
RTS: ; 0x003940, $C940
    RTS
WILLIAMS_LOGO_HANDWRITING_DATA: ; 0x003941, $C941
    .db $FE ; FMT: [1B]
    .db $74 ; FF = Nothing, FE = Load pos for pixel, other values >AA mean EOF.
    .db $40 ; Otherwise nibble bits mean U/D/L/R
    .db $11
    .db $11
    .db $85
    .db $81
    .db $81
    .db $81
    .db $88
    .db $82
    .db $82
    .db $22
    .db $24
    .db $22
    .db $42
    .db $24
    .db $24
    .db $24
    .db $44
    .db $24
    .db $44
    .db $49
    .db $44
    .db $94
    .db $41
    .db $88
    .db $14
    .db $41
    .db $88
    .db $14
    .db $41
    .db $88
    .db $94
    .db $41
    .db $88
    .db $94
    .db $49
    .db $88
    .db $14
    .db $98
    .db $58
    .db $94
    .db $98
    .db $18
    .db $94
    .db $46
    .db $66
    .db $62
    .db $42
    .db $42
    .db $42
    .db $42
    .db $25
    .db $24
    .db $24
    .db $68
    .db $24
    .db $24
    .db $24
    .db $26
    .db $11
    .db $18
    .db $18
    .db $58
    .db $18
    .db $58
    .db $81
    .db $44
    .db $98
    .db $81
    .db $44
    .db $98
    .db $81
    .db $44
    .db $98
    .db $14
    .db $94
    .db $94
    .db $16
    .db $22
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $FE
    .db $81
    .db $4A
    .db $42
    .db $42
    .db $42
    .db $42
    .db $44
    .db $99
    .db $99
    .db $41
    .db $88
    .db $14
    .db $41
    .db $88
    .db $14
    .db $46
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $A4
    .db $22
    .db $42
    .db $4A
    .db $42
    .db $42
    .db $44
    .db $99
    .db $19
    .db $91
    .db $19
    .db $91
    .db $91
    .db $81
    .db $81
    .db $41
    .db $81
    .db $49
    .db $46
    .db $42
    .db $42
    .db $42
    .db $42
    .db $42
    .db $42
    .db $24
    .db $22
    .db $42
    .db $62
    .db $62
    .db $42
    .db $24
    .db $49
    .db $19
    .db $91
    .db $91
    .db $91
    .db $91
    .db $91
    .db $85
    .db $88
    .db $14
    .db $94
    .db $14
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $41
    .db $81
    .db $81
    .db $18
    .db $18
    .db $94
    .db $41
    .db $88
    .db $14
    .db $14
    .db $24
    .db $42
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $44
    .db $98
    .db $18
    .db $18
    .db $18
    .db $58
    .db $89
    .db $44
    .db $18
    .db $85
    .db $14
    .db $24
    .db $14
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $28
    .db $24
    .db $44
    .db $18
    .db $19
    .db $19
    .db $81
    .db $41
    .db $81
    .db $14
    .db $24
    .db $24
    .db $24
    .db $24
    .db $22
    .db $42
    .db $42
    .db $64
    .db $41
    .db $85
    .db $81
    .db $81
    .db $18
    .db $19
    .db $41
    .db $89
    .db $44
    .db $42
    .db $22
    .db $42
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $44
    .db $18
    .db $14
    .db $98
    .db $11
    .db $81
    .db $81
    .db $41
    .db $89
    .db $44
    .db $42
    .db $22
    .db $42
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $44
    .db $18
    .db $94
    .db $41
    .db $88
    .db $89
    .db $44
    .db $49
    .db $88
    .db $14
    .db $41
    .db $88
    .db $14
    .db $14
    .db $24
    .db $24
    .db $24
    .db $26
    .db $62
    .db $66
    .db $26
    .db $24
    .db $18
    .db $91
    .db $91
    .db $19
    .db $18
    .db $14
    .db $18
    .db $14
    .db $14
    .db $24
    .db $14
    .db $2A
    .db $45
    .db $24
    .db $68
    .db $88
    .db $24
    .db $44
    .db $42
    .db $18
    .db $A8
    .db $82
    .db $44
    .db $A8
    .db $22
    .db $20
    .db $FE
    .db $87
    .db $40
    .db $44
    .db $11
    .db $88
    .db $24
    .db $FE
    .db $9A
    .db $3F
    .db $44
    .db $11
    .db $88
    .db $24
    .db $FE
    .db $C1
    .db $3F
    .db $44
    .db $44
    .db $44
    .db $11
    .db $11
    .db $11
    .db $11
    .db $88
    .db $88
    .db $88
    .db $22
    .db $22
    .db $22
    .db $20
    .db $FE
    .db $C3
    .db $45
    .db $22
    .db $22
    .db $44
    .db $11
    .db $81
    .db $50
    .db $FD
DEFENDER_LOGO_DATA: ; 0x003AA0, $CAA0
    .db $10
    .db $D1
    .db $BD
    .db $29
    .db $C2
    .db $9C
    .db $29
    .db $CB
    .db $EA
    .db $C2
    .db $8C
    .db $29
    .db $C2
    .db $81
    .db $0D
    .db $10
    .db $C2
    .db $8D
    .db $29
    .db $C2
    .db $9C
    .db $29
    .db $CB
    .db $EA
    .db $42
    .db $94
    .db $29
    .db $42
    .db $81
    .db $0C
    .db $3F
    .db $29
    .db $C2
    .db $94
    .db $C2
    .db $9C
    .db $29
    .db $C1
    .db $8D
    .db $A4
    .db $29
    .db $42
    .db $94
    .db $29
    .db $3F
    .db $3E
    .db $29
    .db $42
    .db $A4
    .db $29
    .db $4C
    .db $29
    .db $C1
    .db $8D
    .db $A4
    .db $2A
    .db $42
    .db $94
    .db $29
    .db $3E
    .db $3D
    .db $B6
    .db $B4
    .db $A2
    .db $4A
    .db $17
    .db $CA
    .db $16
    .db $C1
    .db $9C
    .db $B4
    .db $A7
    .db $A4
    .db $B1
    .db $7A
    .db $7A
    .db $3D
    .db $3C
    .db $B6
    .db $B4
    .db $B1
    .db $71
    .db $81
    .db $6B
    .db $16
    .db $C1
    .db $AC
    .db $A4
    .db $B6
    .db $B4
    .db $A2
    .db $4A
    .db $6B
    .db $3C
    .db $2F
    .db $B6
    .db $B4
    .db $29
    .db $62
    .db $85
    .db $C2
    .db $85
    .db $C1
    .db $AC
    .db $A4
    .db $B6
    .db $B4
    .db $28
    .db $62
    .db $A2
    .db $F2
    .db $EB
    .db $61
    .db $84
    .db $29
    .db $62
    .db $8E
    .db $28
    .db $E2
    .db $A4
    .db $B7
    .db $B4
    .db $28
    .db $62
    .db $A2
    .db $E2
    .db $DB
    .db $7B
    .db $42
    .db $96
    .db $28
    .db $4E
    .db $28
    .db $E2
    .db $B4
    .db $B6
    .db $B4
    .db $29
    .db $62
    .db $92
    .db $E2
    .db $CB
    .db $7B
    .db $52
    .db $96
    .db $28
    .db $4E
    .db $28
    .db $EB
    .db $41
    .db $A4
    .db $B7
    .db $B4
    .db $28
    .db $62
    .db $92
    .db $E1
    .db $FB
    .db $7B
    .db $5B
    .db $24
    .db $B1
    .db $6D
    .db $18
    .db $14
    .db $EB
    .db $51
    .db $94
    .db $B7
    .db $B4
    .db $18
    .db $17
    .db $29
    .db $2D
    .db $1E
    .db $B1
    .db $4B
    .db $4B
    .db $25
    .db $B1
    .db $6D
    .db $B1
    .db $5E
    .db $B5
    .db $1A
    .db $4B
    .db $61
    .db $84
    .db $B2
    .db $4B
    .db $41
    .db $82
    .db $C1
    .db $DB
    .db $14
    .db $B5
    .db $18
    .db $17
    .db $18
    .db $16
    .db $D1
    .db $81
    .db $4E
    .db $B6
    .db $19
    .db $4B
    .db $61
    .db $84
    .db $18
    .db $24
    .db $B4
    .db $18
    .db $1F
    .db $1C
    .db $38
    .db $53
    .db $84
    .db $B1
    .db $6E
    .db $2B
    .db $CB
    .db $61
    .db $94
    .db $38
    .db $42
    .db $B4
    .db $18
    .db $41
    .db $81
    .db $EF
    .db $39
    .db $43
    .db $85
    .db $B1
    .db $6E
    .db $2B
    .db $CB
    .db $71
    .db $84
    .db $38
    .db $43
    .db $84
    .db $B6
    .db $18
    .db $1C
    .db $E3
    .db $95
    .db $38
    .db $41
    .db $81
    .db $6D
    .db $38
    .db $CB
    .db $C6
    .db $19
    .db $42
    .db $B5
    .db $38
    .db $4B
    .db $61
    .db $8F
    .db $D3
    .db $95
    .db $38
    .db $5B
    .db $51
    .db $F3
    .db $8C
    .db $BD
    .db $61
    .db $84
    .db $2A
    .db $63
    .db $85
    .db $B6
    .db $18
    .db $ED
    .db $38
    .db $53
    .db $94
    .db $18
    .db $51
    .db $F3
    .db $8C
    .db $BD
    .db $7B
    .db $42
    .db $91
    .db $42
    .db $B5
    .db $18
    .db $7B
    .db $DC
    .db $21
    .db $51
    .db $F3
    .db $4C
    .db $7E
    .db $30
    .db $6C
    .db $C2
    .db $14
    .db $2C
    .db $34
    .db $C7
    .db $E1
    .db $07
    .db $C1
    .db $35
    .db $CC
    .db $21
    .db $42
    .db $C3
    .db $4C
    .db $7F
    .db $10
    .db $6C
    .db $13
    .db $5C
    .db $C1
    .db $35
    .db $C1
    .db $52
    .db $C3
    .db $4C
    .db $7F
    .db $15
    .db $C2
    .db $7D
    .db $34
    .db $C1
    .db $5C
    .db $17
    .db $CC
    .db $36
    .db $C3
    .db $5C
    .db $14
    .db $2D
    .db $34
    .db $C7
    .db $1C
    .db $14
    .db $C2
    .db $6E
    .db $34
    .db $D1
    .db $4E
    .db $15
    .db $CC
    .db $36
    .db $C3
    .db $5C
    .db $14
    .db $2D
    .db $34
    .db $C7
    .db $1C
    .db $14
    .db $C2
    .db $51
    .db $C2
    .db $7D
    .db $14
    .db $F1
DATA_PTR_3: ; 0x003C0D, $CC0D
    .db $4C
    .db $22
    .db $CC
    .db $00 ; Data end.
DATA_ONSCREEN_CP?: ; 0x003C11, $CC11
    .db $3E ; CP graphic on title screen?
    .db $41
    .db $41
    .db $22
    .db $00
    .db $3E
    .db $41
    .db $41
    .db $3E
    .db $00
    .db $7F
    .db $09
    .db $09
    .db $06
    .db $00
    .db $03
    .db $04
    .db $78
    .db $04
    .db $03
    .db $00
    .db $7F
    .db $09
    .db $19
    .db $66
    .db $00
    .db $41
    .db $7F
    .db $41
    .db $00
    .db $3E
    .db $41
    .db $49
    .db $3A
    .db $00
    .db $7F
    .db $08
    .db $08
    .db $7F
    .db $00
    .db $01
    .db $01
    .db $7F
    .db $01
    .db $01
    .db $00
    .db $1C
    .db $22
    .db $5D
    .db $63
    .db $55
    .db $22
    .db $1C
    .db $22
    .db $7F
    .db $4B
    .db $45
    .db $22
    .db $1C
    .db $00
    .db $00
    .db $00
    .db $42
    .db $7F
    .db $40
    .db $00
    .db $26
    .db $49
    .db $49
    .db $3E
    .db $00
    .db $36
    .db $49
    .db $49
    .db $36
    .db $00
    .db $3E
    .db $41
    .db $41
    .db $3E
DATA_TABLE_TEXT_POS: ; 0x003C61, $CC61
    .db $43 ; fmt: [XX,YY]
    .db $30
    .db $1C
    .db $70
    .db $3C
    .db $70
    .db $5F
    .db $70
    .db $1C
    .db $A8
    .db $40
    .db $A8
    .db $5C
    .db $A8 ; END OF DATA
DATA_TABLE_TEXT_PTRS: ; 0x003C6F, $CC6F
    .db $C0 ; fmt: [ptr]
    .db $EB ; SENTENCE SCANNER
    .db $C0 ; SENTENCE LANDER 100
    .db $DD
    .db $C0 ; SENTENCE MUTANT 150
    .db $DF
    .db $C0 ; SENTENCE BAITER 200
    .db $E7
    .db $C0 ; SENTENCE BOMBER 250
    .db $E3
    .db $C0 ; SENTENCE  POD 1000
    .db $E1
    .db $C0 ; SENTENCE SWARMER 150
    .db $E5 ; END OF DATA
DATA_UNK: ; 0x003C7D, $CC7D
    .db $60 ; V_WORLD after getting shot.
    .db $00
    .db $60
    .db $00
    .db $62
    .db $00
    .db $98
    .db $00
    .db $98
    .db $00
    .db $9A
    .db $00
    .db $F9 ; Enemy BMP PTRS
    .db $85
    .db $F8
    .db $CE
    .db $F9
    .db $A3
    .db $F9
    .db $29
    .db $F8
    .db $F7
    .db $F9
    .db $7B
    .db $09 ; H_WORLD after getting shot
    .db $00
    .db $11
    .db $00
    .db $19
    .db $80
    .db $09
    .db $60
    .db $11
    .db $60
    .db $19
    .db $E0
    .db $44 ; Scanner pixels, [36]
    .db $33
    .db $CC
    .db $33
    .db $33
    .db $33
    .db $88
    .db $88
    .db $CC
    .db $CC
    .db $24
    .db $24
RTN_UPDATE_SCANNER: ; 0x003CAD, $CCAD
    LDU   #$0000 ; Clear value.
    LDB   #$08 ; Data size
    LDX   #$B05D ; PTR to...
LOOP_CLR_PIXELS: ; 0x003CB5, $CCB5
    STU   [X] ; Clear ptrs to scanner.
    STU   [2,X]
    STU   [4,X]
    STU   [6,X]
    ABX ; X+=B
    CMPX  R_A097_SCANNER_DOTS_END_PTR
    BCS   LOOP_CLR_PIXELS ; Loop if not done.
    LDX   [R_A097_SCANNER_DOTS_END_PTR] ; Load val at addr ptr.
    BEQ   X_LOADED_WAS_ZERO
    STU   X ; Clear addr.
    CLR   2,X ; Clear X+2
    STU   -256,X ; Clear X-1 HPOS?
X_LOADED_WAS_ZERO: ; 0x003CD3, $CCD3
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load pos.
    SUBD  #$6D40 ; D -= val
    STD   A073_SCRATCHPAD_ADDR ; To scratch.
    LSRA ; A >> 2, /4? 0 to 63?
    LSRA
    LDU   #$CD69 ; Planet data start.
    LDB   #$03 ; Data size.
    MUL ; D = 0 to 189
    LEAU  D,U ; U += D
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$02 ; Test planet idk.
    BNE   PLANET_DESTROYED_NO_SCANNER
    LDA   #$30 ; X pos.
    LDY   #$B125 ; PTR
PLANET_SCANNER_UPDATE_LOOP: ; 0x003CF0, $CCF0
    LDX   #$0000 ; CLEAR
    STX   [Y] ; Clear current ptr.
    PULU  B,X ; PULL HEIGHT,GFX
    STD   Y ; Update ptr
    STX   [Y++] ; Draw gfx.
    INCA ; A++
    LDX   #$0000 ; Clear again
    STX   [Y] ; Do 2x
    PULU  B,X
    STD   Y
    STX   [Y++]
    INCA
    CMPA  #$70 ; Do 64 times, end of scanner.
    BNE   PLANET_SCANNER_UPDATE_LOOP
PLANET_DESTROYED_NO_SCANNER: ; 0x003D0C, $CD0C
    LDX   #$4C09 ; Scanner
    LDD   #$9090 ; GFX
    STD   X ; Top
    STD   29,X ; Bottom
    LDX   #$5309 ; Scanner
    LDD   #$0909 ; GFX
    STD   X ; Top
    STD   29,X ; Bottom
    LDX   #$A065 ; List, onscreen.
    LDU   #$B05D ; PTR to SCANNER_ENTRIES_START
    BSR   PUT_LIST_TO_SCANNER
    LDX   #$A06B ; List, offscreen.
    BSR   PUT_LIST_TO_SCANNER
    STU   R_A097_SCANNER_DOTS_END_PTR
    LDD   SHIP_SCR_POS_XXYY ; Load ship pos.
    LSRA ; A >> 4
    LSRA
    LSRA
    LSRA
    LSRB ; B >> 3
    LSRB
    LSRB
    ADDD  #$4B07 ; +=TOP_LEFT_POS
    STD   U ; Store D to U, SCR_POS
    LDX   U ; X from U, SCR_POS
    LDD   #$9099 ; GFX
    STD   X ; GFX to X:X+1
    STA   2,X ; GFX to D+2
    LDA   #$09
    STA   -255,X ; To X-1
    RTS ; Leave.
PUT_LIST_TO_SCANNER: ; 0x003D4F, $CD4F
    LDD   10,X ; Load HPOS
    SUBD  A073_SCRATCHPAD_ADDR ; Sub with scratch.
    LSRA ; A >> 2
    LSRA
    LDB   12,X ; B from VPOS?
    LSRB ; B >> 3
    LSRB
    LSRB
    ADDD  #$3007 ; += SCANNER_TOP_LEFT
    STD   U ; D to U, U=PTR_ENTRIES
    LDD   18,X ; GFX FOR SCANNER
    STD   [U++] ; To UPTR, U+=2
PUT_LIST_TO_SCANNER: ; 0x003D64, $CD64
    LDX   X ; X to X.next
    BNE   PUT_LIST_TO_SCANNER ; If more, do.
    RTS ; RTS if not.
SCANNER_PLANET_DATA: ; 0x003D69, $CD69
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07 ; END SCANNER DATA
DATA_UNK_3EE9: ; 0x003EE9, $CEE9
    .db $80 ; Unused probably. Here to end.
    .db $00
    .db $00
    .db $30
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $96
    .db $00
    .db $00
    .db $00
    .db $00
    .db $FE
    .db $C3
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D6
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $39
    .db $00
    .db $06
    .db $66
    .db $66
    .db $88
    .db $68
    .db $66
    .db $66
    .db $66
    .db $88
    .db $88
    .db $88
    .db $00
    .db $60
    .db $63
    .db $30
    .db $63
    .db $00
    .db $06
    .db $26
    .db $68
    .db $28
    .db $60
    .db $66
    .db $66
    .db $86
    .db $00
    .db $00
    .db $66
    .db $66
    .db $00
    .db $00
    .db $ED
    .db $66
    .db $00
    .db $00
    .db $00
    .db $63
    .db $90
    .db $09
    .db $90
    .db $99
    .db $99
    .db $99
    .db $90
    .db $CC
    .db $90
    .db $11
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $10
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $10
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $11
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $FF
    .db $F0
    .db $FF
    .db $00
    .db $FF
    .db $00
    .db $F0
    .db $00
    .db $F0
    .db $F0
    .db $F0
    .db $00
    .db $EE
    .db $E0
    .db $E0
    .db $E0
    .db $EE
    .db $00
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $00
    .db $DD
    .db $D0
    .db $D0
    .db $D0
    .db $DD
    .db $00
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $00
    .db $0F
    .db $0F
    .db $0F
    .db $00
    .db $0F
    .db $00
    .db $FF
    .db $00
    .db $FF
    .db $0F
    .db $FF
    .db $00
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $00
    .db $EE
    .db $0E
    .db $0E
    .db $0E
    .db $EE
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $DD
    .db $0D
    .db $0D
    .db $0D
    .db $DD
    .db $00
    .db $1C
    .db $0D
    .db $7F
    .db $E7
    .db $70
    .db $00
    .db $0F
    .db $71
    .db $71
    .db $07
    .db $DC
    .db $77
    .db $7C
    .db $0D
    .db $71
    .db $C7
    .db $77
    .db $DE
    .db $07
    .db $71
    .db $17
    .db $17
    .db $DE
    .db $F7
    .db $71
    .db $17
    .db $71
    .db $7C
    .db $DE
    .db $F0
    .db $07
    .db $77
    .db $C7
    .db $71
    .db $17
    .db $70
    .db $70
    .db $7C
    .db $D7
    .db $77
    .db $77
    .db $70
    .db $01
    .db $CD
    .db $FF
    .db $D7
    .db $70
    .db $F0
    .db $00
    .db $00
    .db $00 ; End bank.

;Bank 2
	.org $C000

    .db $C5 ; Used in 0x400 area.
    .db $FB
JMP_SENTENCE_TO_SCREEN: ; 0x004002, $C002
    JMP   TEXT_RTN_PTRS=$FFB3/$CAED ; First is on/off screen, second is data handler.
JMP_SENTENCE_CLEARED_FROM_SCREEN: ; 0x004005, $C005
    JMP   TEXT_RTN_PTRS=$FFB6/$CAED ; Callback sentences.
JMP_UNK_TO_SCREEN: ; 0x004008, $C008
    JMP   TEST_RTN_PTRS=$FFB3/$CB5F
JMP_UNK_CLEARED_FROM_SCREEN: ; 0x00400B, $C00B
    JMP   TEXT_RTN_PTRS=$FFB6/$CB5F
JMP_TO_VAL_IN_AB_TO_SCREEN: ; 0x00400E, $C00E
    JMP   TEXT_RTN_PTRS=$FFB3/$CC0F ; To screen, callback char to screen.
JMP_TO_VAL_IN_AB_CLEARED_FROM_SCREEN: ; 0x004011, $C011
    JMP   TEXT_RTN_PTRS=$FFB6/$CC0F ; Cleared from screen.
JMP_UNK_TO_SCREEN: ; 0x004014, $C014
    JMP   TEXT_RTN_PTRS=$FFB3/$CC39
JMP_UNK_CLEARED_FROM_SCREEN: ; 0x004017, $C017
    JMP   TEXT_RTN_PTRS=$FFB6/$CC39
JMP_SPECIAL_FROM_SCREEN: ; 0x00401A, $C01A
    JMP   TEXT_RTN_SPECIAL_PTR=$FFB6
JMP_SPECIAL_CLEARED_FROM_SCREEN: ; 0x00401D, $C01D
    JMP   TEXT_RTN_SPECIAL_PTR=$FFB3
JMP_TEXT_HELPER_STEP_THRU: ; 0x004020, $C020
    JMP   TEXT_CUSTOM_PRESS_ADV_TO_STEP_THRU_TEST
JMP_TEXT_HELPER_SWITCH_FOR: ; 0x004023, $C023
    JMP   TEXT_CUSTOM_PRESS_ADV_WITH_SWITCH_SET_FOR...
    .db $00 ; Seems like padding for more rtn jmps here.
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $5B ; Unk bytes.
    .db $FF
PTRS_TO_SENTENCES: ; 0x004031, $C031
    .db $C0 ; PTR TO SENTENCE AUTO FOR AUDIT, GAME ADJUSTMENT
    .db $BD
    .db $C0 ; PTR to SENTENCE MANUAL FOR ROM TEST
    .db $BF
    .db $C0 ; PTR to SENTENCE AUTO FOR RAM TEST
    .db $C1
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR RAM TEST
    .db $C1
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO TO EXIT TEST
    .db $C3
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR CMOS RAM TEST
    .db $C5
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR CMOS RAM TEST
    .db $C5
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR COLOR RAM TEST
    .db $C7
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO TO EXIT TEST
    .db $C3
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR AUDIO TEST
    .db $C9
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR SWITCH TEST
    .db $CB
    .db $C0 ; PTR to SENTENCE MANUAL TO TEST INDIVIDUAL SOUNDS
    .db $CD
    .db $C0 ; PTR to SENTENCE AUTO FOR MONITOR TEST PATTERNS
    .db $CF
    .db $00
    .db $00
    .db $C0 ; PTR to SENTENCE AUTO FOR AUDIT, GAME ADJUSTMENT
    .db $BD
    .db $C0 ; PTR to SENTENCE MANUAL TO STEP THRU PATTERNS
    .db $D1
    .db $C0 ; PTR to SENTENCE AUTO FOR GAME OVER
    .db $D3
    .db $C0 ; PTR to SENTENCE MANUAL TO STEP THRU ADJUSTMENT
    .db $D5
    .db $C0 ; PTR to SENTENCE PRESS HIGHSCORE RESET TO MAKE CHANGE
    .db $DB
    .db $00
    .db $00
WORD_POINTER_SENTENCE_RANGES: ; 0x004069, $C069
    .db $C1 ; SENTENCE INITIAL TESTS INDICATE
    .db $07
    .db $C1 ; SENTENCE UNIT OK
    .db $0D
    .db $C1 ; SENTENCE ROM
    .db $11
    .db $C1 ; SENTENCE RAM
    .db $13
    .db $C1 ; SENTENCE ROM FAILURE
    .db $15
    .db $C1 ; SENTENCE RAM FAILURE
    .db $19
    .db $C1 ; SENTENCE GAME OVER
    .db $1D
    .db $C1 ; SENTENCE ALL ROMS OK
    .db $21
    .db $C1 ; SENTENCE RAM TEST
    .db $27
    .db $C1 ; SENTENCE NO RAM ERRORS DETECTED
    .db $2B
    .db $C1 ; SENTENCE CMOS RAM FAILURE
    .db $33
    .db $C1 ; SENTENCE CMOS RAM OK
    .db $4D
    .db $C1 ; SENTENCE MULTIPLE RAM FAILURE
    .db $53
    .db $C1 ; SENTENCE COLOR RAM TEST
    .db $6D
    .db $C1 ; SENTENCE AUDIO TEST
    .db $88
    .db $C1 ; SENTENCE SWITCH TEST
    .db $92
    .db $C1 ; SENTENCE MONITOR TEST
    .db $96
    .db $C1 ; SENTENCE AUTO UP
    .db $9C
    .db $C1 ; SENTENCE ADVANCE
    .db $A0
    .db $C1 ; SENTENCE RIGHT COIN
    .db $A2
    .db $C1 ; SENTENCE HIGHSCORE RESET
    .db $A6
    .db $C1 ; SENTENCE LEFT COIN
    .db $A8
    .db $C1 ; SENTENCE CENTER COIN
    .db $AC
    .db $C1 ; SENTENCE INVALID SWITCH
    .db $B0
    .db $C1 ; SENTENCE INVALID SWITCH
    .db $B2
    .db $C1 ; SENTENCE FIRE
    .db $B4
    .db $C1 ; SENTENCE THRUST
    .db $B6
    .db $C1 ; SENTENCE SMART BOMB
    .db $B8
    .db $C1 ; SENTENCE HYPERSPACE
    .db $BC
    .db $C1 ; SENTENCE TWO PLAYERS
    .db $BE
    .db $C1 ; SENTENCE ONE PLAYER
    .db $C2
    .db $C1 ; SENTENCE REVERSE
    .db $C6
    .db $C1 ; SENTENCE DOWN
    .db $C8
    .db $C1 ; SENTENCE UP
    .db $CA
    .db $C1 ; SENTENCE INVALID SWITCH (ALL BLANK BELOW TOO)
    .db $CC
    .db $C1
    .db $CE
    .db $C1
    .db $D0
    .db $C1
    .db $D2
    .db $C1
    .db $D4
    .db $C1
    .db $D6
    .db $C1
    .db $D8
    .db $C1 ; SENTENCE PRESS ADVANCE WITH SWITCH SET FOR [CMD]:
    .db $DA
    .db $C1 ; SENTENCE AUTO FOR AUDIT, GAME ADJUSTMENT
    .db $EA
    .db $C1 ; SENTENCE MANUAL FOR ROM TEST
    .db $F8
    .db $C2 ; SENTENCE AUTO FOR RAM TEST
    .db $00
    .db $C2 ; SENTENCE AUTO TO EXIT TEST
    .db $08
    .db $C2 ; SENTENCE AUTO FOR CMOS RAM TEST
    .db $10
    .db $C2 ; SENTENCE AUTO FOR COLOR RAM TEST
    .db $1A
    .db $C2 ; SENTENCE AUTO FOR AUDIO TEST
    .db $24
    .db $C2 ; SENTENCE AUTO FOR SWITCH TEST
    .db $2C
    .db $C2 ; SENTENCE MANUAL TO TEST INDIVIDUAL SOUNDS
    .db $34
    .db $C2 ; SENTENCE AUTO FOR MONITOR TEST PATTERNS
    .db $3E
    .db $C2 ; SENTENCE MANUAL TO STEP THRU PATTERNS
    .db $48
    .db $C2 ; SENTENCE AUTO FOR GAME OVER
    .db $52
    .db $C2 ; SENTENCE MANUAL TO STEP THRU ADJUSTMENT
    .db $5A
    .db $C2 ; SENTENCE WILLIAMS DEFENDER
    .db $64
    .db $C2 ; SENTENCE PRESS ADVANCE TO STEP THRU TEST
    .db $68
    .db $C2 ; SENTENCE PRESS HIGHSCORE RESET TO MAKE CHANGE
    .db $74
    .db $C2 ; SENTENCE LANDER 100
    .db $7E
    .db $C2 ; SENTENCE MUTANT 150
    .db $85
    .db $C2 ; SENTENCE " POD" 1000
    .db $8C
    .db $C2 ; SENTENCE BOMBER 250
    .db $93
    .db $C2 ; SENTENCE SWARMER 150
    .db $9A
    .db $C2 ; SENTENCE BAITER 200
    .db $A1
    .db $C2 ; SENTENCE CREDITS:
    .db $A8
    .db $C2 ; SENTENCE SCANNER
    .db $AA
    .db $C2 ; SENTENCE ELECTRONICS INC. PRESENTS
    .db $AC
    .db $C2 ; SENTENCE PLAYER ONE
    .db $B4
    .db $C2 ; SENTENCE PLAYER TWO
    .db $B8
    .db $C2 ; SENTENCE BONUS X
    .db $BC
    .db $C2 ; SENTENCE PRESS ONE PLAYER START
    .db $BE
    .db $C2 ; SENTENCE PRESS ONE OR TWO PLAYER START
    .db $C6
    .db $C2 ; SENTENCE ATTACK WAVE
    .db $D2
    .db $C2 ; SENTENCE COMPLETED
    .db $D6
    .db $C2 ; SENTENCE YOU HAVE QUALIFIED FOR...
    .db $D8
    .db $C3 ; SENTENCE PTR TO A000, A002, A004
    .db $01
    .db $C3 ; SENTENCE HALL OF FAME
    .db $0B
    .db $C3 ; SENTENCE PTR TO A006, A008, A00C
    .db $21
WORD_PTR_GROUPS: ; 0x004105, $C105
    .db $C3 ; ADJUSTMENT
    .db $2B
    .db $C4 ; INITIAL
    .db $64
    .db $C5 ; TESTS
    .db $8D
    .db $C4 ; INDICATE
    .db $50
    .db $C5 ; UNIT
    .db $BB
    .db $C4 ; OK
    .db $D1
    .db $C5 ; ROM
    .db $2D
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; ROM
    .db $2D
    .db $C4 ; FAILURE
    .db $04
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $C4 ; GAME
    .db $15
    .db $C4 ; OVER
    .db $E0
    .db $C3 ; ALL
    .db $3E
    .db $C5 ; ROMS
    .db $31
    .db $C4 ; OK
    .db $D1
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C4 ; NO
    .db $CA
    .db $C5 ; RAM
    .db $1B
    .db $C3 ; ERRORS
    .db $F8
    .db $C3 ; DETECTED
    .db $C6
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $06
    .db $28
    .db $A0
    .db $C5 ; TEST
    .db $81
    .db $C4 ; MUST
    .db $AD
    .db $C3 ; BE
    .db $66
    .db $C3 ; ENTERED
    .db $F0
    .db $07
    .db $C5 ; WITH
    .db $DA
    .db $C3 ; COIN
    .db $98
    .db $C3 ; DOOR
    .db $CF
    .db $C4 ; OPEN
    .db $D8
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; OK
    .db $D1
    .db $C4 ; MULTIPLE
    .db $A4
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $03
    .db $FE
    .db $C3 ; ,
    .db $81
    .db $04
    .db $10
    .db $02
    .db $F8
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C3 ; CAN
    .db $7D
    .db $C4 ; NOT
    .db $CD
    .db $C3 ; BE
    .db $66
    .db $C5 ; TESTED
    .db $86
    .db $C3 ; COLOR
    .db $9D
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $04
    .db $30
    .db $02
    .db $E8
    .db $C5 ; VERTICAL
    .db $C3
    .db $C3 ; COLOR
    .db $9D
    .db $C3 ; BARS
    .db $61
    .db $C4 ; INDICATE
    .db $50
    .db $07
    .db $03
    .db $FC
    .db $C3 ; COLOR
    .db $9D
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $C3 ; AUDIO
    .db $49
    .db $C5 ; TEST
    .db $81
    .db $07
    .db $07
    .db $03
    .db $04
    .db $C5 ; SOUND
    .db $54
    .db $C5 ; SWITCH
    .db $7A
    .db $C5 ; TEST
    .db $81
    .db $C4 ; MONITOR
    .db $9C
    .db $C5 ; TEST
    .db $81
    .db $C4 ; PATTERNS
    .db $E5
    .db $C3 ; AUTO
    .db $55
    .db $C5 ; UP
    .db $C0
    .db $C3 ; ADVANCE
    .db $36
    .db $C5 ; RIGHT
    .db $27
    .db $C3 ; COIN
    .db $98
    .db $C4 ; HIGHSCORE RESET
    .db $35
    .db $C4 ; LEFT
    .db $8B
    .db $C3 ; COIN
    .db $98
    .db $C3 ; CENTER
    .db $85
    .db $C3 ; COIN
    .db $98
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; FIRE
    .db $0C
    .db $C5 ; THRUST
    .db $9C
    .db $C5 ; SMART
    .db $4E
    .db $C3 ; BOMB
    .db $69
    .db $C4 ; HYPERSPACE
    .db $45
    .db $C5 ; TWO
    .db $B7
    .db $C4 ; PLAYERS
    .db $F5
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; REVERSE
    .db $1F
    .db $C3 ; DOWN
    .db $D4
    .db $C5 ; UP
    .db $C0
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C5 ; PRESS
    .db $0B
    .db $C3 ; ADVANCE
    .db $36
    .db $C5 ; WITH
    .db $DA
    .db $C5 ; SWITCH
    .db $7A
    .db $C5 ; SET
    .db $45
    .db $C4 ; FOR
    .db $11
    .db $03
    .db $FE
    .db $C3 ; :
    .db $83
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; AUDIT
    .db $4F
    .db $03
    .db $FE
    .db $C3 ; ,
    .db $81
    .db $C4 ; GAME
    .db $15
    .db $C3 ; ADJUSTMENT
    .db $2B
    .db $C4 ; MANUAL
    .db $95
    .db $C4 ; FOR
    .db $11
    .db $C5 ; ROM
    .db $2D
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C5 ; TO
    .db $AD
    .db $C3 ; EXIT
    .db $FF
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; COLOR
    .db $9D
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; AUDIO
    .db $49
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C5 ; SWITCH
    .db $7A
    .db $C5 ; TEST
    .db $81
    .db $C4 ; MANUAL
    .db $95
    .db $C5 ; TO
    .db $AD
    .db $C5 ; TEST
    .db $81
    .db $C4 ; INDIVIDUAL
    .db $59
    .db $C5 ; SOUNDS
    .db $5A
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C4 ; MONITOR
    .db $9C
    .db $C5 ; TEST
    .db $81
    .db $C4 ; PATTERNS
    .db $E5
    .db $C4 ; MANUAL
    .db $95
    .db $C5 ; TO
    .db $AD
    .db $C5 ; STEP
    .db $67
    .db $C5 ; THRU
    .db $97
    .db $C4 ; PATTERNS
    .db $E5
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C4 ; GAME
    .db $15
    .db $C4 ; OVER
    .db $E0
    .db $C4 ; MANUAL
    .db $95
    .db $C5 ; TO
    .db $AD
    .db $C5 ; STEP
    .db $67
    .db $C5 ; THRU
    .db $97
    .db $C3 ; ADJUSTMENT
    .db $2B
    .db $C5 ; WILLIAMS
    .db $D1
    .db $C3 ; DEFENDER
    .db $BD
    .db $C5 ; PRESS
    .db $0B
    .db $C3 ; ADVANCE
    .db $36
    .db $C5 ; TO
    .db $AD
    .db $C5 ; STEP
    .db $67
    .db $C5 ; THRU
    .db $97
    .db $C5 ; TEST
    .db $81
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; HIGHSCORE RESET
    .db $35
    .db $C5 ; TO
    .db $AD
    .db $C4 ; MAKE
    .db $90
    .db $C3 ; CHANGE
    .db $8C
    .db $C4 ; LANDER
    .db $84
    .db $07
    .db $03
    .db $06
    .db $C4 ; 150
    .db $B9
    .db $C4 ; MUTANT
    .db $B2
    .db $07
    .db $03
    .db $06
    .db $C4 ; 150
    .db $B9
    .db $C4 ; " POD"
    .db $FD
    .db $07
    .db $03
    .db $00
    .db $C4 ; 1000
    .db $C5
    .db $C3 ; BOMBER
    .db $6E
    .db $07
    .db $03
    .db $06
    .db $C4 ; 250
    .db $C1
    .db $C5 ; SWARMER
    .db $72
    .db $07
    .db $03
    .db $08
    .db $C4 ; 150
    .db $B9
    .db $C3 ; BAITER
    .db $5A
    .db $07
    .db $03
    .db $06
    .db $C4 ; 200
    .db $BD
    .db $C3 ; CREDITS:
    .db $B4
    .db $C5 ; SCANNER
    .db $36
    .db $C3 ; ELECTRONICS INC.
    .db $D9
    .db $07
    .db $07
    .db $03
    .db $0C
    .db $C5 ; PRESENTS
    .db $02
    .db $C4 ; PLAYER
    .db $EE
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; TWO
    .db $B7
    .db $C3 ; BONUS X
    .db $75
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; START
    .db $61
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; OR
    .db $DD
    .db $C5 ; TWO
    .db $B7
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; START
    .db $61
    .db $C3 ; ATTACK
    .db $42
    .db $C5 ; WAVE
    .db $CC
    .db $C3 ; COMPLETED
    .db $A3
    .db $C5 ; YOU
    .db $DF
    .db $C4 ; HAVE
    .db $30
    .db $C5 ; QUALIFIED
    .db $11
    .db $C4 ; FOR
    .db $11
    .db $07
    .db $C5 ; THE
    .db $93
    .db $C3 ; DEFENDER
    .db $BD
    .db $C4 ; HALL OF FAME
    .db $23
    .db $07
    .db $07
    .db $C5 ; SELECT
    .db $3E
    .db $C4 ; INITIALS
    .db $6C
    .db $C5 ; WITH
    .db $DA
    .db $C5 ; UP
    .db $C0
    .db $C3 ; DOWN
    .db $D4
    .db $C5 ; STICK
    .db $6C
    .db $07
    .db $07
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; FIRE
    .db $0C
    .db $C5 ; TO
    .db $AD
    .db $C3 ; ENTER
    .db $EA
    .db $C4 ; INITIAL
    .db $64
    .db $A0 ; PTR to $A000
    .db $00
    .db $02
    .db $08
    .db $A0 ; PTR to $A002
    .db $02
    .db $02
    .db $10
    .db $A0 ; PTR to $A004
    .db $04
    .db $C4 ; HALL OF FAME
    .db $23
    .db $06
    .db $22
    .db $68
    .db $C5 ; TODAYS
    .db $B0
    .db $02
    .db $3E
    .db $C3 ; ALL
    .db $3E
    .db $C5 ; TIME
    .db $A8
    .db $07
    .db $03
    .db $FC
    .db $C4 ; GREATEST
    .db $1A
    .db $02
    .db $3D
    .db $C4 ; GREATEST
    .db $1A
    .db $A0 ; PTR to $A006
    .db $06
    .db $02
    .db $05
    .db $A0 ; PTR to $A008
    .db $08
    .db $02
    .db $13
    .db $A0 ; PTR to $A00C
    .db $0C
WORDS_RAW_BYTES: ; 0x00432B, $C32B
    .db $41 ; ADJUSTMENT
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $4D
    .db $45
    .db $4E
    .db $54
    .db $2F
    .db $41 ; ADVANCE
    .db $44
    .db $56
    .db $41
    .db $4E
    .db $43
    .db $45
    .db $2F
    .db $41 ; ALL
    .db $4C
    .db $4C
    .db $2F
    .db $41 ; ATTACK
    .db $54
    .db $54
    .db $41
    .db $43
    .db $4B
    .db $2F
    .db $41 ; AUDIO
    .db $55
    .db $44
    .db $49
    .db $4F
    .db $2F
    .db $41 ; AUDIT
    .db $55
    .db $44
    .db $49
    .db $54
    .db $2F
    .db $41 ; AUTO
    .db $55
    .db $54
    .db $4F
    .db $2F
    .db $42 ; BAITER
    .db $41
    .db $49
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $42 ; BARS
    .db $41
    .db $52
    .db $53
    .db $2F
    .db $42 ; BE
    .db $45
    .db $2F
    .db $42 ; BOMB
    .db $4F
    .db $4D
    .db $42
    .db $2F
    .db $42 ; BOMBER
    .db $4F
    .db $4D
    .db $42
    .db $45
    .db $52
    .db $2F
    .db $42 ; BONUS X
    .db $4F
    .db $4E
    .db $55
    .db $53
    .db $20
    .db $58
    .db $2F
    .db $43 ; CAN
    .db $41
    .db $4E
    .db $2F
    .db $2C ; ,
    .db $2F
    .db $3A ; :
    .db $2F
    .db $43 ; Center
    .db $45
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $43 ; Change
    .db $48
    .db $41
    .db $4E
    .db $47
    .db $45
    .db $2F
    .db $43 ; CMOS
    .db $4D
    .db $4F
    .db $53
    .db $2F
    .db $43 ; Coin
    .db $4F
    .db $49
    .db $4E
    .db $2F
    .db $43 ; Color
    .db $4F
    .db $4C
    .db $4F
    .db $52
    .db $2F
    .db $43 ; Completed
    .db $4F
    .db $4D
    .db $50
    .db $4C
    .db $45
    .db $54
    .db $45
    .db $44
    .db $2F
    .db $43 ; Credit
    .db $52
    .db $45
    .db $44
    .db $49
    .db $54
    .db $2F
    .db $43 ; Credits:
    .db $52
    .db $45
    .db $44
    .db $49
    .db $54
    .db $53
    .db $3A
    .db $2F
    .db $44 ; Defender
    .db $45
    .db $46
    .db $45
    .db $4E
    .db $44
    .db $45
    .db $52
    .db $2F
    .db $44 ; Detected
    .db $45
    .db $54
    .db $45
    .db $43
    .db $54
    .db $45
    .db $44
    .db $2F
    .db $44 ; Door
    .db $4F
    .db $4F
    .db $52
    .db $2F
    .db $44 ; Down
    .db $4F
    .db $57
    .db $4E
    .db $2F
    .db $45 ; Electronics Inc.
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $52
    .db $4F
    .db $4E
    .db $49
    .db $43
    .db $53
    .db $20
    .db $49
    .db $4E
    .db $43
    .db $2E
    .db $2F
    .db $45 ; Enter
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $45 ; Entered
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $45
    .db $44
    .db $2F
    .db $45 ; Errors
    .db $52
    .db $52
    .db $4F
    .db $52
    .db $53
    .db $2F
    .db $45 ; Exit
    .db $58
    .db $49
    .db $54
    .db $2F
    .db $46 ; Failure
    .db $41
    .db $49
    .db $4C
    .db $55
    .db $52
    .db $45
    .db $2F
    .db $46 ; Fire
    .db $49
    .db $52
    .db $45
    .db $2F
    .db $46 ; For
    .db $4F
    .db $52
    .db $2F
    .db $47 ; Game
    .db $41
    .db $4D
    .db $45
    .db $2F
    .db $47 ; Greatest
    .db $52
    .db $45
    .db $41
    .db $54
    .db $45
    .db $53
    .db $54
    .db $2F
    .db $48 ; Hall of Fame
    .db $41
    .db $4C
    .db $4C
    .db $20
    .db $4F
    .db $46
    .db $20
    .db $46
    .db $41
    .db $4D
    .db $45
    .db $2F
    .db $48 ; Have
    .db $41
    .db $56
    .db $45
    .db $2F
    .db $48 ; Highscore Reset
    .db $49
    .db $47
    .db $48
    .db $53
    .db $43
    .db $4F
    .db $52
    .db $45
    .db $20
    .db $52
    .db $45
    .db $53
    .db $45
    .db $54
    .db $2F
    .db $48 ; Hyperspace
    .db $59
    .db $50
    .db $45
    .db $52
    .db $53
    .db $50
    .db $41
    .db $43
    .db $45
    .db $2F
    .db $49 ; Indicate
    .db $4E
    .db $44
    .db $49
    .db $43
    .db $41
    .db $54
    .db $45
    .db $2F
    .db $49 ; Individual
    .db $4E
    .db $44
    .db $49
    .db $56
    .db $49
    .db $44
    .db $55
    .db $41
    .db $4C
    .db $2F
    .db $49 ; Initial
    .db $4E
    .db $49
    .db $54
    .db $49
    .db $41
    .db $4C
    .db $2F
    .db $49 ; Initials
    .db $4E
    .db $49
    .db $54
    .db $49
    .db $41
    .db $4C
    .db $53
    .db $2F
    .db $49 ; Invalid Switch
    .db $4E
    .db $56
    .db $41
    .db $4C
    .db $49
    .db $44
    .db $20
    .db $53
    .db $57
    .db $49
    .db $54
    .db $43
    .db $48
    .db $2F
    .db $4C ; Lander
    .db $41
    .db $4E
    .db $44
    .db $45
    .db $52
    .db $2F
    .db $4C ; Left
    .db $45
    .db $46
    .db $54
    .db $2F
    .db $4D ; Make
    .db $41
    .db $4B
    .db $45
    .db $2F
    .db $4D ; Manual
    .db $41
    .db $4E
    .db $55
    .db $41
    .db $4C
    .db $2F
    .db $4D ; Monitor
    .db $4F
    .db $4E
    .db $49
    .db $54
    .db $4F
    .db $52
    .db $2F
    .db $4D ; Multiple
    .db $55
    .db $4C
    .db $54
    .db $49
    .db $50
    .db $4C
    .db $45
    .db $2F
    .db $4D ; Must
    .db $55
    .db $53
    .db $54
    .db $2F
    .db $4D ; Mutant
    .db $55
    .db $54
    .db $41
    .db $4E
    .db $54
    .db $2F
    .db $31 ; 150
    .db $35
    .db $30
    .db $2F
    .db $32 ; 200
    .db $30
    .db $30
    .db $2F
    .db $32 ; 250
    .db $35
    .db $30
    .db $2F
    .db $31 ; 1000
    .db $30
    .db $30
    .db $30
    .db $2F
    .db $4E ; No
    .db $4F
    .db $2F
    .db $4E ; Not
    .db $4F
    .db $54
    .db $2F
    .db $4F ; OK
    .db $4B
    .db $2F
    .db $4F ; One
    .db $4E
    .db $45
    .db $2F
    .db $4F ; Open
    .db $50
    .db $45
    .db $4E
    .db $2F
    .db $4F ; Or
    .db $52
    .db $2F
    .db $4F ; Over
    .db $56
    .db $45
    .db $52
    .db $2F
    .db $50 ; Patterns
    .db $41
    .db $54
    .db $54
    .db $45
    .db $52
    .db $4E
    .db $53
    .db $2F
    .db $50 ; Player
    .db $4C
    .db $41
    .db $59
    .db $45
    .db $52
    .db $2F
    .db $50 ; Players
    .db $4C
    .db $41
    .db $59
    .db $45
    .db $52
    .db $53
    .db $2F
    .db $20 ; " POD"
    .db $50
    .db $4F
    .db $44
    .db $2F
    .db $50 ; Presents
    .db $52
    .db $45
    .db $53
    .db $45
    .db $4E
    .db $54
    .db $53
    .db $2F
    .db $50 ; Press
    .db $52
    .db $45
    .db $53
    .db $53
    .db $2F
    .db $51 ; Qualified
    .db $55
    .db $41
    .db $4C
    .db $49
    .db $46
    .db $49
    .db $45
    .db $44
    .db $2F
    .db $52 ; RAM
    .db $41
    .db $4D
    .db $2F
    .db $52 ; Reverse
    .db $45
    .db $56
    .db $45
    .db $52
    .db $53
    .db $45
    .db $2F
    .db $52 ; Right
    .db $49
    .db $47
    .db $48
    .db $54
    .db $2F
    .db $52 ; ROM
    .db $4F
    .db $4D
    .db $2F
    .db $52 ; ROMS
    .db $4F
    .db $4D
    .db $53
    .db $2F
    .db $53 ; Scanner
    .db $43
    .db $41
    .db $4E
    .db $4E
    .db $45
    .db $52
    .db $2F
    .db $53 ; Select
    .db $45
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $2F
    .db $53 ; Set
    .db $45
    .db $54
    .db $2F
    .db $53 ; Slam
    .db $4C
    .db $41
    .db $4D
    .db $2F
    .db $53 ; Smart
    .db $4D
    .db $41
    .db $52
    .db $54
    .db $2F
    .db $53 ; Sound
    .db $4F
    .db $55
    .db $4E
    .db $44
    .db $2F
    .db $53 ; Sounds
    .db $4F
    .db $55
    .db $4E
    .db $44
    .db $53
    .db $2F
    .db $53 ; Start
    .db $54
    .db $41
    .db $52
    .db $54
    .db $2F
    .db $53 ; Step
    .db $54
    .db $45
    .db $50
    .db $2F
    .db $53 ; Stick
    .db $54
    .db $49
    .db $43
    .db $4B
    .db $2F
    .db $53 ; Swarmer
    .db $57
    .db $41
    .db $52
    .db $4D
    .db $45
    .db $52
    .db $2F
    .db $53 ; Switch
    .db $57
    .db $49
    .db $54
    .db $43
    .db $48
    .db $2F
    .db $54 ; Test
    .db $45
    .db $53
    .db $54
    .db $2F
    .db $54 ; Tested
    .db $45
    .db $53
    .db $54
    .db $45
    .db $44
    .db $2F
    .db $54 ; Tests
    .db $45
    .db $53
    .db $54
    .db $53
    .db $2F
    .db $54 ; The
    .db $48
    .db $45
    .db $2F
    .db $54 ; Thru
    .db $48
    .db $52
    .db $55
    .db $2F
    .db $54 ; Thrust
    .db $48
    .db $52
    .db $55
    .db $53
    .db $54
    .db $2F
    .db $54 ; Tilt
    .db $49
    .db $4C
    .db $54
    .db $2F
    .db $54 ; Time
    .db $49
    .db $4D
    .db $45
    .db $2F
    .db $54 ; To
    .db $4F
    .db $2F
    .db $54 ; Todays
    .db $4F
    .db $44
    .db $41
    .db $59
    .db $53
    .db $2F
    .db $54 ; Two
    .db $57
    .db $4F
    .db $2F
    .db $55 ; Unit
    .db $4E
    .db $49
    .db $54
    .db $2F
    .db $55 ; Up
    .db $50
    .db $2F
    .db $56 ; Vertical
    .db $45
    .db $52
    .db $54
    .db $49
    .db $43
    .db $41
    .db $4C
    .db $2F
    .db $57 ; Wave
    .db $41
    .db $56
    .db $45
    .db $2F
    .db $57 ; Williams
    .db $49
    .db $4C
    .db $4C
    .db $49
    .db $41
    .db $4D
    .db $53
    .db $2F
    .db $57 ; With
    .db $49
    .db $54
    .db $48
    .db $2F
    .db $59 ; You
    .db $4F
    .db $55
    .db $2F
TEXT_GRAPHICS_INFO: ; 0x0045E3, $C5E3
    .db $01 ; FORMAT:[X_BYTES,Y,BMP_PTR], to get pixels X*2
    .db $08
    .db $C6 ; PTR 0
    .db $97
    .db $01
    .db $08
    .db $C6 ; PTR 1
    .db $AF
    .db $01
    .db $08
    .db $C6 ; PTR 2
    .db $B7
    .db $03
    .db $08
    .db $C7 ; PTR 3
    .db $BF
    .db $01
    .db $08
    .db $C6 ; PTR 4
    .db $BF
    .db $03
    .db $08
    .db $C7 ; PTR 5
    .db $BF
    .db $03
    .db $08
    .db $C6 ; PTR 6
    .db $C7
    .db $03
    .db $08
    .db $C6 ; PTR 7
    .db $DF
    .db $03
    .db $08
    .db $C6 ; PTR 8
    .db $F7
    .db $03
    .db $08
    .db $C7 ; PTR 9
    .db $0F
    .db $03
    .db $08
    .db $C7 ; PTR 10
    .db $27
    .db $03
    .db $08
    .db $C7 ; PTR 11
    .db $3F
    .db $03
    .db $08
    .db $C7 ; PTR 12
    .db $57
    .db $03
    .db $08
    .db $C7 ; PTR 13
    .db $6F
    .db $03
    .db $08
    .db $C7 ; PTR 14
    .db $87
    .db $03
    .db $08
    .db $C7 ; PTR 15
    .db $9F
    .db $01
    .db $08
    .db $C7 ; PTR 16
    .db $B7
    .db $03
    .db $08
    .db $C7 ; PTR 17
    .db $BF
    .db $03
    .db $08
    .db $C6 ; PTR 18
    .db $97
    .db $03
    .db $08
    .db $C7 ; PTR 19
    .db $D7
    .db $03
    .db $08
    .db $C7 ; PTR 20
    .db $EF
    .db $03
    .db $08
    .db $C8 ; PTR 21
    .db $07
    .db $03
    .db $08
    .db $C8 ; PTR 22
    .db $1F
    .db $03
    .db $08
    .db $C8 ; PTR 23
    .db $37
    .db $03
    .db $08
    .db $C8 ; PTR 24
    .db $4F
    .db $03
    .db $08
    .db $C8 ; PTR 25
    .db $67
    .db $03
    .db $08
    .db $C8 ; PTR 26
    .db $7F
    .db $02
    .db $08
    .db $C8 ; PTR 27
    .db $97
    .db $03
    .db $08
    .db $C8 ; PTR 28
    .db $A7
    .db $03
    .db $08
    .db $C8 ; PTR 29
    .db $BF
    .db $03
    .db $08
    .db $C8 ; PTR 30
    .db $D7
    .db $04
    .db $08
    .db $C8 ; PTR 31
    .db $EF
    .db $03
    .db $08
    .db $C9 ; PTR 32
    .db $0F
    .db $03
    .db $08
    .db $C9 ; PTR 33
    .db $27
    .db $03
    .db $08
    .db $C9 ; PTR 34
    .db $3F
    .db $03
    .db $08
    .db $C9 ; PTR 35
    .db $57
    .db $03
    .db $08
    .db $C9 ; PTR 36
    .db $6F
    .db $03
    .db $08
    .db $C9 ; PTR 37
    .db $87
    .db $03
    .db $08
    .db $C9 ; PTR 38
    .db $9F
    .db $03
    .db $08
    .db $C9 ; PTR 39
    .db $B7
    .db $03
    .db $08
    .db $C9 ; PTR 40
    .db $CF
    .db $04
    .db $08
    .db $C9 ; PTR 41
    .db $E7
    .db $03
    .db $08
    .db $CA ; PTR 42
    .db $07
    .db $03
    .db $08
    .db $CA ; PTR 43
    .db $1F
    .db $03
    .db $08
    .db $CA ; PTR 44
    .db $37
TEXT_BITMAP_LIBRARY: ; 0x004697, $C697
    .db $00 ; TEXT_BITMAP_0,18
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_1
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $00 ; TEXT_BITMAP_2
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $10
    .db $00 ; TEXT_BITMAP_4
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_6
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $00 ; TEXT_BITMAP_7
    .db $00
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_8
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $01
    .db $10
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_9
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $00 ; TEXT_BITMAP_10
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $10
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_11
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_12
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_13
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $01
    .db $11
    .db $10
    .db $10
    .db $00
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_14
    .db $01
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $10
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_15
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $00 ; TEXT_BITMAP_16
    .db $00
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_3,5,17
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_19
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_20
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_21
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_22
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $10
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $01 ; TEXT_BITMAP_23
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $10
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_24
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $00
    .db $00
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_25
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_26
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $01
    .db $01
    .db $01
    .db $11
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_27
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $00 ; TEXT_BITMAP_28
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_29
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $11
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $10
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_30
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_31
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_32
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_33
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_34
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_35
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $01
    .db $11
    .db $11
    .db $10
    .db $01 ; TEXT_BITMAP_36
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $10
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_37
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $11 ; TEXT_BITMAP_38
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_39
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_40
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $10
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_41
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_42
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $10
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $10
    .db $00
    .db $10
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_43
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $01
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_44
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $01
    .db $10
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $84
    .db $FF
TEXT_CUSTOM_PRESS_ADV_TO_STEP_THRU_TEST: ; 0x004A51, $CA51
    PSHS  U,Y,X ; Save...
    LDU   #$C0D9 ; Sentences ptr start.
    BRA   DO_TEXT_SOMETHING
TEXT_CUSTOM_PRESS_ADV_WITH_SWITCH_SET_FOR...: ; 0x004A58, $CA58
    PSHS  U,Y,X ; Save...
    LDU   #$C0BB ; Sentence PRESS SWITCH WITH ADVANCED SET FOR (CMD)
DO_TEXT_SOMETHING: ; 0x004A5D, $CA5D
    LDX   #$18CE ; Screen position.
    JSR   TEXT_RTN_PTRS=$FFB3/$CAED ; Something to screen.
    LDU   Y++ ; ptr from Y
    BEQ   LOADED_NULL ; If was null, taken.
    LDX   #$10DA ; Screen location.
    JSR   TEXT_RTN_PTRS=$FFB3/$CAED ; Something to screen.
LOADED_NULL: ; 0x004A6D, $CA6D
    LDU   Y++ ; Get U from Y again.
    BEQ   LOADED_NULL_2 ; If was null, taken.
    LDX   #$10E4 ; Position.
    JSR   TEXT_RTN_PTRS=$FFB3/$CAED ; Something to screen.
LOADED_NULL_2: ; 0x004A77, $CA77
    PULS  X,Y,U,PC ; Restore+RTS
TEXT_RTN_SPECIAL_PTR=$FFB6: ; 0x004A79, $CA79
    PSHS  U,Y,X,B,A,CC ; Save state
    LDY   #$FFB6 ; Ptr to clear sentence.
    BRA   TEXT_RTN_UNK_MAIN
TEXT_RTN_SPECIAL_PTR=$FFB3: ; 0x004A81, $CA81
    PSHS  U,Y,X,B,A,CC ; Save state
    LDY   #$FFB3 ; PTR to display sentence.
TEXT_RTN_UNK_MAIN: ; 0x004A87, $CA87
    LDD   #$CAED ; PTR to SKIP_SENTENCE_INIT
    STY   TEXT_PTR_TO_CODE_JSR ; Store JSR PTR
    STD   TEXT_PTR_TO_CODE_JMP ; Store JMP PTR
    STX   SENTENCE_CURR_SCR_LOC_XXYY ; Store SCR_LOC
    STX   SENTENCE_CURR_SCR_LOC_CR_XXYY? ; Store SCR_LOC_CR
    LDX   #$010A ; Spacing value.
    STX   TEXT_DATA_SPACING_XXYY?
    CLR   SENTENCE_FLAG_58 ; Clear flag.
    LDU   5,S ; Get Y value passed to special rtn.
    STU   SENTENCE_PTR_TO_WORD ; Is ptr to word.
    LEAU  32,U ; End ptr, 32 chars bytes more than start.
    STU   SENTENCE_END_PTR ; Store the stack as the end ptr?
    STU   SENTENCE_PTR_WORD_ON ; And the word on?
    BRA   SKIP_SENTENCE_INIT ; Goto code
TEXT_RTN_PTRS=$FFB3/$CAED: ; 0x004AA7, $CAA7
    PSHS  U,Y,X,B,A,CC ; Save
    LDY   #$FFB3 ; JSR ptr, JMP to TEXT_CHAR_TO_SCREEN
    LDD   #$CAED ; JMP ptr, SKIP_SENTENCE_INIT
    BRA   SENTENCE_TO_SCREEN
TEXT_RTN_PTRS=$FFB6/$CAED: ; 0x004AB2, $CAB2
    PSHS  U,Y,X,B,A,CC
    LDY   #$FFB6 ; PTR to JMP unk
    LDD   #$CAED
    BRA   SENTENCE_TO_SCREEN
TEST_RTN_PTRS=$FFB3/$CB5F: ; 0x004ABD, $CABD
    PSHS  U,Y,X,B,A,CC
    LDY   #$FFB3 ; PTR to JMP unk
    LDD   #$CB5F ; PTR to 4B5F, Pulls state, clears a CC bit, RTS's.
    BRA   SENTENCE_TO_SCREEN
TEXT_RTN_PTRS=$FFB6/$CB5F: ; 0x004AC8, $CAC8
    PSHS  U,Y,X,B,A,CC ; Save stuff
    LDY   #$FFB6
    LDD   #$CB5F
SENTENCE_TO_SCREEN: ; 0x004AD1, $CAD1
    STY   TEXT_PTR_TO_CODE_JSR ; Store ptr JSR'd to.
    STD   TEXT_PTR_TO_CODE_JMP ; Store ptr to JMP.
    TST   SENTENCE_PTR_WORD_ON ; Test if top byte not null
    BNE   SKIP_SENTENCE_INIT ; If is set, don't init.
    STX   SENTENCE_CURR_SCR_LOC_XXYY ; Screen location current
    STX   SENTENCE_CURR_SCR_LOC_CR_XXYY? ; Screen location when carriage returned (CR)
    LDX   #$010A ; Not sure of val. Add per char?
    STX   TEXT_DATA_SPACING_XXYY? ; Store
    CLR   SENTENCE_FLAG_58 ; Clear
    LDX   2,U ; Get end of sentence.
    STX   SENTENCE_END_PTR ; End of sentence.
    LDX   U ; Load X with beginning of sentence.
    BRA   MORE_THINGS_TO_DO ; Do things.
SKIP_SENTENCE_INIT: ; 0x004AED, $CAED
    TST   SENTENCE_FLAG_58 ; Test
    BNE   FLAG_58_SET
    LDX   SENTENCE_PTR_TO_WORD ; Get word ptr
    LDB   X+ ; Load
    CMPB  #$2F ; #$2F='\0' here.
    BNE   NOT_END_OF_STRING ; Not end, put to screen.
    LDB   #$20 ; Space in ascii, probs just flag value tho.
    STB   SENTENCE_FLAG_58 ; Not sure why stored.
    BRA   NOT_END_OF_STRING ; Always space at end.
FLAG_58_SET: ; 0x004AFF, $CAFF
    CLR   SENTENCE_FLAG_58 ; clear
    LDX   SENTENCE_PTR_WORD_ON
DO_MORE_AFTER_CMD: ; 0x004B03, $CB03
    CMPX  SENTENCE_END_PTR ; Compare to end?
    BNE   MORE_THINGS_TO_DO
RTS_DOES_EXTRAS: ; 0x004B07, $CB07
    CLR   SENTENCE_PTR_WORD_ON ; Clear setup check loc.
    PULS  CC,A,B,X,Y,U ; Restore
    ORCC  #$01 ; Set CC.c
    RTS ; leave.
MORE_THINGS_TO_DO: ; 0x004B0E, $CB0E
    LDU   X++ ; Loads sentence word ptr.
    BMI   POINTER_IS_IN_ROM ; If in ROM/scratch, will be above 0x8000.
    LEAX  -1,X ; Not PTR, command, minus 1 because CMD is byte.
    TFR   U>D ; U loaded to D
    CMPA  #$08 ; A contains command.
    BHI   RTS_DOES_EXTRAS ; Leaves if invalid.
    ASLA ; Make index val by doubling.
    LDY   #$CB64 ; ptr
    JSR   [A,Y] ; Run code.
    BRA   DO_MORE_AFTER_CMD
POINTER_IS_IN_ROM: ; 0x004B23, $CB23
    STX   SENTENCE_PTR_WORD_ON ; Store index into sentence, aka word
    STU   SENTENCE_PTR_TO_WORD ; Store word ptr
    BRA   SKIP_SENTENCE_INIT ; Goto
NOT_END_OF_STRING: ; 0x004B29, $CB29
    STX   SENTENCE_PTR_TO_WORD ; Store index into word.
    SUBB  #$20 ; B-=20
    CMPB  #$01 ; CMP 0x20-0x21
    BLS   TEXT_CASE_USE_B ; If <=21
    CMPB  #$0B
    BLS   TEXT_CASE_USE_3 ; Misc ascii. Control chars?
    SUBB  #$0A ; B-=0x2A
    CMPB  #$10 ; CMP 0x2A to 0x3A
    BLS   TEXT_CASE_USE_B ; if <=
    CMPB  #$14 ; CMP 0x3B to 0x3E
    BLS   TEXT_CASE_USE_3 ; if <=
    SUBB  #$04 ; B-=2E
    CMPB  #$2C ; CMP 0x2E to 5A
    BLS   TEXT_CASE_USE_B
TEXT_CASE_USE_3: ; 0x004B45, $CB45
    LDB   #$03 ; Turns to 0xC
TEXT_CASE_USE_B: ; 0x004B47, $CB47
    ASLB ; Multiply by 4
    ASLB
    LDX   #$C5E3 ; TEXT_POINTER_START
    ABX ; Add to X
    TFR   X>Y ; Put to Y
    LDD   SENTENCE_CURR_SCR_LOC_XXYY ; Load screen location
    LDX   TEXT_PTR_TO_CODE_JSR ; Load ptr to code
    JSR   X ; JSR to ptr
    ADDA  Y ; Add to A@Y
    ADDA  TEXT_DATA_SPACING_XXYY? ; Add to A from mem. Minimum movement?
    STA   SENTENCE_CURR_SCR_LOC_XXYY ; Store high byte. Horizontal pos?
    LDX   TEXT_PTR_TO_CODE_JMP ; Load...
    JMP   X ; JMP to loc.
    PULS  CC,A,B,X,Y,U ; PTR'd code. Pull state.
    ANDCC #$FE ; Clear CC.C
    RTS ; RTS
TEXT_FUNCTION_POINTERS: ; 0x004B64, $CB64
    .db $CB ; FORMAT: [ptr], points to code after table. Text functions.
    .db $76
    .db $CB
    .db $7B
    .db $CB
    .db $80
    .db $CB
    .db $87
    .db $CB
    .db $8E
    .db $CB
    .db $95
    .db $CB
    .db $9C
    .db $CB
    .db $A3
    .db $CB
    .db $AC
TEXT_FUNC_CHANGE_SPACING_X: ; 0x004B76, $CB76
    LDA   X+ ; These functions called by table above front str/text routine
    STA   TEXT_DATA_SPACING_XXYY?
    RTS
TEXT_FUNC_CHANGE_SPACING_Y: ; 0x004B7B, $CB7B
    LDB   X+
    STB   TEXT_DATA_SPACING_XXYY?+1
    RTS
TEXT_FUNC_CR.X+DATA_TO_POSX: ; 0x004B80, $CB80
    LDA   SENTENCE_CURR_SCR_LOC_CR_XXYY?
    ADDA  X+
    STA   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_POS.X+=DATA: ; 0x004B87, $CB87
    LDA   SENTENCE_CURR_SCR_LOC_XXYY
    ADDA  X+
    STA   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_CR.Y+DATA_TO_POSY: ; 0x004B8E, $CB8E
    LDB   SENTENCE_CURR_SCR_LOC_CR_XXYY?+1
    ADDB  X+
    STB   SENTENCE_CURR_SCR_LOC_XXYY+1
    RTS
TEXT_FUNC_POS.Y+=DATA: ; 0x004B95, $CB95
    LDB   SENTENCE_CURR_SCR_LOC_XXYY+1
    ADDB  X+
    STB   SENTENCE_CURR_SCR_LOC_XXYY+1
    RTS
TEXT_FUNC_DATA_TO_CR+POS: ; 0x004B9C, $CB9C
    LDD   X++
    STD   SENTENCE_CURR_SCR_LOC_CR_XXYY?
    STD   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_CR: ; 0x004BA3, $CBA3
    LDA   SENTENCE_CURR_SCR_LOC_CR_XXYY?
    LDB   SENTENCE_CURR_SCR_LOC_XXYY+1
    ADDB  TEXT_DATA_SPACING_XXYY?+1
    STD   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_JSR_ADD_JMP_IDK: ; 0x004BAC, $CBAC
    LDY   X++ ; Y from X
    STX   SENTENCE_PTR_WORD_ON ; Store stream ptr.
    LDX   TEXT_PTR_TO_CODE_JSR ; X from var.
    JSR   X ; JSR to code...
    ADDA  Y ; A+=@Y
    ADDA  TEXT_DATA_SPACING_XXYY? ; Add spacing, too.
    STA   SENTENCE_CURR_SCR_LOC_XXYY ; Store to POS.X
    LEAS  2,S ; Clean up stack from JSR here.
    LDX   TEXT_PTR_TO_CODE_JMP ; Load from
    JMP   X ; Goto
TEXT_RTN_PTRS=$FFB3/$CC0F: ; 0x004BC1, $CBC1
    PSHS  U,Y,X,B,A,CC ; Save state.
    LDY   #$FFB3 ; JMP to TEXT_CHAR_TO_SCREEN
    LDU   #$CC0F ; PTR to AND #$F0 below
    BRA   TEXT_RTN_UNK_BASE
TEXT_RTN_PTRS=$FFB6/$CC0F: ; 0x004BCC, $CBCC
    PSHS  U,Y,X,B,A,CC ; Save state.
    LDY   #$FFB6 ; PTR to JMP to unknown code.
    LDU   #$CC0F ; PTR to CMPA #$F0 below.
    BRA   TEXT_RTN_UNK_BASE
TEXT_RTN_PTRS=$FFB3/$CC39: ; 0x004BD7, $CBD7
    PSHS  U,Y,X,B,A,CC ; Save state
    LDY   #$FFB3 ; JMP to TEXT_CHAR_TO_SCREEN
    LDU   #$CC39 ; PTR to restore and RTS
    BRA   TEXT_RTN_UNK_BASE
TEXT_RTN_PTRS=$FFB6/$CC39: ; 0x004BE2, $CBE2
    PSHS  U,Y,X,B,A,CC
    LDY   #$FFB6 ; PTR to JMP to unknown code.
    LDU   #$CC39 ; PTR to restore and RTS
TEXT_RTN_UNK_BASE: ; 0x004BEB, $CBEB
    STY   TEXT_PTR_TO_CODE_JSR ; Store to JSR
    STU   TEXT_PTR_TO_CODE_JMP ; Store to JMP.
    LDU   TEXT_PTR_UNK
    CMPU  #$FFFF ; Is..
    BNE   TEXT_PTR_NOT_FFFF ; != to FF, go here.
    STX   SENTENCE_CURR_SCR_LOC_XXYY ; Put stream to location, temp.
    STD   TEXT_PTR_UNK ; Put D to PTR?
    BNE   BIT_STUFF_IDK ; Get jumped in the middle of maybe?
    LDD   #$0FFF ; Just do it once?
    BRA   STD_UNK
BIT_STUFF_IDK: ; 0x004C03, $CC03
    BITA  #$F0 ; Test top bits.
    BNE   STD_UNK ; If any bits set, taken.
    BSR   MANIPULATE_D ; D << 4, D|= 0x000F
    BRA   BIT_STUFF_IDK
STD_UNK: ; 0x004C0B, $CC0B
    STD   TEXT_PTR_UNK ; Store D
TEXT_PTR_NOT_FFFF: ; 0x004C0D, $CC0D
    LDD   TEXT_PTR_UNK ; Load D
    ANDA  #$F0 ; Test top bits.
    CMPA  #$F0
    BNE   NOT_0xF0 ; Not 0xF0
    PULS  CC,A,B,X,Y,U ; Pull state
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Get stream from temp.
    ORCC  #$01 ; CC.C = 1
    RTS ; Leave
NOT_0xF0: ; 0x004C1C, $CC1C
    LSRA ; A>>2...
    LSRA
    LDX   #$C5FB ; PTR to...
    LEAY  A,X ; Y from X+A
    LDD   SENTENCE_CURR_SCR_LOC_XXYY ; Load pos
    LDX   TEXT_PTR_TO_CODE_JSR ; Load JSR
    JSR   X ; Do JSR
    ADDA  Y ; Add A@Y
    ADDA  TEXT_DATA_SPACING_XXYY? ; Add to spacing X
    STA   SENTENCE_CURR_SCR_LOC_XXYY ; Store to POS.X
    LDD   TEXT_PTR_UNK ; Get unk
    BSR   MANIPULATE_D ; Manipulate
    STD   TEXT_PTR_UNK ; Store
    LDX   TEXT_PTR_TO_CODE_JMP ; Get code to jump to.
    JMP   X ; Jump to var.
    PULS  CC,A,B,X,Y,U ; Pull saved
    ANDCC #$FE ; Clear CC.C
    RTS ; RTS
MANIPULATE_D: ; 0x004C3E, $CC3E
    ASLB ; D << 4, bringing in 0's.
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ORB   #$0F ; D |= 0x000F, setting all shifted to 0's.
    RTS ; Leave
BMP_LIBRARY_BANKED: ; 0x004C49, $CC49
    .db $00 ; From here on is the second bitmap table.
    .db $00 ; Most of these are odd-pixel graphics bmps.
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $05
    .db $38
    .db $4E
    .db $CE
    .db $96
    .db $09
    .db $AC
    .db $42
    .db $90
    .db $16
    .db $52
    .db $A8
    .db $F2
    .db $12
    .db $96
    .db $6A
    .db $08
    .db $C0
    .db $DE
    .db $CA
    .db $A5
    .db $54
    .db $1B
    .db $88
    .db $2D
    .db $59
    .db $A3
    .db $96
    .db $41
    .db $DC
    .db $EF
    .db $A3
    .db $27
    .db $03
    .db $B6
    .db $1C
    .db $EF
    .db $5E
    .db $FF
    .db $D7
    .db $B0
    .db $56
    .db $A4
    .db $76
    .db $C3
    .db $A0
    .db $90
    .db $9B
    .db $D9
    .db $08
    .db $D3
    .db $04
    .db $CB
    .db $99
    .db $C8
    .db $70
    .db $43
    .db $94
    .db $33
    .db $7B
    .db $6B
    .db $8D
    .db $B2
    .db $F8
    .db $00
    .db $0C
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $0C
    .db $00
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $00
    .db $C0
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $C0
    .db $00
    .db $A0
    .db $0A
    .db $A0
    .db $A0
    .db $00
    .db $A0
    .db $0A
    .db $00
    .db $0A
    .db $0A
    .db $A0
    .db $0A
    .db $0A
    .db $AA
    .db $0A
    .db $00
    .db $A0
    .db $00
    .db $00
    .db $0A
    .db $00
    .db $A0
    .db $AA
    .db $A0
    .db $00
    .db $02
    .db $23
    .db $02
    .db $20
    .db $22
    .db $23
    .db $22
    .db $00
    .db $00
    .db $20
    .db $00
    .db $00
    .db $00
    .db $02
    .db $00
    .db $02
    .db $22
    .db $32
    .db $22
    .db $00
    .db $20
    .db $32
    .db $20
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $04
    .db $34
    .db $30
    .db $30
    .db $34
    .db $30
    .db $00
    .db $00
    .db $44
    .db $44
    .db $33
    .db $33
    .db $34
    .db $30
    .db $30
    .db $30
    .db $00
    .db $30
    .db $03
    .db $03
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $33
    .db $33
    .db $03
    .db $03
    .db $30
    .db $00
    .db $44
    .db $44
    .db $03
    .db $03
    .db $43
    .db $03
    .db $03
    .db $03
    .db $40
    .db $43
    .db $30
    .db $30
    .db $43
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $04
    .db $34
    .db $03
    .db $03
    .db $34
    .db $30
    .db $00
    .db $00
    .db $44
    .db $44
    .db $30
    .db $30
    .db $34
    .db $30
    .db $30
    .db $30
    .db $00
    .db $30
    .db $33
    .db $33
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $30
    .db $30
    .db $03
    .db $03
    .db $30
    .db $00
    .db $44
    .db $44
    .db $33
    .db $33
    .db $43
    .db $03
    .db $03
    .db $03
    .db $40
    .db $43
    .db $03
    .db $03
    .db $43
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $00
    .db $33
    .db $33
    .db $33
    .db $33
    .db $30
    .db $00
    .db $00
    .db $00
    .db $33
    .db $03
    .db $03
    .db $33
    .db $30
    .db $30
    .db $30
    .db $00
    .db $30
    .db $33
    .db $33
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $33
    .db $33
    .db $03
    .db $03
    .db $30
    .db $00
    .db $00
    .db $33
    .db $30
    .db $30
    .db $03
    .db $03
    .db $03
    .db $03
    .db $00
    .db $33
    .db $33
    .db $33
    .db $33
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $03
    .db $34
    .db $03
    .db $33
    .db $70
    .db $40
    .db $33
    .db $33
    .db $07
    .db $44
    .db $33
    .db $33
    .db $00
    .db $04
    .db $33
    .db $30
    .db $73
    .db $40
    .db $33
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $37
    .db $44
    .db $33
    .db $33
    .db $00
    .db $04
    .db $33
    .db $33
    .db $70
    .db $40
    .db $33
    .db $33
    .db $07
    .db $44
    .db $33
    .db $00
    .db $30
    .db $03
    .db $30
    .db $00
    .db $03
    .db $30
    .db $03
    .db $33
    .db $00
    .db $44
    .db $33
    .db $33
    .db $70
    .db $04
    .db $33
    .db $33
    .db $07
    .db $40
    .db $33
    .db $30
    .db $03
    .db $44
    .db $33
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $30
    .db $04
    .db $33
    .db $33
    .db $07
    .db $40
    .db $33
    .db $33
    .db $00
    .db $44
    .db $33
    .db $33
    .db $70
    .db $04
    .db $33
    .db $00
    .db $30
    .db $43
    .db $30
    .db $00
    .db $03
    .db $34
    .db $03
    .db $33
    .db $07
    .db $04
    .db $33
    .db $33
    .db $00
    .db $40
    .db $33
    .db $33
    .db $70
    .db $44
    .db $33
    .db $30
    .db $03
    .db $04
    .db $33
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $30
    .db $40
    .db $33
    .db $33
    .db $70
    .db $44
    .db $33
    .db $33
    .db $07
    .db $04
    .db $33
    .db $33
    .db $00
    .db $40
    .db $33
    .db $00
    .db $30
    .db $43
    .db $30
    .db $00
    .db $06
    .db $26
    .db $06
    .db $26
    .db $00
    .db $66
    .db $66
    .db $66
    .db $88
    .db $88
    .db $88
    .db $00
    .db $60
    .db $66
    .db $66
    .db $88
    .db $86
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $93
    .db $00
    .db $00
    .db $00
    .db $6D
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $EF
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $69
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $02
    .db $00
    .db $02
    .db $00
    .db $06
    .db $66
    .db $66
    .db $28
    .db $68
    .db $08
    .db $60
    .db $66
    .db $66
    .db $86
    .db $88
    .db $88
    .db $00
    .db $00
    .db $60
    .db $66
    .db $86
    .db $69
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $30
    .db $00
    .db $00
    .db $00
    .db $DE
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $F0
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $93
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $39
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0F
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $ED
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $03
    .db $00
    .db $00
    .db $06
    .db $66
    .db $68
    .db $96
    .db $06
    .db $66
    .db $66
    .db $68
    .db $88
    .db $88
    .db $60
    .db $66
    .db $66
    .db $83
    .db $86
    .db $80
    .db $00
    .db $00
    .db $30
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $96
    .db $00
    .db $00
    .db $00
    .db $00
    .db $FE
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D6
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $39
    .db $00
    .db $06
    .db $66
    .db $66
    .db $88
    .db $68
    .db $66
    .db $66
    .db $66
    .db $88
    .db $88
    .db $88
    .db $00
    .db $60
    .db $63
    .db $30
    .db $63
    .db $00
    .db $06
    .db $26
    .db $68
    .db $28
    .db $60
    .db $66
    .db $66
    .db $86
    .db $00
    .db $00
    .db $66
    .db $66
    .db $00
    .db $00
    .db $ED
    .db $66
    .db $00
    .db $00
    .db $00
    .db $63
    .db $90
    .db $09
    .db $90
    .db $99
    .db $99
    .db $99
    .db $90
    .db $CC
    .db $90
    .db $11
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $10
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $10
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $11
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $FF
    .db $F0
    .db $FF
    .db $00
    .db $FF
    .db $00
    .db $F0
    .db $00
    .db $F0
    .db $F0
    .db $F0
    .db $00
    .db $EE
    .db $E0
    .db $E0
    .db $E0
    .db $EE
    .db $00
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $00
    .db $DD
    .db $D0
    .db $D0
    .db $D0
    .db $DD
    .db $00
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $00
    .db $0F
    .db $0F
    .db $0F
    .db $00
    .db $0F
    .db $00
    .db $FF
    .db $00
    .db $FF
    .db $0F
    .db $FF
    .db $00
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $00
    .db $EE
    .db $0E
    .db $0E
    .db $0E
    .db $EE
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $DD
    .db $0D
    .db $0D
    .db $0D
    .db $DD
    .db $00
    .db $1C
    .db $0D
    .db $7F
    .db $E7
    .db $70
    .db $00
    .db $0F
    .db $71
    .db $71
    .db $07
    .db $DC
    .db $77
    .db $7C
    .db $0D
    .db $71
    .db $C7
    .db $77
    .db $DE
    .db $07
    .db $71
    .db $17
    .db $17
    .db $DE
    .db $F7
    .db $71
    .db $17
    .db $71
    .db $7C
    .db $DE
    .db $F0
    .db $07
    .db $77
    .db $C7
    .db $71
    .db $17
    .db $70
    .db $70
    .db $7C
    .db $D7
    .db $77
    .db $77
    .db $70
    .db $01
    .db $CD
    .db $FF
    .db $D7
    .db $70
    .db $F0
    .db $00
    .db $00
    .db $00

;Bank 3
	.org $C000

JMP_BOOTUP_UNIT_OK: ; 0x005000, $C000
    JMP   BOOTUP_UNIT_OK
JMP_BOOTUP_RAM_FAILURE: ; 0x005003, $C003
    JMP   BOOTUP_RAM_FAILURE
JMP_BOOTUP_ROM_FAILURE: ; 0x005006, $C006
    JMP   BOOTUP_ROM_FAILURE
JMP_SRAM_CHECK_UNK: ; 0x005009, $C009
    JMP   SRAM_CHECK_UNK
JMP_BOOKKEEP_UPDATE_+A: ; 0x00500C, $C00C
    JMP   BOOKKEEP_UPDATE_+A
JMP_BOOKKEEP_UPDATE_+1: ; 0x00500F, $C00F
    JMP   BOOKKEEP_UPDATE_+1
JMP_BOOKKEEP_COIN_1: ; 0x005012, $C012
    JMP   BOOKKEEP_COIN_1_+1 ; Coin callback
JMP_BOOKKEEP_COIN_3: ; 0x005015, $C015
    JMP   BOOKKEEP_COIN_3_+1 ; Coin callback.
JMP_BOOKKEEP_COIN_2: ; 0x005018, $C018
    JMP   BOOKKEEP_COIN_2_+1 ; Coin callback.
JMP_INIT_SRAM_C41D: ; 0x00501B, $C01B
    JMP   INIT_SRAM_$C41D_WITH_$CECF
JMP MOVE_@X_TO_SRAM@Y: ; 0x00501E, $C01E
    JMP   MOVE_@X_TO_SRAM@Y
JMP_SETTINGS_MENU?: ; 0x005021, $C021
    JMP   SETTINGS_MENU?
JMP_CLEAR_ENTIRE+SETTINGS: ; 0x005024, $C024
    JMP   CLEAR_ENTIRE+SETTINGS
JMP_FAILED_W/_AUTO_NOT_PRESSED: ; 0x005027, $C027
    JMP   FAILED_WITH_AUTO_NOT_PRESSED
JMP_RUG_MISMATCH: ; 0x00502A, $C02A
    JMP   RUG_MISMATCH_JMP
JMP_RUG_NO_RAM_ERRORS_DETECTED: ; 0x00502D, $C02D
    JMP   RUG_NO_RAM_ERRORS_DETECTED
JUMP_RUG_AUDIO_TEST: ; 0x005030, $C030
    JMP   RUG_AUDIO_TEST
JMP_TO_HIGHSCORES_TO_RAM: ; 0x005033, $C033
    JMP   INIT_HIGHSCORES_DAILY
JMP_STORE_B@X_BANK0: ; 0x005036, $C036
    JMP   JMP_STORE_B@X_BANK0
JMP_LOAD_B@X_BANK0: ; 0x005039, $C039
    JMP   JMP_LOAD_B@X_BANK0
GOTO_C002_B2_SENTENCE_TO_SCREEN: ; 0x00503C, $C03C
    JSR   JMP_GOTO_PAST_JSR ; TEXT_RTN
    .db $C0 ; $C002, bank 2, sentence to screen.
    .db $02
    .db $02
    RTS
GOTO_C005_B2_SENTENCE_FROM_SCREEN: ; 0x005043, $C043
    JSR   JMP_GOTO_PAST_JSR ; Sentence cleared from screen.
    .db $C0
    .db $05
    .db $02
    RTS
GOTO_C00E_B2_AB_TO_SCREEN: ; 0x00504A, $C04A
    JSR   JMP_GOTO_PAST_JSR ; Val in AB to screen
    .db $C0
    .db $0E
    .db $02
    RTS
GOTO_C011_B2_AB_FROM_SCREEN: ; 0x005051, $C051
    JSR   JMP_GOTO_PAST_JSR ; Val in AB cleared from screen.
    .db $C0
    .db $11
    .db $02
    RTS
GOTO_C01A_B2_SPECIAL_TO_SCREEN: ; 0x005058, $C058
    JSR   JMP_GOTO_PAST_JSR ; Special to screen.
    .db $C0
    .db $1A
    .db $02
    RTS
GOTO_C01D_B2_SPECIAL_FROM_SCREEN: ; 0x00505F, $C05F
    JSR   JMP_GOTO_PAST_JSR ; Special cleared from screen.
    .db $C0
    .db $1D
    .db $02
    RTS
GOTO_C020_B2_PREP_PRESS_ADV_TO_STEP_THRU: ; 0x005066, $C066
    JSR   JMP_GOTO_PAST_JSR ; SENTENCE PRESS ADV TO STEP THRU TEST
    .db $C0
    .db $20
    .db $02
    RTS
GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...: ; 0x00506D, $C06D
    JSR   JMP_GOTO_PAST_JSR ; SENTENCE PRESS ADV WITH SWITCH SET FOR...
    .db $C0
    .db $23
    .db $02
    RTS
    .db $D9 ; Unk.
    .db $FF
BOOTUP_UNIT_OK: ; 0x005076, $C076
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$7A ; B=1/3,G=7/7,R=2/7
    JSR   SET_COLOR_$C001
    LDU   #$C069 ; PTR to SENTENCE INITIAL TESTS INDICATE
    LDX   #$2870 ; POS XXYY
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Put to screen.
    LDU   #$C06B ; PTR to SENTENCE UNIT OK
    LDX   #$4090 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Put to screen
    LDB   #$0F ; All LED's lighted?
    JSR   ROM_LED_BLINK_STARTUP?
    LDY   #$0BB8 ; Loops to read switches for admin menu.
    JMP   AUTO+ADV_CHECK ; RTS's back into main bootup code to JMP to game code.
BOOTUP_RAM_FAILURE: ; 0x00509C, $C09C
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$57 ; B=1/3,G=2/7,R=7/7
    JSR   SET_COLOR_$C001
    LDU   #$C069 ; PTR to SENTENCE INITIAL TESTS INDICATE
    LDX   #$2870 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDU   #$C073 ; PTR to SENTENCE RAM FAILURE
    LDX   #$3890 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    BRA   BOOTUP_FAILURE_WAIT
BOOTUP_ROM_FAILURE: ; 0x0050B8, $C0B8
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$57 ; B=1/3,G=2/7,R=7/7
    JSR   SET_COLOR_$C001
    LDU   #$C069 ; PTR, SENTENCE INITIAL TESTS INDICATE
    LDX   #$2860
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDU   #$C071 ; PTR, SENTENCE ROM FAILURE
    LDX   #$3880 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    TFR   DP>A
    CMPA  #$9E ; Value if DP was 0.
    BEQ   BOOTUP_FAILURE_WAIT
    LDU   #$C073 ; PTR to SENTENCE RAM FAILURE
    LDX   #$38A0 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Put to screen
BOOTUP_FAILURE_WAIT: ; 0x0050E1, $C0E1
    LDY   #$0BB8 ; Timer?
LOOP_FAIL_ADV/AUTO_READ: ; 0x0050E5, $C0E5
    JSR   ADV+AUTO_CUMULATIVE ; Get switches.
    LDX   #$CC00 ; Get ROM PIA.
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$02 ; Test ADV switch.
    BEQ   ADV_NOT_PRESSED ; If ADV isn't pressed, loop to wait.
    LSRB ; AUTO switch to CC.c
    BCS   RTS ; If auto is pressed, leaves...
    BRA   FAILED_WITH_AUTO_NOT_PRESSED ; If not pressed, goes here.
ADV_NOT_PRESSED: ; 0x0050F7, $C0F7
    LEAY  -1,Y
    BNE   LOOP_FAIL_ADV/AUTO_READ
RTS: ; 0x0050FB, $C0FB
    RTS
SRAM_CHECK_UNK: ; 0x0050FC, $C0FC
    ANDCC #$EF ; Clear IRQ mask.
    LDX   #$C47F ; PTR to SRAM
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data.
    CMPB  #$5A ; If SRAM _ val
    BNE   GOTO_SETTINGS_MENU ; !=, goto.
    LDX   #$C400 ; Load
    JSR   JMP_LOAD_B@X_BANK0 ; To B
    ANDB  #$0F ; Get bottom bits.
    BNE   C400_NOT_0 ; If any set in 0000.1111, goto.
    RTS ; RTS if bits set.
C400_NOT_0: ; 0x005113, $C113
    CLRB
    JSR   JMP_STORE_B@X_BANK0 ; Clear location 0xC400.
    LDX   #$C47D
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data here
    CLRA ; Clear
    LEAX  -2,X ; Fix location.
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Clear location.
    CMPB  #$15 ; Previous value.
    BNE   PREV_NOT_0x15
CLEAR_ENTIRE+SETTINGS: ; 0x005127, $C127
    ANDCC #$7F ; Clear ENTIRE flag.
    BRA   FAILED_WITH_AUTO_NOT_PRESSED
PREV_NOT_0x15: ; 0x00512B, $C12B
    CMPB  #$25
    BNE   PREV_NOT_0x25
    JMP   INIT_SRAM_$C41D_WITH_$CECF
PREV_NOT_0x25: ; 0x005132, $C132
    CMPB  #$35
    BNE   PREV_NOT_35
    JMP   CLEAR_SRAM@0xC400_B_BYTES ; If is 35, goto here.
PREV_NOT_35: ; 0x005139, $C139
    CMPB  #$45
    BEQ   GOTO_SETTINGS_MENU ; If is 45, goto menu.
    RTS ; Leave otherwise.
GOTO_SETTINGS_MENU: ; 0x00513E, $C13E
    LEAS  2,S ; Clean stack because we will not RTS.
    JSR   INIT_SRAM
    JMP   SETTINGS_MENU? ; Settings menu?
FAILED_WITH_AUTO_NOT_PRESSED: ; 0x005146, $C146
    ORCC  #$10 ; Mask interrupts.
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF ; Do...
    JSR   JMP_ROM_CHECK_START ; Do...
    PSHS  U ; Save U
    LDU   DATA_W_#$F86E
    LEAU  24,U ; Off $2886
    STU   R_A043_TEST_TEMP/RUG_MISMATCH_ADDR ; Store to..
    PULS  U ; Restore U
    CMPU  R_A043_TEST_TEMP/RUG_MISMATCH_ADDR ; Compare them.
    BEQ   STACKS_THE_SAME ; Taken if same.
    STU   R_A05B_ROM_CHECK_UNK ; Not same, do...
    LDB   #$08
    JSR   ROM_BOARD_LED_DISPLAY_B ; Show
    LDB   #$57 ; Color
    JSR   SET_COLOR_$C001 ; Color
    LDU   #$C071 ; PTR to SENTENCE ROM FAILURE
    LDX   #$3860 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; DISP
    LDY   #$C035 ; PTR to SENTENCE AUTO FOR RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR... ; DISP
    LDD   #$4266 ; XXYY Screen pos initial.
    STD   R_A04A_ROM_FAIL_POS_XXYY ; Store
LOOP_ROM_CHECK?: ; 0x005180, $C180
    LDX   R_A04A_ROM_FAIL_POS_XXYY ; Load
    LEAX  10,X ; Add 10
    STX   R_A04A_ROM_FAIL_POS_XXYY ; Store
    LDU   #$C06D ; PTR to SENTENCE ROM
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Disp?
    LDU   DATA_W_#$F86E ; Get
    STU   R_A043_TEST_TEMP/RUG_MISMATCH_ADDR ; Put
    LDU   R_A05B_ROM_CHECK_UNK ; Load
    LDD   R_A05B_ROM_CHECK_UNK
    SUBD  R_A043_TEST_TEMP/RUG_MISMATCH_ADDR ; Get difference.
    LSRB ; Get bottom bit.
    BCS   BOTTOM_BIT_SET ; Don't add if bottom set.
    LEAU  1,U
BOTTOM_BIT_SET: ; 0x00519C, $C19C
    INCB ; INC PTR bottom?
    STB   R_A03A_MENU_UNK ; Store...
    JSR   A+=16_PER_EACH_B_0xF0>>8_VALUE ; Make pos?
    LDX   SENTENCE_CURR_SCR_LOC_XXYY
    JSR   GOTO_C00E_B2_AB_TO_SCREEN ; Text IDK
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog+switches.
    JSR   JMP_CORRECT_CHECKSUM ; Idk why
    STU   R_A05B_ROM_CHECK_UNK ; Store U...?
    LDU   DATA_W_#$F86E ; Get ptr...
    LEAU  24,U ; Add 24
    CMPU  R_A05B_ROM_CHECK_UNK ; Compare to...
    BNE   LOOP_ROM_CHECK? ; Not +24
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag...
    BNE   $49_NOT_SET ; If not set..
    LDB   R_A03A_MENU_UNK ; If set, load val...
    JSR   ROM_BOARD_LED_DISPLAY_B ; Display on ROM board.
    LDY   #$C039 ; PTR to SENTENCE AUTO FOR RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR... ; Disp?
    BRA   RAM_TEST_ENTER ; Go always
STACKS_THE_SAME: ; 0x0051CF, $C1CF
    TFR   CC>B ; CC to B
    TSTB ; Test CC
    BPL   ENTIRE_NOT_SET ; If positive signed, goto.
    LDB   #$7A ; R=2/7, G=7/7, B=1/3
    JSR   SET_COLOR_$C001 ; Set text color.
    LDU   #$C077 ; PTR to SENTENCE ALL ROMS OK
    LDX   #$3880
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Put to scr
    LDY   #$C039
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR... ; Sentence AUTO FOR RAM TEST
    LDB   #$08
    JSR   ROM_LED_BLINK_STARTUP? ; Do LED's
RAM_TEST_ENTER: ; 0x0051EE, $C1EE
    JSR   SINGLE_CHECK_AUTO+ADV
$49_NOT_SET: ; 0x0051F1, $C1F1
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    CLRB
    JSR   ROM_BOARD_LED_DISPLAY_B
    JSR   SET_COLOR_PALETTE_0x01_WHITE
    LDU   #$C079 ; Sentence RAM TEST
    LDX   #$4080
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; To scr
    LDY   #$C03D ; PTR to SENTENCE AUTO TO EXIT TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    LDY   #$1388 ; Check time.
    JSR   AUTO+ADV_CHECK
ENTIRE_NOT_SET: ; 0x005212, $C212
    JSR   ADV+AUTO_CUMULATIVE
    TST   UNK_$49_SYS_MENU_FLAG?
    LBNE  Y_IS_#$000A
    TST   UNK_$47_AUTO+ADV
    BNE   ENTIRE_NOT_SET ; Loop wait
    LDX   #$C000
    LDB   #$C0
SET_PALETTE_LOOP: ; 0x005224, $C224
    JSR   JMP_STORE_B@X_BANK0
    LDA   #$B5
    MUL
    EXG   A-B
    LEAX  1,X
    CMPX  #$C010
    BNE   SET_PALETTE_LOOP ; Loop palette
    LDD   #$0000 ; Idk
    LDY   #$000A ; Times to run
    JMP   JMP_RUG_SETUP ; Do setup.
RUG_MISMATCH_JMP: ; 0x00523D, $C23D
    TFR   Y>D ; Y to D
    EORB  -X ; Get bits that are different than expected?
    EORA  -X
    STD   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; Store bits wrong here.
    STX   R_A043_TEST_TEMP/RUG_MISMATCH_ADDR ; X pos of event here.
    JSR   CLEAR_COLOR_PALETTE ; Clear screen
    JSR   JMP_CLEAR_ALL_SCREEN ; Clear screen bytes.
    JSR   SETUP_52+49+48+36+59 ; Setup
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDB   #$04
    JSR   ROM_BOARD_LED_DISPLAY_B
    LDB   #$57 ; R=7/7, G=2/7, B=1/3
    JSR   SET_COLOR_$C001
    LDU   #$C073 ; PTR TO SENTENCE RAM FAILURE
    LDX   #$3870 ; Pos XXYY
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; To screen
    LDY   #$C041 ; PTR to SENTENCE AUTO FOR CMOS RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    LDD   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; Load
    TSTA ; test
    BNE   A_NOT_ZERO ; If set, goto.
    TFR   B>A ; B to A if zero.
A_NOT_ZERO: ; 0x005274, $C274
    CLRB ; Clear B, counter.
LOOP_FIND_SET: ; 0x005275, $C275
    INCB ; B++
    LSRA
    BCC   LOOP_FIND_SET ; Loop to find set bit.
    STB   R_A03A_MENU_UNK ; B is bit number.
    LDD   R_A043_TEST_TEMP/RUG_MISMATCH_ADDR ; D to
NOT_UNDER_ZERO_YET: ; 0x00527D, $C27D
    SUBA  #$03 ; A -= 3
    BCC   NOT_UNDER_ZERO_YET
    ADDA  #$04 ; +=4
    STA   R_AO3B_UPDATE_SCREEN? ; Store here.
    LDU   #$C06F ; Sentence RAM
    LDX   #$4290 ; Pos
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; To screen
    LDB   R_AO3B_UPDATE_SCREEN? ; Load val
    ASLB ; B << 4
    ASLB
    ASLB
    ASLB
    ADDB  R_A03A_MENU_UNK ; += addr
    CLRA ; Clear A
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Put after other text.
    JSR   GOTO_C00E_B2_AB_TO_SCREEN ; Put to screen.
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS ; Buttons
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag
    BNE   Y_IS_#$000A ; If set, goto.
    LDA   R_AO3B_UPDATE_SCREEN? ; Load val
    LDB   #$10 ; Seed bits.
LOOP_A_TIMES: ; 0x0052A7, $C2A7
    LSRB ; B >> 1
    DECA ; A--
    BNE   LOOP_A_TIMES ; Loop until A is 0.
    JSR   ROM_BOARD_LED_DISPLAY_B ; Display
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS ; Input
    TST   UNK_$49_SYS_MENU_FLAG? ; Test
    BNE   Y_IS_#$000A ; If set, goto.
    LDB   R_A03A_MENU_UNK ; Load
    JSR   ROM_BOARD_LED_DISPLAY_B ; Display bits.
    LDY   #$C045 ; SENTENCE AUTO FOR CMOS RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    BRA   CHECK_ADV_AUTO
RUG_NO_RAM_ERRORS_DETECTED: ; 0x0052C3, $C2C3
    JSR   CLEAR_COLOR_PALETTE
    JSR   JMP_CLEAR_ALL_SCREEN
    JSR   SETUP_52+49+48+36+59
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    CMPY  #$000A
    BEQ   Y_IS_#$000A
    LDB   #$7A ; R=2/7,G=7/7,B=1/3
    JSR   SET_COLOR_$C001 ; Set color.
    LDU   #$C07B ; SENTENCE NO RAM ERRORS DETECTED
    LDX   #$2880 ; Pos
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; To screen
    LDY   #$C045 ; SENTENCE AUTO FOR CMOS RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR... ; To SCR
    LDB   #$04
    JSR   ROM_LED_BLINK_STARTUP? ; Display on ROM
CHECK_ADV_AUTO: ; 0x0052EF, $C2EF
    JSR   SINGLE_CHECK_AUTO+ADV
Y_IS_#$000A: ; 0x0052F2, $C2F2
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF ; Setup stuff.
    TFR   DP>A ; DP to A
    CMPA  #$A2 ; Test A
    BNE   L_005318 ; If not, goto.
    LDB   #$02 ; Display on LED's
    JSR   ROM_BOARD_LED_DISPLAY_B
    LDB   #$57 ; R=7/7, G=2/7, B=1/3
    JSR   SET_COLOR_$C001
    LDU   #$C081 ; SENTENCE MULTIPLE RAM FAILURE
    LDX   #$2880
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDY   #$C049 ; SENTENCE AUTO FOR COLOR RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    JMP   POST_CMOS_TEST
L_005318: ; 0x005318, $C318
    ADDA  #$03 ; A += 3
    CLRB ; B = 0
    STD   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; To addr
    LDU   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; U from ADDR
    LDX   #$C400 ; SRAM PTR
LOOP_SRAM_IDK: ; 0x005322, $C322
    JSR   JMP_LOAD_B@X_BANK0 ; Load from SRAM
    STB   U+ ; B to U
    LEAX  1,X ; X++
    CMPX  #$C500 ; If X _ val
    BNE   LOOP_SRAM_IDK ; !=, goto.
    LDD   #$0010 ; D =
    STB   R_A03A_MENU_UNK ; =0x10
    CLRA ; A = 0
LONGER_LOOP: ; 0x005334, $C334
    LDX   #$C400 ; X =
    LDB   R_A03A_MENU_UNK ; B =
LOOP_B++_IDK: ; 0x005339, $C339
    JSR   JMP_STORE_B@X_BANK0 ; B to X
    LEAX  1,X ; X++
    INCB ; B++
    CMPB  R_A03A_MENU_UNK ; If B _ addr
    BNE   LOOP_B++_IDK ; !=, goto.
    LDX   #$C400 ; X =
    INCA ; A++
LOOP_INC_A: ; 0x005347, $C347
    JSR   JMP_LOAD_B@X_BANK0 ; Load B
    STB   R_AO3B_UPDATE_SCREEN? ; B to
    LEAX  1,X ; X++
    JSR   JMP_LOAD_B@X_BANK0 ; Load B
    SUBB  R_AO3B_UPDATE_SCREEN? ; B -= val
    DECB ; B--
    ANDB  #$0F ; Get bits
    BNE   NEXT_PART_IDK ; If not 0, goto.
    INCA ; A++
    BNE   LOOP_INC_A ; If not 0, goto.
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Switches
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag
    BNE   NEXT_PART_IDK ; If set, goto.
    DEC   R_A03A_MENU_UNK ; Dec var
    BNE   LONGER_LOOP
NEXT_PART_IDK: ; 0x005366, $C366
    LDU   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; U from
    LDX   #$C400 ; SRAM PTR
LOOP_UNTIL_C500: ; 0x00536B, $C36B
    LDB   U+ ; Load B from U
    JSR   JMP_STORE_B@X_BANK0 ; Store to X
    LEAX  1,X ; X += 1
    CMPX  #$C500 ; Val for end.
    BNE   LOOP_UNTIL_C500 ; Loop
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag
    BNE   L_0053BE ; If set, next test.
    LDA   R_A03A_MENU_UNK
    BEQ   CMOS_RAM_OK_RTN ; If 0, goto, is okay.
    LDB   #$02
    JSR   ROM_BOARD_LED_DISPLAY_B ; Display bits.
    LDB   #$57 ; R=7/7, G=2/7, B=1/3
    JSR   SET_COLOR_$C001
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDU   #$C07D ; Sentence CMOS RAM FAILURE
    LDX   #$3080 ; POS
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; To screen
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Test switches
    LDY   #$C049 ; Sentence AUTO FOR COLOR RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR... ; To screen
    BRA   POST_CMOS_TEST
CMOS_RAM_OK_RTN: ; 0x0053A1, $C3A1
    LDB   #$7A
    JSR   SET_COLOR_$C001
    LDU   #$C07F ; Sentence CMOS RAM OK
    LDX   #$3880
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDY   #$C049 ; Sentence COLOR FOR AUTO RAM TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    LDB   #$02
    JSR   ROM_LED_BLINK_STARTUP? ; Show LED's.
POST_CMOS_TEST: ; 0x0053BB, $C3BB
    JSR   SINGLE_CHECK_AUTO+ADV
L_0053BE: ; 0x0053BE, $C3BE
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$01
    JSR   ROM_BOARD_LED_DISPLAY_B
    JSR   SET_COLOR_PALETTE_0x01_WHITE
    LDU   #$C083 ; COLOR RAM TEST
    LDX   #$3880
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDY   #$C04D ; AUTO TO EXIT TEST
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    LDY   #$1388
    JSR   AUTO+ADV_CHECK
    JSR   DRAW_DATA_TO_STRIPS ; Draw strips.
    LDY   #$07D0 ; Timer between colors.
RESET_COLOR_PTR_LOOP: ; 0x0053E7, $C3E7
    LDU   #$C9D8 ; Colors ptr.
LOAD_NEW_COLOR_LOOP: ; 0x0053EA, $C3EA
    LDB   U+ ; B from U
    LDX   #$C000 ; X to palette.
UPLOAD_PALETTE: ; 0x0053EF, $C3EF
    JSR   JMP_STORE_B@X_BANK0 ; Store B to palette
    LEAX  1,X ; X++
    CMPX  #$C010 ; End palette addr
    BNE   UPLOAD_PALETTE ; Loop
    JSR   AUTO+ADV_CHECK ; Check switches.
    CMPU  #$C9E0 ; If end of palette.
    BNE   LOAD_NEW_COLOR_LOOP ; Load new color
    TST   UNK_$49_SYS_MENU_FLAG? ; Tets flag
    BEQ   RESET_COLOR_PTR_LOOP ; If not requested, loop colors.
RUG_AUDIO_TEST: ; 0x005406, $C406
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF ; Clear screen+setup.
    CLRB ; Clear
    STB   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; Clear
    STB   R_A041_TEST_TEMP/RUG_MISMATCH_BITS+1 ; Set
    JSR   ROM_BOARD_LED_DISPLAY_B ; Clear LED's.
    JSR   SET_COLOR_PALETTE_0x01_WHITE ; White.
    LDU   #$C085 ; Sentence AUDIO TEST
    LDX   #$4078 ; Screen loc?
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Text?
    LDY   #$C055
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR... ; Text?
    LDY   #$0001 ; Set
LOOP_SOUND_TEST_START: ; 0x005428, $C428
    LDU   #$C9F0 ; Load
    CLRA ; Clear
LOOP_SND_WAIT?: ; 0x00542C, $C42C
    LDX   #$CC00
    JSR   JMP_LOAD_B@X_BANK0 ; Get ROM PIA
    BITB  #$01 ; Test auto/manual
    BNE   AUTO/MANUAL PRESSED
    BITB  #$02 ; Test advance switch
    BNE   ADVANCED_PRESSED
    JSR   ADV+AUTO_CUMULATIVE
    BRA   LOOP_SND_WAIT?
AUTO/MANUAL PRESSED: ; 0x00543F, $C43F
    JSR   AUTO+ADV_CHECK
INC_A_CMP_U: ; 0x005442, $C442
    INCA ; A++
    CMPA  U ; If A = addr
    BNE   A_NOT_EQ
    LEAU  1,U ; U++
    BRA   INC_A_CMP_U
A_NOT_EQ: ; 0x00544B, $C44B
    STA   R_A03A_MENU_UNK ; Store A
    EORA  #$3F ; Invert bottom bits.
ADVANCED_PRESSED: ; 0x00544F, $C44F
    LDB   #$13 ; Nothing.
    JSR   OUTPUT_SOUND? ; Output it.
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag
    BNE   SWITCH_TEST ; If set, goto.
    LDB   R_A03A_MENU_UNK ; Load
    JSR   OUTPUT_SOUND? ; Output sound in B
    LDY   #$03E8
    LDD   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; AB to display
    LDX   #$5A8C ; Pos
    JSR   GOTO_C011_B2_AB_FROM_SCREEN ; From screen
    LDB   R_A03A_MENU_UNK ; Load val
    JSR   A+=16_PER_EACH_B_0xF0>>8_VALUE ; To display
    CLRA ; Clear A
    STD   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; To
    LDX   #$5A8C ; Pos
    JSR   GOTO_C00E_B2_AB_TO_SCREEN ; Display
    LDA   R_A03A_MENU_UNK ; Load
    CMPA  #$1F ; CMP 32
    BNE   LOOP_SND_WAIT? ; Not all sounds played.
    TFR   CC>B ; CC to B
    TSTB ; Test entire
    LBPL  MONITOR_TEST ; Entire not set
    BRA   LOOP_SOUND_TEST_START ; Redo
SWITCH_TEST: ; 0x005486, $C486
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF ; Init
    JSR   SET_COLOR_PALETTE_0x01_WHITE
    LDU   #$C087 ; Sentence SWITCH TEST
    LDX   #$3820
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDY   #$C059 ; AUTO FOR MONITOR TEST PATTERNS
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    TFR   DP>A ; DP to A
    LDB   #$62 ; B=
    STD   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; D to...
    ADDB  #$26 ; B += 0x26
    TFR   D>X ; D to X
    LDA   #$FF ; A=
LOOP_WRITE_FF: ; 0x0054A8, $C4A8
    STA   -X ; FF to -X
    CMPX  R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; End?
    BNE   LOOP_WRITE_FF ; Nope, loop.
    CLR   TICKS_HAPPENED_COUNTER? ; Clear 5 bytes in a row
    CLR   R_A05E_SLOWDOWN_FLAG?
    CLR   LIST_CALLBACKS_GENERIC?
    CLR   LIST_CALLBACKS_GENERIC?+1
    CLR   LIST_15B_CALLBACKS_AVAILABLE ; Only high byte? Weird.
LOOP_CONTINUE_BUTTONS_TEST: ; 0x0054B8, $C4B8
    LDA   #$01
    STA   R_A03C_OPTION_ON ; Store 1
    LDX   #$CC00 ; Ptr to PIA
    LDU   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; U from
    LEAU  -5,U ; U -= 5
    CLRA ; A = 0
NOT_END_PIA_LOOP: ; 0x0054C4, $C4C4
    JSR   JMP_LOAD_B@X_BANK0 ; Load PIA
    CMPX  #$CC06 ; AND'd
    BNE   SKIP_ANDB ; Not reg, don't end.
    ANDB  #$7F ; Keep 0111.1111
SKIP_ANDB: ; 0x0054CE, $C4CE
    CMPA  #$18 ; If A _ val
    BNE   SKIP_ANDB ; !=, goto.
    ANDB  #$CF ; Keep 1100.1111
SKIP_ANDB: ; 0x0054D4, $C4D4
    STB   R_A03A_MENU_UNK ; B to
    EORB  U+ ; Invert val with U
    BNE   EOR_NOT_ZERO ; If changed, goto.
    ADDA  #$08 ; A +=
X_TO_NEXT_DATA: ; 0x0054DC, $C4DC
    LEAX  2,X ; X += 2
    CMPX  #$CC02 ; If X _ addr
    BEQ   X_TO_NEXT_DATA ; ==, goto, skipping.
    CMPX  #$CC08 ; If X _ addr
    BNE   NOT_END_PIA_LOOP ; !=, goto.
    CMPA  #$28 ; If A _ val
    BEQ   SEE_IF_TEST_END ; ==, goto.
    LEAX  -2,X ; X -= 2
    JSR   JMP_LOAD_B@X_BANK0 ; Load
    TSTB ; Test
    BPL   SEE_IF_TEST_END ; If positive, goto.
    LDB   #$34 ; PIA STATE CA2 SET 0, OUTPUT REG
    LEAX  1,X ; X += 1 for CTRL register
    JSR   JMP_STORE_B@X_BANK0 ; Store B to CTRL
    LEAX  -3,X
    INC   R_A03C_OPTION_ON
    BRA   NOT_END_PIA_LOOP
SEE_IF_TEST_END: ; 0x005501, $C501
    LDB   #$3C ; CTRL CA2 SET 1, OUTPUT REG
    LDX   #$CC07 ; Load CTRL widget
    JSR   JMP_STORE_B@X_BANK0 ; Store setting
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Test adv
    TST   UNK_$49_SYS_MENU_FLAG? ; Set?
    BEQ   LOOP_CONTINUE_BUTTONS_TEST ; If zero, loop.
    BRA   MONITOR_TEST ; Goto
EOR_NOT_ZERO: ; 0x005512, $C512
    STB   R_AO3B_UPDATE_SCREEN? ; Store B, buttons changing.
    LDB   #$01 ; Bit test reg
LOOP_CHANGED_BITS: ; 0x005516, $C516
    BITB  R_AO3B_UPDATE_SCREEN? ; Test bit in B
    BNE   BIT_CHANGED ; Was changed
    INCA ; A++
    ASLB ; Shift B
    BRA   LOOP_CHANGED_BITS
BIT_CHANGED: ; 0x00551E, $C51E
    LDX   R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; X from
    BITB  R_A03A_MENU_UNK ; Test putting or removing.
    BNE   ADDING_TEXT? ; If set, goto.
    EORB  -U ; Flip bit we're doing in original U
    STB   U ; Store back changed not handeled.
FIND_A_MATCH: ; 0x005528, $C528
    CMPA  X+ ; If A _ addr
    BNE   FIND_A_MATCH ; !=, loop.
    COM   -X ; Invert match
    BSR   FIGURE_TEXT_AND_POS ; Get text and pos
    LDD   #$3808 ; Clear size
    JSR   JMP_CLEAR_SCREEN_FLEX_SETUP ; Clear screen at text.
    BRA   SEE_IF_TEST_END ; Goto, continue.
ADDING_TEXT?: ; 0x005538, $C538
    EORB  -U ; Flip bit we're doing in original U
    STB   U ; Store back changed not handeled.
    LDB   #$08 ; Do sound.
    JSR   OUTPUT_SOUND?
FIND_NEGATIVE_SLOT: ; 0x005541, $C541
    TST   X+ ; Test X addr
    BPL   FIND_NEGATIVE_SLOT ; If positive, text is in space.
    STA   -X ; Store text offset to addr, positive val always.
    PSHS  A ; Save text
    BSR   FIGURE_TEXT_AND_POS ; Do sub
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Text to screen.
    PULS  A ; Pull text
    CMPA  #$08 ; If A _ 8
    BCS   SEE_IF_TEST_END ; <, goto.
    LSRA ; Otherwise, half A.
    CMPA  #$06 ; If A _ 6
    BEQ   SEE_IF_TEST_END ; ==, goto.
    LDX   #$CC06 ; PTR to WIDGET B
    JSR   JMP_LOAD_B@X_BANK0 ; Load
    TSTB ; Test load
    BPL   SEE_IF_TEST_END ; If positive, goto.
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Load sentence loc
    CLRA ; Clear A
    LDB   R_A03C_OPTION_ON ; B =
    JSR   GOTO_C00E_B2_AB_TO_SCREEN ; Put number to screen after button...
    BRA   SEE_IF_TEST_END ; Goto
FIGURE_TEXT_AND_POS: ; 0x00556C, $C56C
    LDU   #$C08B ; AUTO UP
    CMPA  #$18 ; If A _ 0x18
    BCS   DONT_RANGE_A ; <, goto.
    SUBA  #$10 ; A -= 0x10
DONT_RANGE_A: ; 0x005575, $C575
    ASLA ; A *= 2
    LEAU  A,U ; U = U + A
    TFR   X>D ; X to D
    SUBD  R_A041_TEST_TEMP/RUG_MISMATCH_BITS ; D -= addr
    LDA   #$0A ; A =
    MUL ; A * B to D
    ADDD  #$3830 ; += base
    TFR   D>X ; POS X
    RTS
MONITOR_TEST: ; 0x005585, $C585
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    JSR   SET_COLOR_PALETTE_0x01_WHITE
    LDU   #$C089 ; Sentence MONITOR TEST
    LDX   #$2880
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN
    LDY   #$C05D ; AUTO FOR AUDIT, GAME ADJUSTMENT
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    LDX   #$CC00 ; ROM PIA, COIN DOOR
LOOP_MONITOR_TEST: ; 0x00559E, $C59E
    LDU   #$C9F4
LOOP_MONITOR_ROUTINES: ; 0x0055A1, $C5A1
    JSR   JMP_LOAD_B@X_BANK0 ; Load pressed
    BITB  #$01 ; Test man/auto
    BEQ   AUTO/MAN_NOT_PRESSED ; Not pressed, goto.
    LDY   #$1388 ; Timer
    JSR   AUTO+ADV_CHECK ; Do
    TST   UNK_$49_SYS_MENU_FLAG? ; Test leave flag
    LBNE  SETTINGS_MENU? ; If set, goto settings menu.
    JSR   JMP_LOAD_B@X_BANK0 ; Load B from X
    BITB  #$01 ; Test auto/man
    BNE   IS_PRESSED ; Button set
AUTO/MAN_NOT_PRESSED: ; 0x0055BC, $C5BC
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS ; Test keys
    TST   UNK_$49_SYS_MENU_FLAG? ; Test leave
    LBNE  SETTINGS_MENU? ; If set, goto.
IS_PRESSED: ; 0x0055C5, $C5C5
    PSHS  U,Y,X ; Save
    JSR   [U]
    PULS  X,Y,U
    LEAU  2,U
    CMPU  #$C9FE
    BNE   LOOP_MONITOR_ROUTINES ; Loop if not done.
    LDY   #$1388
    JSR   AUTO+ADV_CHECK
    TFR   CC>B
    TSTB
    LBPL  FAILED_WITH_AUTO_NOT_PRESSED
    BRA   LOOP_MONITOR_TEST
MONITOR_PTR_CODE_1: ; 0x0055E3, $C5E3
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Switches, but probs for watchdog.
    JSR   JMP_CLEAR_ALL_SCREEN ; Clear screen
    JSR   CLEAR_COLOR_PALETTE ; Clear palette.
    LDX   #$C001 ; Store colors x 4
    LDB   #$FF
    JSR   JMP_STORE_B@X_BANK0
    LDX   #$C002
    LDB   #$C0
    JSR   JMP_STORE_B@X_BANK0
    LDX   #$C003
    LDB   #$38
    JSR   JMP_STORE_B@X_BANK0
    LDX   #$C004
    LDB   #$07
    JSR   JMP_STORE_B@X_BANK0
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Switches/watchdog.
    LDY   #$C6F7 ; Ptr to data
    LDD   #$0101 ; D
LOOP_DATA_TABLE: ; 0x005616, $C616
    LDX   Y ; X from data
LOOP_DRAW_VLINE_TO_END: ; 0x005618, $C618
    STD   X++ ; D to X
    CMPX  2,Y ; Compare to end
    BNE   LOOP_DRAW_VLINE_TO_END ; Loop if not done
    LEAY  4,Y ; Y to next slot.
    CMPY  #$C71F
    BNE   LOOP_DATA_TABLE
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog
    LDA   #$11 ; A =
    LDY   #$C6D7 ; Y =
LOOP_HLINE_MACRO: ; 0x00562F, $C62F
    LDX   Y ; X from Y
    STX   R_A045_LINE_DRAW_CR_XXYY ; to
LOOP_DRAW_HLINE_TO_END: ; 0x005633, $C633
    STA   X ; A to X
    INC   R_A045_LINE_DRAW_CR_XXYY ; POSX++?
    LDX   R_A045_LINE_DRAW_CR_XXYY ; X from
    CMPX  2,Y ; CMP to PTR[2], end
    BNE   LOOP_DRAW_HLINE_TO_END ; Loop if not done.
    LEAY  4,Y ; Next slot.
    CMPY  #$C6F7 ; End of data table.
    BNE   LOOP_HLINE_MACRO ; Loop table.
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog
    LDY   #$C71F ; Ptr to table.
LOOP_CUSTOM_PIXELS_V_MACRO: ; 0x00564C, $C64C
    LDX   Y ; Load from slot[0]
    STX   R_A045_LINE_DRAW_CR_XXYY ; X to
    LDA   4,Y ; A from slot[4]
LOOP_DRAW_CUSTOM_PIXELS_V: ; 0x005652, $C652
    STA   X ; A to Xaddr
    INC   R_A045_LINE_DRAW_CR_XXYY ; XPOS++
    LDX   R_A045_LINE_DRAW_CR_XXYY ; Load pos
    CMPX  2,Y ; Compare to end.
    BNE   LOOP_DRAW_CUSTOM_PIXELS_V ; Branch if not done.
    LEAY  5,Y ; Next slot
    CMPY  #$C75B ; End compare
    BNE   LOOP_CUSTOM_PIXELS_V_MACRO ; Not done
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog
    LDY   #$C75B ; Next table
LOOP_CUSTOM_PIXELS_H_MACRO: ; 0x00566B, $C66B
    LDX   Y ; X start
    LDA   4,Y ; A from slot[4]
LOOP_CUSTOM_PIXELS_H: ; 0x00566F, $C66F
    STA   X+ ; Store to X
    CMPX  2,Y ; CMP to end
    BNE   LOOP_CUSTOM_PIXELS_H
    LEAY  5,Y ; Slot++
    CMPY  #$C76F ; End of slot.
    BNE   LOOP_CUSTOM_PIXELS_H_MACRO ; Loop if not done.
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog
    LDA   #$21 ; Val..
    STA   $467E ; To screen
    LDA   #$20 ; Different...
    STA   $967E ; To screen
    LDX   #$4E0A ; X=
LOOP_LOWER_NIBBLE_MANIP: ; 0x00568D, $C68D
    LDA   X ; A from X
    ANDA  #$F0 ; Keep upper nibble.
    ORA   #$02 ; Lower nibble = 0x2
    STA   X+ ; A to X, onward.
    CMPX  #$4E6D ; End
    BNE   LOOP_LOWER_NIBBLE_MANIP ; Loop
    LDX   #$4E90 ; New X
LOOP_LOWER_NIBBLE_MANIP_2: ; 0x00569D, $C69D
    LDA   X ; Load A
    ANDA  #$F0 ; Keep upper nibble.
    ORA   #$02 ; Set lower nibble.
    STA   X+ ; Store back
    CMPX  #$4EF3 ; End?
    BNE   LOOP_LOWER_NIBBLE_MANIP_2
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog
    LDX   #$0E18 ; SCR POS to start
    STX   R_A045_LINE_DRAW_CR_XXYY ; SCR POS CR, basically.
LOOP_MOD_NIBBLE: ; 0x0056B2, $C6B2
    LDX   R_A045_LINE_DRAW_CR_XXYY ; X from
    LDA   X ; A from X
    ANDA  #$F0 ; Upper nibble.
    ORA   #$01 ; Lower nibble to val
    STA   X ; Store back
    LDB   R_A045_LINE_DRAW_CR_XXYY+1 ; B =
    ADDB  #$22 ; B += 0x22
    BCS   B_ADD_OVERFLOW ; If overflow, goto.
    STB   R_A045_LINE_DRAW_CR_XXYY+1 ; Store B otherwise.
    BRA   LOOP_MOD_NIBBLE
B_ADD_OVERFLOW: ; 0x0056C6, $C6C6
    LDB   #$18 ; Reset B
    STB   R_A045_LINE_DRAW_CR_XXYY+1 ; Reset
    LDB   R_A045_LINE_DRAW_CR_XXYY
    ADDB  #$10 ; X+=16
    STB   R_A045_LINE_DRAW_CR_XXYY
    CMPB  #$9E ; Off screen.
    BNE   LOOP_MOD_NIBBLE
    JMP   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
MONITOR_TEST_TABLE_2: ; 0x0056D7, $C6D7
    .db $07
    .db $07
    .db $97
    .db $07
    .db $07
    .db $29
    .db $97
    .db $29
    .db $07
    .db $4B
    .db $97
    .db $4B
    .db $07
    .db $6D
    .db $97
    .db $6D
    .db $07
    .db $8F
    .db $97
    .db $8F
    .db $07
    .db $B1
    .db $97
    .db $B1
    .db $07
    .db $D3
    .db $97
    .db $D3
    .db $07
    .db $F5
    .db $97
    .db $F5
DATA_MONITOR_TABLE_1: ; 0x0056F7, $C6F7
    .db $06 ; fmt: [StartW,EndW]
    .db $07
    .db $06
    .db $F5
    .db $16
    .db $07
    .db $16
    .db $F5
    .db $26
    .db $07
    .db $26
    .db $F5
    .db $36
    .db $07
    .db $36
    .db $F5
    .db $46
    .db $07
    .db $46
    .db $F5
    .db $56
    .db $07
    .db $56
    .db $F5
    .db $66
    .db $07
    .db $66
    .db $F5
    .db $76
    .db $07
    .db $76
    .db $F5
    .db $86
    .db $07
    .db $86
    .db $F5
    .db $96
    .db $07
    .db $96
    .db $F5
MONITOR_PATTERN_TABLE_3: ; 0x00571F, $C71F
    .db $48 ; fmt:[startw,endw,pixel]
    .db $05
    .db $55
    .db $05
    .db $44
    .db $48
    .db $06
    .db $55
    .db $06
    .db $44
    .db $48
    .db $07
    .db $55
    .db $07
    .db $00
    .db $48
    .db $08
    .db $55
    .db $08
    .db $33
    .db $48
    .db $09
    .db $55
    .db $09
    .db $33
    .db $48
    .db $F3
    .db $55
    .db $F3
    .db $33
    .db $48
    .db $F4
    .db $55
    .db $F4
    .db $33
    .db $48
    .db $F5
    .db $55
    .db $F5
    .db $00
    .db $48
    .db $F6
    .db $55
    .db $F6
    .db $44
    .db $48
    .db $F7
    .db $55
    .db $F7
    .db $44
    .db $07
    .db $7E
    .db $46
    .db $7E
    .db $22
    .db $57
    .db $7E
    .db $96
    .db $7E
    .db $22
MONITOR_PATERN_TABLE_4: ; 0x00575B, $C75B
    .db $05
    .db $6F
    .db $05
    .db $8E
    .db $04
    .db $06
    .db $6F
    .db $06
    .db $8E
    .db $30
    .db $96
    .db $6F
    .db $96
    .db $8E
    .db $00
    .db $97
    .db $6F
    .db $97
    .db $8E
    .db $34
MONITOR_PTR_CODE_2: ; 0x00576F, $C76F
    JSR   JMP_CLEAR_ALL_SCREEN
    LDB   #$05
UPDATE_PALETTE_WITH_B?: ; 0x005774, $C774
    LDX   #$C000 ; PTR to palette?
    BSR   JMP_STORE_B@X_BANK0
    LDX   #$C00C ; Also here?
JMP_STORE_B@X_BANK0: ; 0x00577C, $C77C
    JMP   JMP_STORE_B@X_BANK0 ; Store B to palette.
MONITOR_PTR_CODE_3: ; 0x00577F, $C77F
    LDB   #$28 ; B=
    BRA   UPDATE_PALETTE_WITH_B?
MONITOR_PTR_CODE_4: ; 0x005783, $C783
    LDB   #$80
    BRA   UPDATE_PALETTE_WITH_B?
MONITOR_PTR_CODE_5: ; 0x005787, $C787
    LDY   #$C9FE ; Use this palette.
    JSR   UPLOAD_PALETTE_@Y
    JMP   DRAW_BANDS_OF_COLORS?
SET_COLOR_PALETTE_0x01_WHITE: ; 0x005791, $C791
    LDB   #$A5 ; R=5/7, G=4/7, B=2/3
SET_COLOR_$C001: ; 0x005793, $C793
    LDX   #$C001
    JMP   JMP_STORE_B@X_BANK0
SETTINGS_MENU?: ; 0x005799, $C799
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    BSR   SET_COLOR_PALETTE_0x01_WHITE
    LDU   #$C0D7 ; PTR to SENTENCE WILLIAMS DEFENDER
    LDX   #$2820 ; POS
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Do once? Setup?
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Put to screen
    LDY   #$C061 ; SENTENCE AUTO FOR GAME OVER
    JSR   GOTO_C023_B2_PREP_PRESS_ADV_WITH_SWITCH_SET_FOR...
    LDY   #$05DC ; Timer?
    JSR   AUTO+ADV_CHECK ; Check for buttons.
    TST   UNK_$49_SYS_MENU_FLAG? ; Test
    BNE   LEAVE_SETTINGS_MENU ; Flag set, goto.
    CLR   R_A03C_OPTION_ON ; Clear IDK
    LDA   #$01
    STA   R_AO3B_UPDATE_SCREEN? ; Set...
    LEAS  -32,S ; Get 32 bytes at stack pointer?
    JSR   JMP_CLEAR_ALL_SCREEN ; Clear screen.
    LDU   #$C0D7 ; PTR to SENTENCE WILLIAMS DEFENDER
    LDX   #$2820 ; POS
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Do...
    JSR   GOTO_C002_B2_SENTENCE_TO_SCREEN ; Put to screen.
    CLR   R_A03A_MENU_UNK ; Clear...
    LDY   #$C065 ; SENTENCE PRESS HIGH SCORE RESET TO MAKE CHANGE
    JSR   GOTO_C020_B2_PREP_PRESS_ADV_TO_STEP_THRU
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Do
    LDA   #$20 ; Space val
    TFR   A>B ; To B
    DECB ; Loop--
    LEAX  S ; S pos to X
LOOP_CLEAR_TEXT_BUF: ; 0x0057EA, $C7EA
    STA   X+ ; Space to text buf.
    DECB ; Loop--
    BNE   LOOP_CLEAR_TEXT_BUF
    LDA   #$2F ; End of string value.
    STA   X+ ; Store
    LEAX  S ; Reset X
LOOP_WAIT_FOR_INPUT_MENU?: ; 0x0057F5, $C7F5
    JSR   ADV+AUTO_CUMULATIVE ; Do
    LDX   #$CC00
    JSR   JMP_LOAD_B@X_BANK0 ; ROM PIA DATA_A
    BITB  #$02 ; Test ADV
    BEQ   DONT_CHANGE_MENU_OPTION ; Not set
    BITB  #$01 ; Test AUTO/MANUAL toggle.
    BNE   INC_VALS_IDK ; AUTO/MAN SET, increase.
    INC   R_AO3B_UPDATE_SCREEN? ; Inc IDK
    DEC   R_A03C_OPTION_ON ; --
    BPL   DONT_CHANGE_MENU_OPTION ; Exit if okay.
    LDB   #$1B ; Reseed to last.
    STB   R_A03C_OPTION_ON ; Store back.
    BRA   DONT_CHANGE_MENU_OPTION ; Skip other.
INC_VALS_IDK: ; 0x005812, $C812
    INC   R_A03C_OPTION_ON ; Inc
    INC   R_AO3B_UPDATE_SCREEN? ; Inc
    LDA   #$1C ; 28th option.
    CMPA  R_A03C_OPTION_ON
    BNE   DONT_CHANGE_MENU_OPTION ; Not on 28th option.
    LEAS  32,S ; Fix stack space reserved.
LEAVE_SETTINGS_MENU: ; 0x00581F, $C81F
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Check one more time, watchdog use here?
    JMP   JMP_TO_RUG_PASS_SRAM_CHECK ; Go to game.
DONT_CHANGE_MENU_OPTION: ; 0x005825, $C825
    JSR   SUB_IDK ; Idk
    TST   R_AO3B_UPDATE_SCREEN? ; Test addr
    BEQ   LOOP_WAIT_FOR_INPUT_MENU? ; If 0, loop.
    LDB   R_A03C_OPTION_ON
    CMPB  #$09 ; If B _ 9
    BNE   NOT_NINE ; !=, goto.
    LDX   #$C487 ; X assumed?
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data
    TSTB ; Test loaded
    BEQ   NOT_NINE ; Is 0, goto.
    CMPB  #$08 ; B _ val
    BHI   SRAM_INIT_UNK_NOT_SUB ; >, goto.
    JSR   SRAM_INIT_UNK ; Init SRAM area...
    BRA   NOT_NINE ; goto.
SRAM_INIT_UNK_NOT_SUB: ; 0x005844, $C844
    LDX   #$C487 ; SRAM PTR
    PSHS  X ; Save to stack
    LDB   #$01 ; Val
    JSR   JMP_STORE_B_TO_SRAM[X] ; Store B to SRAM...
    JSR   SRAM_INIT_UNK ; Now init???
    CLRB ; Clear B
    PULS  X ; Restore X
    JSR   JMP_STORE_B_TO_SRAM[X] ; Store cleared here...
NOT_NINE: ; 0x005857, $C857
    BSR   SETTING_UPDATE
    LDA   R_A03A_MENU_UNK ; Load addr
    CMPA  #$06 ; If A _ 6
    BEQ   INPUT_STUFF ; ==, goto.
    TSTA ; If A...
    BNE   LOAD_WITH_6 ; != 0, goto.
    LDA   #$64 ; Val if A=0
    BRA   SKIP_OTHER_LOAD
LOAD_WITH_6: ; 0x005866, $C866
    LDA   #$06
SKIP_OTHER_LOAD: ; 0x005868, $C868
    STA   R_A03A_MENU_UNK ; Store to.
    INCA ; A++
    LDB   #$FF ; B=
INPUT_STUFF: ; 0x00586D, $C86D
    JSR   ADV+AUTO_CUMULATIVE ; Do
    DECA ; A--
    BEQ   A_COUNTDOWN_ENDED
    LDX   #$CC00 ; ROM PIA DATA_A
    PSHS  B ; Save B asis.
    JSR   JMP_LOAD_B@X_BANK0 ; Get input.
    BITB  #$0A ; Test HSR+ADV
    BNE   BUTTONS_PRESSED
    ANDCC #$FE ; Clear CC.c
    BRA   BUTTON_PRESSED_CC
BUTTONS_PRESSED: ; 0x005883, $C883
    ORCC  #$01 ; Set CC
BUTTON_PRESSED_CC: ; 0x005885, $C885
    PULS  B ; Pull
    RORB ; Rotate bringing in pressed.
    BNE   INPUT_STUFF ; If any set, loop.
    CLR   R_A03A_MENU_UNK ; Clear
A_COUNTDOWN_ENDED: ; 0x00588C, $C88C
    CLR   R_AO3B_UPDATE_SCREEN? ; Updated.
    JMP   LOOP_WAIT_FOR_INPUT_MENU? ; Loop back to the beginning.
SETTING_UPDATE: ; 0x005891, $C891
    LEAY  2,S ; Y from S[2], PTR stream?
    LDX   #$1080 ; POS
    JSR   GOTO_C01A_B2_SPECIAL_TO_SCREEN ; Cleared
    JSR   SUB_CLEAR_TEXT_BUF+RESET_X_POS ; Clear text buffer.
    LDA   R_A03C_OPTION_ON ; Load
    INCA ; ++ for display, 0 disp as 1, 1>2, etc.
    JSR   A_TO_DECIMAL ; To decimal.
    JSR   A_TO_AB_ASCII ; To displayable.
    STD   X ; Text to X
    LDB   R_A03C_OPTION_ON ; Load
    ASLB ; << 2, *4
    ASLB
    LDX   #$CCD6 ; Ptr to data
    ABX ; X+=B
    LDY   X ; X[0] to Y, text move ptr.
    LDU   2,X ; U from X[2], attribute data.
    LEAX  14,S ; X = S[14], text ptr.
LOOP_MOVE_TEXT: ; 0x0058B6, $C8B6
    LDA   Y+ ; Load from text moving.
    CMPA  #$2F ; \0?
    BEQ   EXIT_MOVE_LOOP ; ==, yes, goto.
    STA   X+ ; Store to ptr.
    BRA   LOOP_MOVE_TEXT
EXIT_MOVE_LOOP: ; 0x0058C0, $C8C0
    TFR   U>D ; Attributes to A/B
    LEAU  2,S ; U = S[2], text buffer.
    LDX   #$C400 ; SRAM PTR
    ABX ; X += B
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get val
    PSHS  B,A ; Save B, and A settings.
    LDB   R_A03C_OPTION_ON ; Get option
    INCB ; Inc
    CMPB  #$07 ; If changable from menu...
    BHI   IS_POSSIBLY_6_DIGIT
4_DIGIT_TO_BUF: ; 0x0058D4, $C8D4
    PULS  A,B ; Pull
    TFR   B>A ; Overwrite settings.
    JSR   A_TO_AB_ASCII ; Get ascii.
    STD   7,U ; Store to text buf.
    JSR   JMP_GET_DATA_FROM_SRAM[X]_IN_A ; Get other bytes.
2_DIGIT_TO_BUF: ; 0x0058E0, $C8E0
    JSR   A_TO_AB_ASCII ; To ascii.
    STD   9,U ; To text buf.
    BRA   POST_DISPLAY_SETTING_ASCII ; Goto.
IS_POSSIBLY_6_DIGIT: ; 0x0058E7, $C8E7
    CMPB  #$08
    BNE   NOT_6_DIGIT ; Not long val, goto.
    LDD   #$3030 ; This is ship bonus level here. Two blanks.
    STD   9,U ; To
    LEAU  -2,U ; Move buf ptr.
    BRA   4_DIGIT_TO_BUF ; Put val to buf.
NOT_6_DIGIT: ; 0x0058F4, $C8F4
    PULS  A,B ; Pull setting and B
    TFR   B>A ; Move.
    BRA   2_DIGIT_TO_BUF ; Do 2 digit.
POST_DISPLAY_SETTING_ASCII: ; 0x0058FA, $C8FA
    LDX   #$1080 ; Pos
    LEAY  2,S ; Y = S[2]
    JMP   GOTO_C01D_B2_SPECIAL_FROM_SCREEN ; Display this.
A_TO_DECIMAL: ; 0x005902, $C902
    PSHS  B ; Save B
    TFR   A>B ; A to B
    LDA   #$99 ; A =
LOOP_B_STILL_POSITIVE: ; 0x005908, $C908
    ADDA  #$01 ; A+=1
    DAA ; Decimal
    DECB ; Loop--
    BPL   LOOP_B_STILL_POSITIVE
    PULS  B,PC ; RTS
A_TO_AB_ASCII: ; 0x005910, $C910
    TFR   A>B ; A to B
    ANDA  #$F0 ; Keep top nibble.
    LSRA ; A >> 4
    LSRA
    LSRA
    LSRA
    ADDA  #$30 ; A +=
    ANDB  #$0F
    ADDB  #$30
    RTS
SUB_CLEAR_TEXT_BUF+RESET_X_POS: ; 0x00591F, $C91F
    LDA   #$20 ; Spaces
    TFR   A>B ; Loop count also.
    DECB ; Loop--
    LEAX  4,S ; X = S[4]
LOOP_WRITE_BLANKS: ; 0x005926, $C926
    STA   X+ ; Space to X
    DECB ; Loop++
    BNE   LOOP_WRITE_BLANKS
    LDA   #$2F ; End of string.
    STA   X+ ; Store
    LEAX  4,S ; X = S[4]
    RTS
INC_SRAM_VAL: ; 0x005932, $C932
    CMPX  #$C481 ; If X _ val
    BNE   SRAM_INC_@X ; Nope, inc with this.
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_AB ; Get SRAM
    LEAX  -4,X ; Fix addr stored back to.
    EXG   A-B ; XXYY, YY to A
    ADDA  #$10 ; += dec
    DAA ; Adjust
    BCC   EXCHANGE_AND_STORE_D_BACK ; Don't need to fix.
    EXG   A-B ; Exchange for DAA again
    ADDA  #$01 ; Add dec
ADJUST_EXG_STORE_BACK+UNK: ; 0x005947, $C947
    DAA ; Adjust
    EXG   A-B ; Exchange
EXCHANGE_AND_STORE_D_BACK: ; 0x00594A, $C94A
    EXG   A-B ; Exchange
    INC   R_AO3B_UPDATE_SCREEN? ; Inc this
    JMP   JMP_STORE_D_TO_SRAM[X] ; Store to SRAM
SRAM_INC_@X: ; 0x005951, $C951
    JSR   JMP_GET_DATA_FROM_SRAM[X]_IN_A ; Get X
    ADDA  #$01 ; Inc
ADJUST_AND_STORE_BACK: ; 0x005956, $C956
    DAA ; Adjust
    LEAX  -2,X ; X -= 2 to restore.
    INC   R_AO3B_UPDATE_SCREEN? ; Inc
    JMP   JMP_STORE_A_TO_SRAM_@X_BANKED ; Do.
DEC_SRAM_VAL: ; 0x00595E, $C95E
    CMPX  #$C481 ; If X _ val
    BNE   SUB_SRAM_X_BY_1 ; !=, goto.
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_AB ; Get in A/B
    LEAX  -4,X ; Restore X
    EXG   A-B ; Exchange
    ADDA  #$90 ; A -= 10
    DAA ; Adjust
    EXG   A-B ; Exchange back
    ADCA  #$99 ; A -= 1
    BRA   ADJUST_EXG_STORE_BACK+UNK
SUB_SRAM_X_BY_1: ; 0x005973, $C973
    JSR   JMP_GET_DATA_FROM_SRAM[X]_IN_A ; Get SRAM data
    ADDA  #$99 ; -1 DAA
    BRA   ADJUST_AND_STORE_BACK
SUB_IDK: ; 0x00597A, $C97A
    LDB   R_A03C_OPTION_ON ; Load val
    INCB ; B++
    CMPB  #$07 ; If B _ 7
    BHI   IDK ; >, goto.
RTS: ; 0x005981, $C981
    RTS
IDK: ; 0x005982, $C982
    CMPB  #$09 ; If B _ 9
    BLS   IDK_2 ; <=, goto.
    CMPB  #$10 ; If B _ 0x10
    BHI   IDK_2 ; >, goto.
    CMPB  #$0A ; If B _ #$0A
    BEQ   IDK_2 ; ==, goto.
    LDX   #$C487
    JSR   JMP_GET_DATA_FROM_SRAM[X]_IN_A ; Get data
    TSTA
    BNE   RTS ; If set, RTS.
IDK_2: ; 0x005997, $C997
    DECB ; B--
    ASLB ; << 2, *4
    ASLB
    LDX   #$CCD6 ; PTR
    ABX ; PTR + B
    LDB   3,X ; Load PTR[3]
    LDX   #$C400 ; Load other PTR
    ABX ; += B
    PSHS  X ; Save to stack.
GOTO_ABOVE: ; 0x0059A6, $C9A6
    JSR   ADV+AUTO_CUMULATIVE ; Do
    LDX   #$CC00 ; ROM PIA DATA_A
    JSR   JMP_LOAD_B@X_BANK0 ; Load from
    BITB  #$02 ; Test bit.
    BEQ   ADV_NOT_SET ; Not set
    PULS  X,PC ; RTS
ADV_NOT_SET: ; 0x0059B5, $C9B5
    BITB  #$08 ; Test HIGH SCORE RESET input.
    BNE   HSR_NOT_SET ; Set
    CLR   R_A03A_MENU_UNK ; Clear val
    BRA   GOTO_ABOVE ; Loop?
HSR_NOT_SET: ; 0x0059BD, $C9BD
    PULS  X ; Get X
    CMPX  #$C47D ; If X _ val
    BNE   INC_OR_DEC_SRAM_@X_DEP_ON_B:0 ; !=, goto.
    PSHS  X,B ; Save B+X
    LDX   #$C400
    LDB   #$01
    JSR   JMP_STORE_B@X_BANK0 ; Store
    PULS  B,X ; Use this X and B
INC_OR_DEC_SRAM_@X_DEP_ON_B:0: ; 0x0059D0, $C9D0
    LSRB ; B >> 1, auto/man switch test.
    LBCS  INC_SRAM_VAL ; If shifted off 1.
    JMP   DEC_SRAM_VAL ; If shifted off 0.
PALETTE_CRAM_TEST: ; 0x0059D8, $C9D8
    .db $02
    .db $03
    .db $04
    .db $10
    .db $18
    .db $20
    .db $40
    .db $80 ; END OF DATA
COLOR_DATA_IDK: ; 0x0059E0, $C9E0
    .db $00
    .db $FF
    .db $11
    .db $EE
    .db $22
    .db $DD
    .db $33
    .db $CC
    .db $44
    .db $BB
    .db $55
    .db $AA
    .db $66
    .db $99
    .db $77
    .db $88 ; END OF DATA
    .db $13 ; Ptr to this byte, idk why.
    .db $1B
    .db $1C
    .db $00
MONITOR_TEST_IDK: ; 0x0059F4, $C9F4
    .db $C5 ; fmt: [SUB_CODE_PTR]
    .db $E3
    .db $C7
    .db $6F
    .db $C7
    .db $7F
    .db $C7
    .db $83
    .db $C7
    .db $87
PALETTE_MONITOR_5: ; 0x0059FE, $C9FE
    .db $05
    .db $05
    .db $28
    .db $28
    .db $80
    .db $80
    .db $00
    .db $00
    .db $AD
    .db $AD
    .db $2D
    .db $2D
    .db $A8
    .db $A8
    .db $85
    .db $85
WAIT_ADV_NONPRESS_THEN_PRESS: ; 0x005A0E, $CA0E
    LDX   #$CC00 ; PIA_ROM_A
    LDY   #$0064 ; Times...
LOOP_IF_PRESSED: ; 0x005A15, $CA15
    JSR   AUTO+ADV_CHECK ; Adv+auto check rtn.
    JSR   JMP_LOAD_B@X_BANK0 ; Get data too...
    BITB  #$02 ; Test adv pressed.
    BNE   LOOP_IF_PRESSED ; Loop if pressed.
LOOP_IF_NONPRESSED: ; 0x005A1F, $CA1F
    JSR   AUTO+ADV_CHECK ; Adv+auto check rtn.
    JSR   JMP_LOAD_B@X_BANK0 ; Get.
    BITB  #$02 ; Test adv pressed.
    BEQ   LOOP_IF_NONPRESSED
    RTS
CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF: ; 0x005A2A, $CA2A
    JSR   JMP_CLEAR_ALL_SCREEN ; Clear screen.
    BSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog+ADV+AUTO
    JSR   CLEAR_COLOR_PALETTE ; Clear palette
    DEC   UNK_$49_SYS_MENU_FLAG? ; Dec menu flag?
    BPL   RTS ; DEC counter. If it's positive, don't clear?
    CLR   UNK_$49_SYS_MENU_FLAG? ; Clear if neg...idfk.
RTS: ; 0x005A38, $CA38
    RTS ; Leaves.
SINGLE_CHECK_AUTO+ADV: ; 0x005A39, $CA39
    LDY   #$0001 ; Loop 1 check
LOOP_READ_BUTTONS: ; 0x005A3D, $CA3D
    BSR   AUTO+ADV_CHECK
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag
    BEQ   LOOP_READ_BUTTONS ; If zero, loop.
    RTS
AUTO+ADV_CHECK: ; 0x005A44, $CA44
    PSHS  Y,A,CC
READ_SWITCHES: ; 0x005A46, $CA46
    BSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag set in above, set if both ADV+AUTO pressed.
    BNE   LEAVE_RTN ; If triggered, leave.
    LDA   #$B2 ; Load delay.
READ_SWITCHES_DELAY.: ; 0x005A4E, $CA4E
    DECA
    BNE   READ_SWITCHES_DELAY.
    LEAY  -1,Y ; One less time.
    BNE   READ_SWITCHES ; If Y not 0, keep going.
LEAVE_RTN: ; 0x005A55, $CA55
    PULS  CC,A,Y,PC ; Leaves
ADV+AUTO_CUMULATIVE: ; 0x005A57, $CA57
    PSHS  Y,B ; Save loop, idk why B.
    LDB   UNK_$49_SYS_MENU_FLAG? ; Save?
    CLR   UNK_$49_SYS_MENU_FLAG? ; Clear
    LDY   #$000A ; Check for button X times.
    BSR   AUTO+ADV_CHECK ; Wait for switches?
    ADDB  UNK_$49_SYS_MENU_FLAG? ; Add trigger count.
    STB   UNK_$49_SYS_MENU_FLAG? ; Store back.
    PULS  B,Y,PC ; RTS
WATCHDOG/TRIGGER_$49_ON_AUTO+ADV: ; 0x005A69, $CA69
    PSHS  X,B,CC ; Save
    LDB   #$38 ; Setup watchdog.
    LDX   #$C3FC ; Ptr to write.
    JSR   JMP_STORE_B@X_BANK0 ; Set watchdog.
    LDX   #$CC00 ; Ptr to read.
    JSR   JMP_LOAD_B@X_BANK0 ; Get ROM PIA-A
    COMB ; Invert, active 0 now. CC.c=1 with this. Very important to note.
    ANDB  #$03 ; Test auto/adv
    BEQ   BOTH_PRESSED ; Both pressed.
    ANDCC #$FE ; Clear CC.c
BOTH_PRESSED: ; 0x005A80, $CA80
    LDB   UNK_$47_AUTO+ADV ; Get val
    RORB ; rotate into B
    STB   UNK_$47_AUTO+ADV ; Store
    BNE   NOT_ZERO ; If not zero, skip clearing $48.
    STB   UNK_$48_AUTO+ADV ; Clear if zero.
NOT_ZERO: ; 0x005A89, $CA89
    COMB ; Invert again
    BNE   RTS ; If any bit not set, exit.
    LDB   UNK_$48_AUTO+ADV ; Get val
    BNE   RTS ; If not zero, RTS.
    COMB ; Invert, now 0xFF.
    STB   UNK_$48_AUTO+ADV ; Store to.
    INC   UNK_$49_SYS_MENU_FLAG? ; INC addr.
RTS: ; 0x005A95, $CA95
    PULS  CC,B,X,PC ; RTS
UPLOAD_PALETTE_@Y: ; 0x005A97, $CA97
    PSHS  Y,X,B ; Save
    LDX   #$C000 ; PTR
LOOP_UPLOAD_PALETTE: ; 0x005A9C, $CA9C
    LDB   Y+ ; Get daya from Y
    JSR   JMP_STORE_B@X_BANK0 ; Store.
    LEAX  1,X ; X++
    CMPX  #$C010 ; End?
    BNE   LOOP_UPLOAD_PALETTE
    PULS  B,X,Y,PC ; RTS
ROM_BOARD_LED_DISPLAY_B: ; 0x005AAA, $CAAA
    PSHS  X,B ; Save
    LSRB ; Bring 0 in.
    RORB
    RORB
    RORB ; Shift 4x total here.
    BPL   DONT_INC ; If B bit 2 clear originally, not sure why.
    INCB ; +=1 if origin B:2 was set.
DONT_INC: ; 0x005AB3, $CAB3
    RORB
    RORB ; Shift 6x total, this is to display the original bottom bits?
    LDX   #$CC00 ; Store to ROM_PIA_A_DATA
    JSR   JMP_STORE_B@X_BANK0 ; Store LED's.
    ASLB ; Shift in 3 zeros.
    ASLB
    ASLB
    ORB   #$3F ; Set bits to sound board. Silence?
    LDX   #$CC02 ; Store to ROM_PIA_B_DATA
    JSR   JMP_STORE_B@X_BANK0 ; Store LED's.
    PULS  B,X,PC
ROM_LED_BLINK_STARTUP?: ; 0x005AC8, $CAC8
    PSHS  Y,B,A ; Save
    LDA   #$02 ; Loop count?
    LDY   #$01F4 ; Unk val. Timer?
LOOP_LED_BLINK?: ; 0x005AD0, $CAD0
    JSR   ROM_BOARD_LED_DISPLAY_B ; Write B
    JSR   AUTO+ADV_CHECK
    CLRB ; Clear B
    JSR   ROM_BOARD_LED_DISPLAY_B ; Write cleared.
    JSR   AUTO+ADV_CHECK
    LDB   1,S ; Get original B.
    DECA ; Loop counter?
    BNE   LOOP_LED_BLINK? ; Loop blink.
    PULS  A,B,Y ; RTS
SETUP_52+49+48+36+59: ; 0x005AE4, $CAE4
    PSHS  B,A
    CLR   SENTENCE_PTR_WORD_ON
    CLR   UNK_$49_SYS_MENU_FLAG?
    LDA   #$01
    STA   UNK_$48_AUTO+ADV
    LDA   #$03
    STA   CURRENT_BANK
    LDD   #$FFFF
    STD   TEXT_PTR_UNK
    PULS  A,B,PC
CLEAR_COLOR_PALETTE: ; 0x005AF9, $CAF9
    PSHS  X,B ; Save
    CLRB
    LDX   #$C000
CLEAR_PALETTE_LOOP: ; 0x005AFF, $CAFF
    JSR   JMP_STORE_B@X_BANK0 ; Write 0
    LEAX  1,X ; Next
    CMPX  #$C010 ; Bound
    BNE   CLEAR_PALETTE_LOOP ; Loop
    PULS  B,X,PC ; RTS
OUTPUT_SOUND?: ; 0x005B0B, $CB0B
    PSHS  X,B ; Save
    COMB ; Invert
    ANDB  #$3F ; And bits.
    LDX   #$CC02 ; PTR to PIA_ROM_B
    JSR   JMP_STORE_B@X_BANK0 ; Store to
    JSR   ADV+AUTO_CUMULATIVE ; Switch stuff?
    LDB   #$3F ; Load
    JSR   JMP_STORE_B@X_BANK0 ; Store to.
    JSR   ADV+AUTO_CUMULATIVE ; Switch stuff?
    PULS  B,X,PC ; RTS
A+=16_PER_EACH_B_0xF0>>8_VALUE: ; 0x005B23, $CB23
    PSHS  A ; Save A
    TFR   B>A ; B to A
    ANDA  #$0F ; Bottom bits...
    ADDA  #$00 ; Idk why. Sets flags right?
    DAA ; Adjust decimal.
    ANDB  #$F0 ; Top bits, >>4 for loop count.
LOOP_ADD+SUB: ; 0x005B2E, $CB2E
    BEQ   IS_ZERO ; If =0
    ADDA  #$16 ; Add dec to A.
    DAA ; Adjust
    SUBB  #$10 ; Minus 10 on B.
    BRA   LOOP_ADD+SUB ; Loop...
IS_ZERO: ; 0x005B37, $CB37
    TFR   A>B ; A to B.
    PULS  A,PC ; RTS.
DRAW_BANDS_OF_COLORS?: ; 0x005B3B, $CB3B
    PSHS  X,B,A ; Save
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
NEW_TARGET_OUTPUT_COLOR: ; 0x005B43, $CB43
    STX   TEXT_PTR_TO_CODE_JSR ; Store to, target addr
    LEAX  3840,X ; +15 X
LOOP_OUTPUT_COLOR: ; 0x005B49, $CB49
    STD   --X ; D to --X
    CMPX  TEXT_PTR_TO_CODE_JSR ; If X _ target
    BNE   LOOP_OUTPUT_COLOR ; !=, goto.
    LEAX  2304,X ; XPOS += 9
    TSTA ; Test A
    BNE   A_NOT_ZERO ; Not 0, goto.
    LDX   #$0F00 ; Set X if A is 0, XPOX+15
A_NOT_ZERO: ; 0x005B59, $CB59
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Test buttons.
    TST   UNK_$49_SYS_MENU_FLAG? ; Test
    BNE   RTS ; If set, RTS
    ADDD  #$1111 ; Add color entry.
    BCC   NEW_TARGET_OUTPUT_COLOR ; Loop if no overflow.
RTS: ; 0x005B65, $CB65
    PULS  A,B,X,PC
DRAW_DATA_TO_STRIPS: ; 0x005B67, $CB67
    JSR   CLEAR_COLOR_PALETTE ; Colors to black
    LDX   #$0000 ; X =
    LDY   #$C9E0 ; PTR to data
LOOP_DRAW: ; 0x005B71, $CB71
    STX   TEXT_PTR_TO_CODE_JSR ; Store target
    LEAX  3840,X ; XPOS + 15
    LDA   Y+ ; Load A from Y
    TFR   A>B ; Clone to B
LOOP_OUTPUT_COLOR: ; 0x005B7B, $CB7B
    STD   --X ; To X
    CMPX  TEXT_PTR_TO_CODE_JSR ; Compare to target
    BNE   LOOP_OUTPUT_COLOR
    LEAX  2304,X ; X += 9
    TSTA ; Test A
    BNE   A_NOT_ZERO
    LDX   #$0F00 ; Set X
A_NOT_ZERO: ; 0x005B8B, $CB8B
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Buttons
    TST   UNK_$49_SYS_MENU_FLAG? ; Test leave
    BNE   RTS ; True, RTS
    CMPY  #$C9F0 ; Y end, 16 entries.
    BNE   LOOP_DRAW
RTS: ; 0x005B98, $CB98
    RTS
SRAM_INIT_UNK: ; 0x005B99, $CB99
    LDX   #$C487 ; Load PTR
    JSR   JMP_STORE_B_TO_SRAM[X] ; Store B?
    ASLB ; B >> 1
    PSHS  B ; Save
    ASLB ; B >> 1
    ADDB  S+ ; B += pushed? Clean up too.
    LDX   #$CF10 ; PTR to init data?
    ABX ; X += B
    LDY   #$C489 ; Y = SRAM PTR
    LDB   #$06 ; Loop count.
MOVE_@X_TO_SRAM@Y: ; 0x005BAF, $CBAF
    PSHS  A ; Save
LOOP_INIT_SRAM: ; 0x005BB1, $CBB1
    LDA   X+ ; Get data from ROM pointer.
    EXG   X-Y ; Put SRAM pointer to X
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Put to SRAM
    EXG   X-Y ; Move back to ROM pointer in X
    DECB ; Loop counter
    BNE   LOOP_INIT_SRAM
    PULS  A,PC
CLEAR_SRAM@0xC400_B_BYTES: ; 0x005BBF, $CBBF
    LDB   #$0E ; Bytes to clear up to. Not entries, bytes.
    BRA   CLEAR_B_BYTES_SRAM_FROM_0x400 ; Do.
CLEAR_ALL_SRAM: ; 0x005BC3, $CBC3
    CLRB ; Loop counter.
CLEAR_B_BYTES_SRAM_FROM_0x400: ; 0x005BC4, $CBC4
    LDX   #$C400 ; Start of SRAM
    CLRA ; Clear
LOOP_WRITE_A_TO_SRAM_B_TIMES: ; 0x005BC8, $CBC8
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Write location
    DECB ; loop--
    BNE   LOOP_WRITE_A_TO_SRAM_B_TIMES ; Loop
    RTS ; Leave
INIT_SRAM: ; 0x005BCF, $CBCF
    PSHS  Y,X,B,A ; Save
    BSR   CLEAR_ALL_SRAM ; Clear SRAM
    LDX   #$CECF ; CMOS_RAM_INIT_DATA
    LDY   #$C41D ; Pointer into CMOS RAM
    LDB   #$47 ; Times to loop
    BSR   MOVE_@X_TO_SRAM@Y ; Move data
    PULS  A,B,X,Y,PC ; RTS
BOOKKEEP_UPDATE_+1: ; 0x005BE0, $CBE0
    PSHS  X,B,A ; Save
    LDA   #$01 ; Adding
    BRA   BOOKKEEP_UPDATE_+A_RTN
BOOKKEEP_UPDATE_+A: ; 0x005BE6, $CBE6
    PSHS  X,B,A ; Save
BOOKKEEP_UPDATE_+A_RTN: ; 0x005BE8, $CBE8
    ANDB  #$07 ; And B
    BEQ   RTS_BOOKKEEP ; Invalid if 0.
    ASLB ; <<1
    ASLB ; <<1, *4 total
    LDX   #$C3FD ; SRAM index.
    ABX ; Add B to.
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data in B
    PSHS  B ; Save
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data in B
    PSHS  B ; Save
    ADDA  S+ ; Add A to second.
    DAA ; Adjust
    EXG   A-B ; Rotate because no DAB instruction.
    PULS  A ; Pull A
    ADCA  #$00 ; Add carry.
    DAA ; Adjust.
    LEAX  -4,X ; Original X ptr.
    JSR   JMP_STORE_D_TO_SRAM[X] ; Store D to.
RTS_BOOKKEEP: ; 0x005C0B, $CC0B
    PULS  A,B,X,PC
ADD_A_CREDITS_ROUTINE?: ; 0x005C0D, $CC0D
    PSHS  X,A ; Save
    ADDA  SRAM_C495-C496_PLAY_CREDITS ; A += VAL
    DAA ; Adjust
    BCC   NUM_IS_HIGHER
    LDA   #$99 ; CAP
NUM_IS_HIGHER: ; 0x005C16, $CC16
    STA   SRAM_C495-C496_PLAY_CREDITS ; Store to
    LDX   #$C47D ; SRAM ptr
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Store val to SRAM, credits?
    PULS  A,X,PC ; RTS
BOOKKEEP_COIN_3_+1: ; 0x005C20, $CC20
    PSHS  X,B,A
    LDB   #$03
    BRA   BOOKKEEP_COINS_IDK
BOOKKEEP_COIN_2_+1: ; 0x005C26, $CC26
    PSHS  X,B,A
    LDB   #$02
    BRA   BOOKKEEP_COINS_IDK
BOOKKEEP_COIN_1_+1: ; 0x005C2C, $CC2C
    PSHS  X,B,A
    LDB   #$01
BOOKKEEP_COINS_IDK: ; 0x005C30, $CC30
    JSR   BOOKKEEP_UPDATE_+1 ; Update correct bookkeep for total coins count.
    ASLB ; << 1, *2, for index of byte.
    LDX   #$C487 ; SRAM PTR
    ABX ; X += B
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data from SRAM in slot C489/C48B/C48D
    BSR   REG.B_DEC_TO_HEX_CONVERT ; Convert to hex
    LDA   R_A039_BOOKKEEP_SUB_CREDITS? ; Load val
    PSHS  B ; Save B hex
    ADDA  S ; A += B
    STA   R_A039_BOOKKEEP_SUB_CREDITS? ; Store back
    LDA   R_A038_BOOKKEEP_SUB_SUB_CREDITS? ; A from
    ADDA  S+ ; A += B, clean stack.
    STA   R_A038_BOOKKEEP_SUB_SUB_CREDITS? ; Store back.
    LDX   #$C493 ; SRAM data.
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get SRAM val
    BSR   REG.B_DEC_TO_HEX_CONVERT ; To hex
    PSHS  B ; Save B
    CMPA  S+ ; IF A _ B_STACK, clean stack also.
    BCC   DONT_RTS ; >=, goto.
    PULS  A,B,X,PC ; RTS. No credit yet?
DONT_RTS: ; 0x005C5B, $CC5B
    LDX   #$C48F ; Load SRAM from.
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data.
    BSR   REG.B_DEC_TO_HEX_CONVERT ; To hex
    BSR   RTN_DIVIDE_A_WITH_B,A_TIMES_B_REMAINDER ; Divide A with B, A times B remainder.
    PSHS  A ; Save A, total divisions successful for sub sub credits.
    STB   R_A038_BOOKKEEP_SUB_SUB_CREDITS? ; Remainder back to sub sub credits.
    LDX   #$C491 ; SRAM PTR
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get in B.
    LDA   R_A039_BOOKKEEP_SUB_CREDITS? ; A from
    BSR   REG.B_DEC_TO_HEX_CONVERT ; B to hex.
    BSR   RTN_DIVIDE_A_WITH_B,A_TIMES_B_REMAINDER ; Divide A with B, A times B remainder.
    TSTA ; Test A
    BEQ   A_IS_ZERO ; If not a full credit, don't clear credit trackers.
    CLR   R_A038_BOOKKEEP_SUB_SUB_CREDITS? ; If not 0, clear.
    CLR   R_A039_BOOKKEEP_SUB_CREDITS?
A_IS_ZERO: ; 0x005C7C, $CC7C
    ADDA  S+ ; A += PUSH'D
    DAA ; Adjust
    LDB   #$04 ; Bookkeep stat.
    JSR   BOOKKEEP_UPDATE_+A ; += A
    JSR   ADD_A_CREDITS_ROUTINE?
    PULS  A,B,X,PC ; RTS
RTN_DIVIDE_A_WITH_B,A_TIMES_B_REMAINDER: ; 0x005C89, $CC89
    PSHS  B ; Save B, used as SUB_VAL. A is sub target.
    TSTB ; Test
    BNE   SUB_VAL_NOT_ZERO ; Push'd not zero.
    CLRA ; Bail if sub val is 0. Clear A.
    PULS  B,PC ; RTS with original B, 0.
SUB_VAL_NOT_ZERO: ; 0x005C91, $CC91
    EXG   A-B ; B is now divide target.
    LDA   #$99 ; A =
A_INC,B_SUB_VAL: ; 0x005C95, $CC95
    ADDA  #$01 ; A += 1, 0 first run.
    DAA ; Adjust decimal.
    SUBB  S ; B -= SUB_VAL. Hence why 0 check. Need to sub SOMETHING.
    BCC   A_INC,B_SUB_VAL ; No carry needed, loop.
    ADDB  S+ ; B += SUB_VAL to get remainder.
    RTS ; RTS
REG.B_DEC_TO_HEX_CONVERT: ; 0x005C9F, $CC9F
    PSHS  A ; SUB_B_DEC_TO_HEX_CONVERT
    EXG   A-B ; B to A
    CLRB ; B = 0
LOOP_SUB: ; 0x005CA4, $CCA4
    TSTA ; Test A
    BNE   A_NOT_ZERO ; A != 0
    PULS  A,PC ; A == 0, rts, restoring A.
A_NOT_ZERO: ; 0x005CA9, $CCA9
    ADDA  #$99 ; Decimal subtract.
    DAA ; Adjust
    INCB ; B++
    BRA   LOOP_SUB
INIT_SRAM_$C41D_WITH_$CECF: ; 0x005CAF, $CCAF
    PSHS  Y,X,B,A
    LDX   #$CECF ; Ptr to data.
    LDY   #$C41D ; Ptr to SRAM
    LDB   #$30 ; Loop count.
    JSR   MOVE_@X_TO_SRAM@Y ; Move data.
    BSR   INIT_HIGHSCORES_DAILY ; Initing the daily scores.
    PULS  A,B,X,Y,PC ; RTS
INIT_HIGHSCORES_DAILY: ; 0x005CC1, $CCC1
    PSHS  Y,X,B,A ; Save
    LDY   #$CECF ; Ptr to high score table.
    LDX   #$B260 ; PTR to place data will be put.
    LDB   #$30 ; Length
LOOP_WRITE_TO_SRAM: ; 0x005CCC, $CCCC
    LDA   Y+
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Used to write to normal RAM in 4-bit pieces.
    DECB ; Loop count.
    BNE   LOOP_WRITE_TO_SRAM ; Loop
    PULS  A,B,X,Y,PC ; RTS
PTRS_USED_IN_CODE: ; 0x005CD6, $CCD6
    .db $CD ; FORMAT: [TEXT_PTR,UNK,SRAM_ADD]
    .db $46
    .db $00
    .db $01
    .db $CD
    .db $51
    .db $00
    .db $05
    .db $CD
    .db $5E
    .db $00
    .db $09
    .db $CD
    .db $6A
    .db $00
    .db $0D
    .db $CD
    .db $75
    .db $00
    .db $11
    .db $CD
    .db $7F
    .db $00
    .db $15
    .db $CD
    .db $8A
    .db $00
    .db $19
    .db $CD
    .db $96
    .db $00
    .db $81
    .db $CD
    .db $A7
    .db $00
    .db $85
    .db $CD
    .db $B7
    .db $00
    .db $87
    .db $CD
    .db $C6
    .db $00
    .db $89
    .db $CD
    .db $D5
    .db $00
    .db $8B
    .db $CD
    .db $E6
    .db $00
    .db $8D
    .db $CD
    .db $F6
    .db $00
    .db $8F
    .db $CE
    .db $07
    .db $00
    .db $91
    .db $CE
    .db $17
    .db $00
    .db $93
    .db $CE
    .db $25
    .db $00
    .db $95
    .db $CE
    .db $2F
    .db $00
    .db $97
    .db $CE
    .db $3D
    .db $00
    .db $99
    .db $CE
    .db $4B
    .db $00
    .db $9B
    .db $CE
    .db $59
    .db $00
    .db $9D
    .db $CE
    .db $67
    .db $00
    .db $9F
    .db $CE
    .db $75
    .db $00
    .db $A1
    .db $CE
    .db $83
    .db $00
    .db $A3
    .db $CE
    .db $91
    .db $00
    .db $A5
    .db $CE
    .db $9F
    .db $00
    .db $A7
    .db $CE
    .db $AD
    .db $00
    .db $A9
    .db $CE
    .db $BC
    .db $00
    .db $7D ; End of data
    .db $43 ; Coins Left
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $4C
    .db $45
    .db $46
    .db $54
    .db $2F
    .db $43 ; Coins center
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $43
    .db $45
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $43 ; Coins right
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $52
    .db $49
    .db $47
    .db $48
    .db $54
    .db $2F
    .db $54 ; Total paid
    .db $4F
    .db $54
    .db $41
    .db $4C
    .db $20
    .db $50
    .db $41
    .db $49
    .db $44
    .db $2F
    .db $53 ; Ships won
    .db $48
    .db $49
    .db $50
    .db $53
    .db $20
    .db $57
    .db $4F
    .db $4E
    .db $2F
    .db $54 ; Total time
    .db $4F
    .db $54
    .db $41
    .db $4C
    .db $20
    .db $54
    .db $49
    .db $4D
    .db $45
    .db $2F
    .db $54 ; Total ships
    .db $4F
    .db $54
    .db $41
    .db $4C
    .db $20
    .db $53
    .db $48
    .db $49
    .db $50
    .db $53
    .db $2F
    .db $42 ; Bonus ship level
    .db $4F
    .db $4E
    .db $55
    .db $53
    .db $20
    .db $53
    .db $48
    .db $49
    .db $50
    .db $20
    .db $4C
    .db $45
    .db $56
    .db $45
    .db $4C
    .db $2F
    .db $4E ; Number of ships
    .db $55
    .db $4D
    .db $42
    .db $45
    .db $52
    .db $20
    .db $4F
    .db $46
    .db $20
    .db $53
    .db $48
    .db $49
    .db $50
    .db $53
    .db $2F
    .db $43 ; Coinage select
    .db $4F
    .db $49
    .db $4E
    .db $41
    .db $47
    .db $45
    .db $20
    .db $53
    .db $45
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $2F
    .db $4C ; Left coin mult
    .db $45
    .db $46
    .db $54
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $20
    .db $4D
    .db $55
    .db $4C
    .db $54
    .db $2F
    .db $43 ; Center coin mult
    .db $45
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $20
    .db $4D
    .db $55
    .db $4C
    .db $54
    .db $2F
    .db $52 ; Right coin mult
    .db $49
    .db $47
    .db $48
    .db $54
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $20
    .db $4D
    .db $55
    .db $4C
    .db $54
    .db $2F
    .db $43 ; Coins for credit
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $46
    .db $4F
    .db $52
    .db $20
    .db $43
    .db $52
    .db $45
    .db $44
    .db $49
    .db $54
    .db $2F
    .db $43 ; Coins for bonus
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $46
    .db $4F
    .db $52
    .db $20
    .db $42
    .db $4F
    .db $4E
    .db $55
    .db $53
    .db $2F
    .db $4D ; Minimum coins
    .db $49
    .db $4E
    .db $49
    .db $4D
    .db $55
    .db $4D
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $2F
    .db $46 ; Free play
    .db $52
    .db $45
    .db $45
    .db $20
    .db $50
    .db $4C
    .db $41
    .db $59
    .db $2F
    .db $47 ; Game adjust 1
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $31
    .db $2F
    .db $47 ; Game adjust 2
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $32
    .db $2F
    .db $47 ; Game adjust 3
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $33
    .db $2F
    .db $47 ; Game adjust 4
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $34
    .db $2F
    .db $47 ; Game adjust 5
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $35
    .db $2F
    .db $47 ; Game adjust 6
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $36
    .db $2F
    .db $47 ; Game adjust 7
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $37
    .db $2F
    .db $47 ; Game adjust 8
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $38
    .db $2F
    .db $47 ; Game adjust 9
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $39
    .db $2F
    .db $47 ; Game adjust 10
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $31
    .db $30
    .db $2F
    .db $53 ; Special function
    .db $50
    .db $45
    .db $43
    .db $49
    .db $41
    .db $4C
    .db $20
    .db $46
    .db $55
    .db $4E
    .db $43
    .db $54
    .db $49
    .db $4F
    .db $4E
    .db $2F
    .db $FF
    .db $FF
CMOS_RAM_INIT_DATA: ; 0x005ECF, $CECF
    .db $02 ; High score table initial start. Score, BCD.
    .db $12
    .db $70
    .db $44 ; Initials, DRJ
    .db $52
    .db $4A
    .db $01 ; Score
    .db $83
    .db $15
    .db $53 ; SAM
    .db $41
    .db $4D
    .db $01 ; Score
    .db $59
    .db $20
    .db $4C ; LED
    .db $45
    .db $44
    .db $01 ; Score
    .db $42
    .db $85
    .db $50 ; PGD
    .db $47
    .db $44
    .db $01 ; Score
    .db $25
    .db $20
    .db $43 ; CRB
    .db $52
    .db $42
    .db $01 ; Score
    .db $10
    .db $35
    .db $4D ; MRS
    .db $52
    .db $53
    .db $00 ; Score
    .db $82
    .db $65
    .db $53 ; SSR
    .db $53
    .db $52
    .db $00 ; Score
    .db $60
    .db $10
    .db $54 ; TMH
    .db $4D
    .db $48
    .db $00
    .db $5A
    .db $01
    .db $00
    .db $03
    .db $03
    .db $01
    .db $04
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $05
    .db $15
    .db $01
    .db $05
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; END SRAM INIT DATA
    .db $04
    .db $01
    .db $02
    .db $04
    .db $00
    .db $06
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $04
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $16
    .db $06
    .db $02
    .db $00
    .db $00
    .db $01
    .db $04
    .db $01
    .db $02
    .db $00
    .db $00
    .db $01
    .db $00
    .db $04
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $02
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $02
    .db $02
    .db $00
    .db $00
    .db $43 ; Copyright 1980 - Williams Electronics
    .db $4F
    .db $50
    .db $59
    .db $52
    .db $49
    .db $47
    .db $48
    .db $54
    .db $20
    .db $31
    .db $39
    .db $38
    .db $30
    .db $20
    .db $2D
    .db $20
    .db $57
    .db $49
    .db $4C
    .db $4C
    .db $49
    .db $41
    .db $4D
    .db $53
    .db $20
    .db $45
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $52
    .db $4F
    .db $4E
    .db $49
    .db $43
    .db $53
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $4A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00

;Bank 7
	.org $C000

JMP_TO_DRAW_LAND_INITIALIZATION?: ; 0x006000, $C000
    JMP   DRAW_LAND_INITIALIZATION?
JMP_TO_LAND_IRQ: ; 0x006003, $C003
    JMP   IRQ_TASK_LAND_IRQ
JMP_TO_GENERATE_LAND_DATA_B300-B6FF: ; 0x006006, $C006
    JMP   GENERATE_LAND_DATA_B300-B6FF
JMP_TO_CLEAR_LAND_ONSCREEN?: ; 0x006009, $C009
    JMP   CLEAR_LAND_ONSCREEN
    .db $C4 ; Value here is related to land, dev leftover?
    .db $50
JMP_TO_SHIP_EXPLODE?: ; 0x00600E, $C00E
    JMP   SHIP_EXPLODE?
DIFFICULTY_DATA_START_LOC: ; 0x006011, $C011
    .db $C6
    .db $BA
DIFFICULTY_DATA_END_LOC: ; 0x006013, $C013
    .db $C7
    .db $72
DRAW_LAND_INITIALIZATION?: ; 0x006015, $C015
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load pos value.
    ANDB  #$E0 ; B=1110.0000
    STD   A017_WORLD_MOVEMENT_MASKED ; Store to, start.
    ADDD  #$2610 ; Make do whole screen. 0x2610 >> 5 = 304 dec. 10 is +1?
    STD   A015_WORLD_UPDATE_COUNT? ; Store to.
    CLR   A00F_SHIFTS_COUNTER_UNK ; None left, aka reseed.
    LDX   #$C34F ; World data ptr -1, because ++ on reseed.
    STX   A009_WORLD_HEIGHT_POS_LEFT? ; Store to
    LDA   #$E0 ; Load 1110.0000, initial height.
    STA   A011_WORLD_HEIGHT_UNK ; Store
    JSR   SHIFT_WORLD_DATA_RESEED_LEFT ; Seed data.
    LDX   #$0010 ; Initial value for loop below. 10 is +1?
LOOP_X304: ; 0x006031, $C031
    CMPX  A015_WORLD_UPDATE_COUNT? ; If X _ $A015
    BEQ   SEED_WORLDGEN_FROM_FIGURED? ; ==, goto.
    LDA   A00D_WORLD_DATA_COPY_L ; Get this data we shifted.
    BPL   WORLD_MOVE_DATA_POSITIVE ; Positive, inc, negative, dec.
DEC_A011_WORLD_HEIGHT: ; 0x006039, $C039
    DEC   A011_WORLD_HEIGHT_UNK ; Dec
    BRA   HEIGHT_MODIFIED ; Skip inc.
WORLD_MOVE_DATA_POSITIVE: ; 0x00603D, $C03D
    INC   A011_WORLD_HEIGHT_UNK ; Inc
HEIGHT_MODIFIED: ; 0x00603F, $C03F
    JSR   SHIFT_WORLD_DATA_RESEED_LEFT ; Shift
    LEAX  32,X ; X+=32, 1 world ground unit?
    BRA   LOOP_X304
SEED_WORLDGEN_FROM_FIGURED?: ; 0x006047, $C047
    LDD   A009_WORLD_HEIGHT_POS_LEFT? ; Move
    STD   A003_CURR_PLANET_GEN_DATA_PTR
    LDA   A00F_SHIFTS_COUNTER_UNK ; Move
    STA   R_A000_CURR_PLANET_GEN_SHIFT_DELTA
    LDA   A00D_WORLD_DATA_COPY_L ; Move
    STA   A001_CURR_PLANET_GEN_HEIGHT_CHANGES
    LDA   A011_WORLD_HEIGHT_UNK ; Move
    STA   R_A002_CURR_PLANET_GEN_HEIGHT
    LDX   #$B700 ; Planet GFX PTR 1
    STX   R_A005_PLANET_DATA_PTR_LOWER
    LDX   #$BA90 ; Planet GFX PTR 2
    STX   R_A007_PLANET_DATA_PTR_HIGHER
LOOP_UNTIL_A015<A017: ; 0x006061, $C061
    LDD   A015_WORLD_UPDATE_COUNT? ; Get val
    SUBD  #$0020 ; -=
L_006066: ; 0x006066, $C066
    STD   A015_WORLD_UPDATE_COUNT? ; Store to
    CMPD  A017_WORLD_MOVEMENT_MASKED ; Compare to.
    BMI   CURRENT_PLANET_GEN_STATE_TO_GEN_SEED ; If result is negative, goto.
L_00606D: ; 0x00606D, $C06D
    JSR   UPDATE_PLANET_SURFACE_BUFFERS_TO_RIGHT ; Update one scroll pixel?
    BRA   LOOP_UNTIL_A015<A017
CURRENT_PLANET_GEN_STATE_TO_GEN_SEED: ; 0x006072, $C072
    LDD   A003_CURR_PLANET_GEN_DATA_PTR ; Seeds all planet gen vals.
    STD   A00B_PLANET_GEN_DATA_PTR
    LDA   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; Move
    STA   A010_PLANET_GEN_SHIFTS_DELTA
    LDA   A001_CURR_PLANET_GEN_HEIGHT_CHANGES ; Move
    STA   A00B_PLANET_GEN_HEIGHT_CHANGES
    LDA   R_A002_CURR_PLANET_GEN_HEIGHT ; Move
    STA   A012_PLANET_GEN_HEIGHT
    LDY   #$BE20 ; Planet ptrs array.
    LDX   #$0000 ; Clear/NULL
LOOP_CLEAR_PLANET_POINTERS_LOOP: ; 0x006089, $C089
    STX   Y++ ; Clear
    CMPY  #$BF50 ; Until
    BNE   LOOP_CLEAR_PLANET_POINTERS_LOOP
    RTS ; Leave
IRQ_TASK_LAND_IRQ: ; 0x006092, $C092
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load
    ANDB  #$E0 ; AND...
    SUBD  A015_WORLD_UPDATE_COUNT? ; Sub with...
    ASLB ; D << 3, *8
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    STA   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; Store A to.
    BEQ   CLEAR_PLANET_AND_DRAW_NEW ; No change, goto.
    BMI   LOOP_MOVE_PLANET_MINUS ; Move minus.
LOOP_MOVE_PLANET_PLUS: ; 0x0060A4, $C0A4
    LDD   A015_WORLD_UPDATE_COUNT? ; Load
    ADDD  #$0020 ; D+=32
    STD   A015_WORLD_UPDATE_COUNT? ; Store back
    JSR   WORLD_MOVE_DATA_IDK_LEFT ; Does IDK
    DEC   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; Dec A000 
    BNE   LOOP_MOVE_PLANET_PLUS
    BRA   CLEAR_PLANET_AND_DRAW_NEW ; Draw
LOOP_MOVE_PLANET_MINUS: ; 0x0060B4, $C0B4
    LDD   A015_WORLD_UPDATE_COUNT? ; Load
    SUBD  #$0020 ; Sub
    STD   A015_WORLD_UPDATE_COUNT? ; Store back
    JSR   UPDATE_PLANET_SURFACE_BUFFERS_TO_RIGHT
    INC   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; ++
    BNE   LOOP_MOVE_PLANET_MINUS
CLEAR_PLANET_AND_DRAW_NEW: ; 0x0060C2, $C0C2
    LDD   R_A020_SCREEN_POS_HORIZ_1_CURR? ; Load
    ANDB  #$E0 ; B bits, 1110.0000
    STD   A015_WORLD_UPDATE_COUNT? ; Store to
    LDX   #$0000 ; Pixel clear.
    LDY   #$BE20 ; Ptr to on-screen pixels.
    STS   R_A013_STACK_SAVE_IRQ_RTN_B7 ; Save S stack.
    LDS   R_A005_PLANET_DATA_PTR_LOWER ; S from here.
    BITB  #$20 ; Test world bit 0010.0000
    BNE   USING_LOWER_STACK_ADDR ; If set, goto
    LDS   R_A007_PLANET_DATA_PTR_HIGHER ; S from here otherwise.
USING_LOWER_STACK_ADDR: ; 0x0060DC, $C0DC
    LDA   #$98 ; X pos in D
LOOP_WRITE_NEW_PLANET_OVER_OLD: ; 0x0060DE, $C0DE
    STX   [Y] ; Clear screen planet pixel.
    PULS  B,U ; Pull height, gfx.
    STD   Y ; Addr on screen to Y
    STU   [Y++] ; Planet data to ptr stored.
    DECA
    STX   [Y] ; 2x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 3x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 4x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 5x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 6x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 7x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 8x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    BNE   LOOP_WRITE_NEW_PLANET_OVER_OLD ; If A != 0, goto.
    LDS   R_A013_STACK_SAVE_IRQ_RTN_B7 ; Fix stack
    RTS ; RTS
UPDATE_PLANET_SURFACE_BUFFERS_TO_RIGHT: ; 0x00612C, $C12C
    JSR   PLANET_GEN_SHIFT_TO_RIGHT ; Shift planet gen byte to the right?
    BMI   INC_PLANET_HEIGHT ; If A is negative, taken.
    DEC   A012_PLANET_GEN_HEIGHT ; --
    BRA   HEIGHT_CHANGED ; Always goto.
INC_PLANET_HEIGHT: ; 0x006135, $C135
    INC   A012_PLANET_GEN_HEIGHT ; ++
HEIGHT_CHANGED: ; 0x006137, $C137
    LDA   #$20 ; Load with val
    BITA  A015_WORLD_UPDATE_COUNT?+1 ; Test bit here.
    BNE   USE_PLANET_DATA_PTR_HIGHER_TO_RIGHT ; If set, use higher.
    LDX   R_A007_PLANET_DATA_PTR_HIGHER ; Get X from
    JSR   PLANET_IDK_SHIFT_RIGHT ; Shift planet data. Implied result test.
    BMI   VALUE_IS_NEGATIVE ; If A store was negative.
    DEC   A011_WORLD_HEIGHT_UNK ; --
    LDA   A011_WORLD_HEIGHT_UNK ; Get val.
    STA   X ; Store to PTR[0]
    STA   456,X ; Store to OPRT[0]
    LDD   #$7007 ; Pixels to display.
    STD   1,X ; Store to PTR[1]
    STD   457,X ; Store to OPTR[1]
    LEAX  3,X ; X+=3
    CMPX  #$BC58 ; Compare to
    BNE   SAVE_STACK,RTS ; !=, skip reset.
    LDX   #$BA90 ; Reset
SAVE_STACK,RTS: ; 0x006161, $C161
    STX   R_A007_PLANET_DATA_PTR_HIGHER ; Store to.
    RTS
VALUE_IS_NEGATIVE: ; 0x006164, $C164
    LDA   A011_WORLD_HEIGHT_UNK ; Get height
    STA   X ; To PTR[0]
    STA   456,X ; To OPTR[0]
    INCA ; Height++
    STA   A011_WORLD_HEIGHT_UNK ; Store to
    LDD   #$0770 ; Pixels storing.
    STD   1,X ; To PTR[1]
    STD   457,X ; To OPTR[1]
    LEAX  3,X ; X+=3
    CMPX  #$BC58 ; CMP to end.
    BNE   COMMIT_X_$A007,RTS
    LDX   #$BA90 ; Reset
COMMIT_X_$A007,RTS: ; 0x006182, $C182
    STX   R_A007_PLANET_DATA_PTR_HIGHER ; Store.
    RTS
USE_PLANET_DATA_PTR_HIGHER_TO_RIGHT: ; 0x006185, $C185
    LDX   R_A005_PLANET_DATA_PTR_LOWER ; Load X from
    JSR   PLANET_IDK_SHIFT_RIGHT ; Shift to right, implied result test.
    BMI   PLANET_MOVE_DATA_NEGATIVE ; If rtn made negative, goto.
    DEC   A011_WORLD_HEIGHT_UNK ; Dec world height idk
    LDA   A011_WORLD_HEIGHT_UNK ; Load
    STA   X ; Store height to PTR[0]
    STA   456,X ; Store to OPTR[0]
    LDD   #$7007 ; Pixels to draw.
    STD   1,X ; To PTR[1]
    STD   457,X ; To OPTR[1]
    LEAX  3,X ; X+=3
    CMPX  #$B8C8 ; End
    BNE   SAVE_STACK,RTS
    LDX   #$B700 ; Reset stack ptr.
SAVE_STACK,RTS: ; 0x0061A9, $C1A9
    STX   R_A005_PLANET_DATA_PTR_LOWER ; Store back.
    RTS
PLANET_MOVE_DATA_NEGATIVE: ; 0x0061AC, $C1AC
    LDA   A011_WORLD_HEIGHT_UNK ; Get height
    STA   X ; Store to ptr
    STA   456,X ; Store to other ptr.
    INCA ; Height ++
    STA   A011_WORLD_HEIGHT_UNK ; Store height.
    LDD   #$0770 ; Pixels to draw.
    STD   1,X ; Store to PTR[1]
    STD   457,X ; Store to OPTR[1]
    LEAX  3,X ; X+=3
    CMPX  #$B8C8 ; End?
    BNE   SAVE_STACK,RTS
    LDX   #$B700 ; Reset
SAVE_STACK,RTS: ; 0x0061CA, $C1CA
    STX   R_A005_PLANET_DATA_PTR_LOWER ; Store back.
    RTS
WORLD_MOVE_DATA_IDK_LEFT: ; 0x0061CD, $C1CD
    LDA   A00D_WORLD_DATA_COPY_L ; Load data.
    BPL   INC_VAL
    DEC   A011_WORLD_HEIGHT_UNK
    BRA   SKIP_INC
INC_VAL: ; 0x0061D5, $C1D5
    INC   A011_WORLD_HEIGHT_UNK
SKIP_INC: ; 0x0061D7, $C1D7
    JSR   SHIFT_WORLD_DATA_RESEED_LEFT ; Reseed if needed.
    LDA   #$20
    BITA  A015_WORLD_UPDATE_COUNT?+1 ; Test 0010.0000
    BEQ   MANIP_LOWER_PLANET_POINTER ; Bit not set, goto.
    LDX   R_A007_PLANET_DATA_PTR_HIGHER ; Offset stack 2
    LEAX  -3,X
    CMPX  #$BA8D ; If X _ val
    BNE   DONT_RESET
    LDX   #$BC55 ; Reset
DONT_RESET: ; 0x0061EC, $C1EC
    STX   R_A007_PLANET_DATA_PTR_HIGHER ; Store stack ptr.
    LDA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Get height
    BPL   PLANET_GOING_UP ; If positive, goto.
    DEC   A012_PLANET_GEN_HEIGHT ; Goes down.
    LDA   A012_PLANET_GEN_HEIGHT ; Load height
    STA   X ; Store to
    STA   456,X ; Mirrored
    LDD   #$0770 ; Land
    STD   1,X ; To 2nd and 3rd bytes reserved.
    STD   457,X
    JSR   SHIFT_HEIGHT_CHANGE_DATA_LEFT ; Do IDK
    RTS ; RTS
PLANET_GOING_UP: ; 0x006209, $C209
    LDA   A012_PLANET_GEN_HEIGHT ; Height
    STA   X ; To H
    STA   456,X ; And here...
    INCA ; Height ++
    STA   A012_PLANET_GEN_HEIGHT ; Store to, idk why.
    LDD   #$7007 ; Planet pixels.
    STD   1,X ; To 2nd and 3rd bytes reserved.
    STD   457,X
    JSR   SHIFT_HEIGHT_CHANGE_DATA_LEFT ; Do.
    RTS
MANIP_LOWER_PLANET_POINTER: ; 0x006221, $C221
    LDX   R_A005_PLANET_DATA_PTR_LOWER ; Load data ptr
    LEAX  -3,X ; -=3
    CMPX  #$B6FD ; Underflow?
    BNE   WRITE_VAL
L_00622A: ; 0x00622A, $C22A
    LDX   #$B8C5 ; Reset ptr.
WRITE_VAL: ; 0x00622D, $C22D
    STX   R_A005_PLANET_DATA_PTR_LOWER ; Store back.
    LDA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Get height
    BPL   HEIGHT_POSITIVE ; If positive, goto.
    DEC   A012_PLANET_GEN_HEIGHT ; Dec height
    LDA   A012_PLANET_GEN_HEIGHT ; Get height.
    STA   X ; Height to PTR[0]
    STA   456,X ; Height to OPTR[0]
    LDD   #$0770 ; Pixels
    STD   1,X ; To PTR[1]
    STD   457,X ; To OPTR[1]
    JSR   SHIFT_HEIGHT_CHANGE_DATA_LEFT ; Change height.
    RTS
HEIGHT_POSITIVE: ; 0x00624A, $C24A
    LDA   A012_PLANET_GEN_HEIGHT ; Get height.
    STA   X ; To PTR[0]
    STA   456,X ; To O[PTR]
    INCA ; Height++
    STA   A012_PLANET_GEN_HEIGHT ; Store
    LDD   #$7007 ; Pixels
    STD   1,X ; To PTR[1]
    STD   457,X ; To OPTR[1]
    JSR   SHIFT_HEIGHT_CHANGE_DATA_LEFT ; Height stuff.
    RTS
GENERATE_LAND_DATA_B300-B6FF: ; 0x006262, $C262
    LDX   #$C350 ; Data ptr
    STX   A00B_PLANET_GEN_DATA_PTR ; Store to
    LDA   X ; Load from, base height for planet.
GENERATE_LAND_HEIGHT_BUFFER_MANUALLY: ; 0x006269, $C269
    STA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Store height starting at.
    LDA   #$07 ; Load
    STA   A010_PLANET_GEN_SHIFTS_DELTA ; Store
    LDA   #$E0 ; Load
    STA   A012_PLANET_GEN_HEIGHT ; Store
    LDX   #$B300 ; Ptr to buffer start.
LOOP_FILL_B300-B6FF_PLANET_HEIGHT_BUFFER: ; 0x006276, $C276
    LDA   A012_PLANET_GEN_HEIGHT ; Val from
    STA   X+ ; Commit planet data.
    LDA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Load val
    BPL   INC_PLANET_HEIGHT ; If positive, inc.
    DEC   A012_PLANET_GEN_HEIGHT ; Dec height if 1
    BRA   PLANET_HEIGHT_DONE ; Forward.
INC_PLANET_HEIGHT: ; 0x006282, $C282
    INC   A012_PLANET_GEN_HEIGHT
PLANET_HEIGHT_DONE: ; 0x006284, $C284
    JSR   SHIFT_HEIGHT_CHANGE_DATA_LEFT
    LDA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Load to test high bit.
    BPL   INC_PLANET_HEIGHT_2
    DEC   A012_PLANET_GEN_HEIGHT
    BRA   ALREADY_CHANGED_HEIGHT_2
INC_PLANET_HEIGHT_2: ; 0x00628F, $C28F
    INC   A012_PLANET_GEN_HEIGHT
ALREADY_CHANGED_HEIGHT_2: ; 0x006291, $C291
    JSR   SHIFT_HEIGHT_CHANGE_DATA_LEFT
    CMPX  #$B700 ; End X
BNE_LOOP_FILL: ; 0x006297, $C297
    BNE   LOOP_FILL_B300-B6FF_PLANET_HEIGHT_BUFFER
    RTS
CLEAR_LAND_ONSCREEN: ; 0x00629A, $C29A
    LDX   #$0000
    LDY   #$BE20 ; Planet screen pointers.
LOOP_CLEAR: ; 0x0062A1, $C2A1
    STX   [Y++]
    CMPY  #$BF50 ; 304, width of screen.
    BNE   LOOP_CLEAR ; Not done, loop.
    RTS
SHIFT_WORLD_DATA_RESEED_LEFT: ; 0x0062AA, $C2AA
    LDA   A00F_SHIFTS_COUNTER_UNK ; Load
    BEQ   RESEED_WORLD_DATA ; If 0, goto.
    DEC   A00F_SHIFTS_COUNTER_UNK ; --
    LDA   A00D_WORLD_DATA_COPY_L ; Load D
    ASLA ; Shift
    ADCA  #$00 ; Put bit back to other end.
    STA   A00D_WORLD_DATA_COPY_L ; Store to.
    RTS
RESEED_WORLD_DATA: ; 0x0062B8, $C2B8
    LDU   A009_WORLD_HEIGHT_POS_LEFT? ; Load world data ptr.
    LEAU  1,U ; ++
    CMPU  #$C450 ; End world data.
    BNE   DONT_RESET ; Skip reset.
    LDU   #$C350 ; Range
DONT_RESET: ; 0x0062C5, $C2C5
    STU   A009_WORLD_HEIGHT_POS_LEFT? ; Store ptr to data back.
    LDA   #$07
    STA   A00F_SHIFTS_COUNTER_UNK ; Reset shifts.
    LDA   U ; Load world data.
    STA   A00D_WORLD_DATA_COPY_L ; Store
    RTS ; RTS
SHIFT_HEIGHT_CHANGE_DATA_LEFT: ; 0x0062D0, $C2D0
    LDA   A010_PLANET_GEN_SHIFTS_DELTA ; Load val from
    BEQ   RESEED_HEIGHT_CHANGE_DATA ; If 0, do this.
    DEC   A010_PLANET_GEN_SHIFTS_DELTA ; Dec available.
    LDA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Load
    ASLA ; Shift
    ADCA  #$00 ; If shifted off one, put back...
    STA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Store back.
    RTS
RESEED_HEIGHT_CHANGE_DATA: ; 0x0062DE, $C2DE
    LDU   A00B_PLANET_GEN_DATA_PTR ; Load ptr
    LEAU  1,U ; Ptr++
    CMPU  #$C450 ; See if at end.
    BNE   DONT_RESET_LAND_DATA_PTR ; If not, goto.
    LDU   #$C350 ; Reset
DONT_RESET_LAND_DATA_PTR: ; 0x0062EB, $C2EB
    STU   A00B_PLANET_GEN_DATA_PTR ; Store back.
    LDA   #$07 ; Load
    STA   A010_PLANET_GEN_SHIFTS_DELTA ; Store shifts of validity.
    LDA   U ; Load from ptr
    STA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Reseed
    RTS
PLANET_IDK_SHIFT_RIGHT: ; 0x0062F6, $C2F6
    LDA   A00F_SHIFTS_COUNTER_UNK ; Load val
    CMPA  #$07 ; If _ 7
    BEQ   RESEED_DATA ; ==, goto
    INC   A00F_SHIFTS_COUNTER_UNK ; ++
    LDA   A00D_WORLD_DATA_COPY_L ; Load val
    LSRA ; Shift off bit.
    BCC   DONT_SET_BIT_1 ; If shifted off 1, don't add 80.
    ADDA  #$80 ; Set bit.
DONT_SET_BIT_1: ; 0x006305, $C305
    STA   A00D_WORLD_DATA_COPY_L ; Store to.
    RTS
RESEED_DATA: ; 0x006308, $C308
    LDU   A009_WORLD_HEIGHT_POS_LEFT? ; Load U from
    CMPU  #$C350 ; If U _ val
    BNE   DONT_RANGE_PTR ; !=, goto.
    LDU   #$C450 ; Reset
DONT_RANGE_PTR: ; 0x006313, $C313
    LEAU  -1,U ; U--
    STU   A009_WORLD_HEIGHT_POS_LEFT? ; Store to.
    CLR   A00F_SHIFTS_COUNTER_UNK ; Clear
    LDA   U ; Load from U
    LSRA ; Shift
    BCC   DONT_SET_BIT_2 ; If shifted off 0, skip add.
    ADDA  #$80 ; Set
DONT_SET_BIT_2: ; 0x006320, $C320
    STA   A00D_WORLD_DATA_COPY_L ; Store to.
    RTS ; RTS
PLANET_GEN_SHIFT_TO_RIGHT: ; 0x006323, $C323
    LDA   A010_PLANET_GEN_SHIFTS_DELTA ; Get val
    CMPA  #$07 ; If A _ 7
    BEQ   RESEED_PLANET_GEN ; ==, goto
    INC   A010_PLANET_GEN_SHIFTS_DELTA ; Inc count
    LDA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Load val
    LSRA ; Shift off bit
    BCC   DONT_PUT_BACK ; If shifted 0, goto.
    ADDA  #$80 ; Put bit back.
DONT_PUT_BACK: ; 0x006332, $C332
    STA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Store back
    RTS ; RTS
RESEED_PLANET_GEN: ; 0x006335, $C335
    LDU   A00B_PLANET_GEN_DATA_PTR ; Get U from
    CMPU  #$C350 ; If U _ C350
    BNE   SKIP_LOADING_U ; !=, goto
    LDU   #$C450 ; Load U
SKIP_LOADING_U: ; 0x006340, $C340
    LEAU  -1,U ; U-=1
    STU   A00B_PLANET_GEN_DATA_PTR ; Store new U
    CLR   A010_PLANET_GEN_SHIFTS_DELTA ; Clear
    LDA   U ; Get data at U
    LSRA ; get bit off.
    BCC   DONT_SET_BIT ; If shifted 0, don't add 80
    ADDA  #$80 ; Put back shifted.
DONT_SET_BIT: ; 0x00634D, $C34D
    STA   A00B_PLANET_GEN_HEIGHT_CHANGES ; Store to.
    RTS ; RTS
PLANET_HEIGHT_DATA: ; 0x006350, $C350
    .db $2A
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AB
    .db $A1
    .db $D5
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $AA
    .db $BF
    .db $FF
    .db $FF
    .db $FF
    .db $C0
    .db $00
    .db $00
    .db $00
    .db $55
    .db $55
    .db $57
    .db $FF
    .db $C0
    .db $01
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $5F
    .db $E0
    .db $15
    .db $55
    .db $55
    .db $57
    .db $FF
    .db $F0
    .db $00
    .db $15
    .db $55
    .db $5F
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $00
    .db $00
    .db $00
    .db $00
    .db $05
    .db $55
    .db $7F
    .db $FF
    .db $E0
    .db $00
    .db $05
    .db $55
    .db $55
    .db $55
    .db $55
    .db $FC
    .db $05
    .db $55
    .db $55
    .db $50
    .db $01
    .db $FF
    .db $FF
    .db $FF
    .db $C0
    .db $00
    .db $0A
    .db $AA
    .db $AA
    .db $AA
    .db $FF
    .db $00
    .db $00
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $F0
    .db $00
    .db $00
    .db $1F
    .db $E0
    .db $00
    .db $55
    .db $55
    .db $55
    .db $40
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $B5
    .db $57
    .db $AA
    .db $AA
    .db $AA
    .db $F5
    .db $7F
    .db $D5
    .db $55
    .db $55
    .db $57
    .db $FF
    .db $80
    .db $07
    .db $E0
    .db $7F
    .db $F1
    .db $55
    .db $7F
    .db $FF
    .db $FF
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0F
    .db $EF
    .db $76
    .db $91
    .db $11
    .db $11
    .db $5E
    .db $DB
    .db $E9
    .db $84
    .db $77
    .db $EC
    .db $C4
    .db $87
    .db $47
    .db $98
    .db $08
    .db $98
    .db $3F
    .db $C3
    .db $CB
    .db $DB
    .db $9F
    .db $C7
    .db $5F
    .db $2F
    .db $C7
    .db $7D
    .db $EF
    .db $BF
    .db $FA
    .db $4C
    .db $57
    .db $2B
    .db $61
    .db $EF
    .db $EF
    .db $FB
    .db $F7
    .db $E8
    .db $00
    .db $20
    .db $40
    .db $00
    .db $14
    .db $04
    .db $04
    .db $3C
    .db $06
    .db $00
    .db $1D
    .db $07
    .db $3C
    .db $E1
    .db $A5
    .db $55
    .db $55
    .db $45
    .db $2A
    .db $AA
    .db $AA
    .db $AA
    .db $A8
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $56
    .db $AA
    .db $AA
    .db $FE
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $EA
    .db $AA
    .db $AA
    .db $A8
    .db $02
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $BF
    .db $BE
    .db $3E
    .db $63
    .db $FF
    .db $E0
    .db $D8
    .db $1C
    .db $18
    .db $2A
    .db $AB
    .db $1E
    .db $77
    .db $7A
    .db $AF
    .db $A8
    .db $40
    .db $70
    .db $7D
    .db $40
    .db $0B
    .db $FB
    .db $FA
    .db $FF
    .db $C1
    .db $53
    .db $54
    .db $75
    .db $70
    .db $03
    .db $00
    .db $00 ; End of data.
SCANNER_WORLD_DATA_COPY???: ; 0x006450, $C450
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
SHIP_EXPLODE?: ; 0x0065D0, $C5D0
    PULS  A,B ; RTS location to...
    STD   9,U ; UOBJ[9]
    STX   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; X is XXYY center of ship.
    LDD   #$0808 ; Not sure of val...
    STD   A003_CURR_PLANET_GEN_DATA_PTR+1
    LDD   #$1732 ; Not sure of val...
    STD   R_A006_SCORE_POS_CHAR
    LDY   #$B300 ; Ptr
LOOP_EXPLOSION_DATA_MAKE: ; 0x0065E4, $C5E4
    LDA   R_A000_CURR_PLANET_GEN_SHIFT_DELTA ; Load X pos
    CLRB ; Clear B, no Y
    STD   2,Y ; To EXPLOSION[2]
    LDA   A001_CURR_PLANET_GEN_HEIGHT_CHANGES ; Height of ship
    STD   4,Y ; D to EXPLOSION[4]
    LDA   R_A005_PLANET_DATA_PTR_LOWER ; A from
    LSRA ; >> 1
    EORA  R_A005_PLANET_DATA_PTR_LOWER ; A ^ addr
    LSRA ; >> 2
    LSRA
    ROR   A003_CURR_PLANET_GEN_DATA_PTR+1 ; Rotate
    ROR   R_A005_PLANET_DATA_PTR_LOWER ; Rotate
    LDA   A003_CURR_PLANET_GEN_DATA_PTR+1 ; Load val
    ANDA  #$01 ; Get 0000.0001
    SUBA  #$01 ; 0 or FF val
    LDB   R_A005_PLANET_DATA_PTR_LOWER ; B from
    STD   6,Y ; D to EXPLOSION[6]
    BPL   DONT_INVERT ; If B positive, don't invert.
    COMA ; Invert D
    COMB
DONT_INVERT: ; 0x006606, $C606
    PSHS  B,A ; Save to stack, always positive. D.
    LDA   R_A007_PLANET_DATA_PTR_HIGHER ; Load val
    LSRA ; >> 1
    EORA  R_A007_PLANET_DATA_PTR_HIGHER ; A ^ addr
    LSRA
    LSRA ; >> 2
    ROR   R_A006_SCORE_POS_CHAR ; Rotate
    ROR   R_A007_PLANET_DATA_PTR_HIGHER ; Rotate
    LDA   R_A006_SCORE_POS_CHAR ; Load
    ANDA  #$03 ; Get 0000.0011
    SUBA  #$02 ; FE,FF,0,1 val
    LDB   R_A007_PLANET_DATA_PTR_HIGHER ; Load val
    STD   8,Y ; D to EXPLOSION[8]
    BPL   DONT_INVERT_2 ; If B positive, don't invert.
    COMA ; Invert D
    COMB
DONT_INVERT_2: ; 0x006621, $C621
    LSRA ; D >> 1, /2
    RORB
    ADDD  S++ ; D += prev pushed, fix stack.
    CMPD  #$016A ; If D _ val
    BCC   LOOP_EXPLOSION_DATA_MAKE ; >=, loop again to get range data.
    LDX   #$0000 ; X =
    STX   Y ; Clear EXPLOSION[0], SCR_LOC?
    LEAY  10,Y ; Y += 10
    CMPY  #$B800 ; If Y _ val, 80
    BNE   LOOP_EXPLOSION_DATA_MAKE ; !=, loop.
    LDX   #$C6AB ; RE_PURPOSE, PTR to explosion color change table?
    STX   R_A002_CURR_PLANET_GEN_HEIGHT ; To
    LDA   #$38 ; Timer to delay changing explosion color.
    STA   A001_CURR_PLANET_GEN_HEIGHT_CHANGES
SETUP_CALLBACK_EXPLOSION_PLAY: ; 0x006641, $C641
    LDA   #$01 ; Setup callback.
    LDX   #$C649
    JMP   JMP_SCHEDULE_BANKED_CALLBACK_IN_CURRENT_SUB
CALLBACK_SHIP_EXPLODE_STEP: ; 0x006649, $C649
    LDX   #$0000 ; Clear
    LDY   #$B300 ; Ptr to height data.
    LDA   [R_A002_CURR_PLANET_GEN_HEIGHT] ; Load color from PTR
    STA   COLOR_PALETTE_RAM_COPY+11 ; Store to palette, explosion color.
    BEQ   EXIT_EXPLOSION_BACK_TO_GAMEPLAY ; If 0, goto.
MOVE_ALL_EXPLOSIONS: ; 0x006658, $C658
    LDU   Y ; U from Y.next
    STX   U ; Clear U
    STX   256,U ; Clear U,X+1
    LDD   8,Y ; D from EXPLOSION[8]
    ADDD  4,Y ; += EXPLOSION[4]
    CMPA  #$2A ; If A _ val
    BCS   NEXT_EXPLOSION_PARTICLE ; <, goto. Above scanner. This catches wrapping to top.
    STD   4,Y ; Store back
    STA   1,Y ; A to EXPLOSION[1]
    LDD   6,Y ; D from EXPLOSION[6]
    ADDD  2,Y ; D += EXPLOSION[2]
    CMPA  #$98 ; If A _ #$98
    BHI   NEXT_EXPLOSION_PARTICLE ; >, goto. This catches offscreeen both sides.
    STD   2,Y ; Store to EXPLOSION[2]
    STA   Y ; To EXPLOSION[0]
    TSTB ; Test B
    BMI   PIXEL_OFFSET ; If top bit set, offset.
    LDD   #$BBBB ; Blow up pixels.
    STD   [Y] ; D to Y[0] ptr
    BRA   NEXT_EXPLOSION_PARTICLE
PIXEL_OFFSET: ; 0x006682, $C682
    LDU   Y ; U from Y
    LDD   #$0B0B ; D = pixels?
    STD   U ; to U
    LDD   #$B0B0 ; Pixels?
    STD   256,U ; To U,X+1
NEXT_EXPLOSION_PARTICLE: ; 0x006690, $C690
    LEAY  10,Y ; Y += 10
    CMPY  #$B800 ; If Y _ val
    BNE   MOVE_ALL_EXPLOSIONS ; !=, goto.
    DEC   A001_CURR_PLANET_GEN_HEIGHT_CHANGES ; -- val
    BNE   SETUP_CALLBACK_EXPLOSION_PLAY ; Not done, keep color of explosion as is.
    LDU   R_A002_CURR_PLANET_GEN_HEIGHT ; U from
    LEAU  1,U ; ++
    STU   R_A002_CURR_PLANET_GEN_HEIGHT ; Store to
    LDA   #$04 ; New delay value, 4.
    STA   A001_CURR_PLANET_GEN_HEIGHT_CHANGES
    BRA   SETUP_CALLBACK_EXPLOSION_PLAY ; Callback.
EXIT_EXPLOSION_BACK_TO_GAMEPLAY: ; 0x0066A8, $C6A8
    JMP   [9,U] ; RTS location stored here, hence JMP.
PLAYER_EXPLOSION_COLOR_ROTATION: ; 0x0066AB, $C6AB
    .db $FF
    .db $7F
    .db $3F
    .db $37
    .db $2F
    .db $27
    .db $1F
    .db $17
    .db $07
    .db $06
    .db $05
    .db $04
    .db $03
    .db $02
    .db $00
DIFFICULT_DATA_START: ; 0x0066BA, $C6BA
    .db $14
    .db $00
    .db $00
    .db $00
    .db $0F
    .db $14
    .db $14
    .db $14
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $04
    .db $05
    .db $06
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $03
    .db $04
    .db $0A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $1E
    .db $00
    .db $00
    .db $00
    .db $1E
    .db $19
    .db $14
    .db $10
    .db $05
    .db $00
    .db $00
    .db $00
    .db $05
    .db $05
    .db $05
    .db $05
    .db $60
    .db $00
    .db $03
    .db $02
    .db $16
    .db $1E
    .db $26
    .db $2E
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $FF
    .db $00
    .db $10
    .db $00
    .db $70
    .db $B0
    .db $00
    .db $00
    .db $80
    .db $10
    .db $FC
    .db $FE
    .db $4A
    .db $3A
    .db $2A
    .db $2A
    .db $30
    .db $00
    .db $00
    .db $00
    .db $20
    .db $28
    .db $2C
    .db $30
    .db $02
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $02
    .db $02
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $FF
    .db $00
    .db $08
    .db $06
    .db $62
    .db $E0
    .db $02
    .db $12
    .db $60
    .db $00
    .db $08
    .db $04
    .db $0C
    .db $1C
    .db $24
    .db $28
    .db $FF
    .db $08
    .db $FE
    .db $FE
    .db $2A
    .db $22
    .db $1E
    .db $1C
    .db $60
    .db $00
    .db $08
    .db $02
    .db $16
    .db $1E
    .db $20
    .db $22
    .db $28
    .db $0A
    .db $FE
    .db $FF
    .db $19
    .db $19
    .db $19
    .db $19
    .db $3F
    .db $00
    .db $00
    .db $00
    .db $1F
    .db $1F
    .db $1F
    .db $3F
    .db $C0
    .db $18
    .db $F4
    .db $FC
    .db $D4
    .db $C4
    .db $A4
    .db $94
    .db $0A
    .db $03
    .db $FF
    .db $FF
    .db $0F
    .db $0D
    .db $0C
    .db $0A
    .db $C8
    .db $28
    .db $F4
    .db $F8
    .db $F0
    .db $DC
    .db $C8
    .db $C8 ; End of data
DIFFICULTY_DATA_END: ; 0x006772, $C772
    .db $00 ; From here on seems like leftover junk and seems completely unused.
    .db $00
L_006774: ; 0x006774, $C774
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $8E
    .db $C0
    .db $0C
    JMP   L_006036
    LDB   #$28
    BRA   L_006774
    LDB   #$80
    BRA   L_006774
    LDY   #$C9FE
    JSR   BNE_LOOP_FILL
    JMP   $CB3B
L_006791: ; 0x006791, $C791
    LDB   #$A5 ; Color
    LDX   #$C001 ; Palette
    JMP   L_006036
    JSR   GENERATE_LAND_HEIGHT_BUFFER_MANUALLY
    JSR   L_00622A
    BSR   L_006791
    LDU   #$C0D7 ; WILLIAMS DEFENDER
    LDX   #$2820
    JSR   GENERATE_LAND_HEIGHT_BUFFER_MANUALLY
    JSR   L_00603C
    LDY   #$C061 ; SENTENCE AUTO FOR GAME OVER
    JSR   L_00606D
    LDY   #$05DC
    JSR   L_006244
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_00601F
    CLR   R_A03C_OPTION_ON
    LDA   #$01
    STA   R_AO3B_UPDATE_SCREEN?
    LEAS  -32,S
    JSR   JMP_CLEAR_ALL_SCREEN
    LDU   #$C0D7 ; WILLIAMS DEFENDER
    LDX   #$2820
    JSR   GENERATE_LAND_HEIGHT_BUFFER_MANUALLY
    JSR   L_00603C
    CLR   R_A03A_MENU_UNK
    LDY   #$C065 ; PRESS HIGH SCORE RESET TO MAKE CHANGE
    JSR   L_006066
    JSR   GENERATE_LAND_HEIGHT_BUFFER_MANUALLY
    LDA   #$20
    TFR   A>B
    DECB
    LEAX  S
L_0067EA: ; 0x0067EA, $C7EA
    STA   X+
    DECB
    BNE   L_0067EA
    LDA   #$17
    STA   X+
    LEAX  S
    JSR   L_006257
    LDX   #$CC00
    JSR   DEC_A011_WORLD_HEIGHT
    .db $C5
    .db $02
