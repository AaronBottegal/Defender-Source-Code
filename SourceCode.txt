; Williams Defender arcade game disassembly, created by Aaron Bottegal.
; This disassembly is a work in progress.


;PCB Registers

PALETTE_ENTRY_0x0                        = 0xC000
PALETTE_ENTRY_0x1                        = 0xC001
PALETTE_ENTRY_0x2                        = 0xC002
PALETTE_ENTRY_0x3                        = 0xC003
PALETTE_ENTRY_0x4                        = 0xC004
PALETTE_ENTRY_0x5                        = 0xC005
PALETTE_ENTRY_0x6                        = 0xC006
PALETTE_ENTRY_0x7                        = 0xC007
PALETTE_ENTRY_0x8                        = 0xC008
PALETTE_ENTRY_0x9                        = 0xC009
PALETTE_ENTRY_0xA                        = 0xC00A
PALETTE_ENTRY_0xB                        = 0xC00B
PALETTE_ENTRY_0xC                        = 0xC00C
PALETTE_ENTRY_0xD                        = 0xC00D
PALETTE_ENTRY_0xE                        = 0xC00E
PALETTE_ENTRY_0xF                        = 0xC00F
SCREEN_CONTROL                           = 0xC010
WATCHDOG                                 = 0xC3FC ;to 0xC3FF
VIDEO_COUNTER_BITS                       = 0xC800 ;to 0xCBFF
PIA_ROM_DATA_A                           = 0xCC00
PIA_ROM_CTRL_A                           = 0xCC01
PIA_ROM_DATA_B                           = 0xCC02
PIA_ROM_CTRL_B                           = 0xCC03
PIA_WGT_DATA_A                           = 0xCC04
PIA_WGT_CTRL_A                           = 0xCC05
PIA_WGT_DATA_B                           = 0xCC06
PIA_WGT_CTRL_B                           = 0xCC07
BANKSWITCH                               = 0xD000


;RAM Variables

	.org $A002
R_A002:                                  .rs 0x01 ;0xA002


	.org $A005
R_A005_IRQ_STACK_VAL_1:                  .rs 0x01 ;0xA005

R_A006_SCORE_POS_CHAR:                   .rs 0x01 ;0xA006

R_A007_IRQ_STACK_VAL_2:                  .rs 0x01 ;0xA007

HIGHSCORE_INITIALS_ADDR:                 .rs 0x03 ;0xA008 to A00A
A00B_PLANET_GEN_DATA_PTR:                .rs 0x01 ;0xA00B


	.org $A00D
SHITED_DATA_A00D:                        .rs 0x01 ;0xA00D

A00B_PLANET_GEN_SEED:                    .rs 0x01 ;0xA00E

COUNTDOWN_A00F:                          .rs 0x01 ;0xA00F

A010_PLANET_SHIFTS_COUNTDOWN:            .rs 0x01 ;0xA010

A011_TIED_WITH_A00D:                     .rs 0x01 ;0xA011

A012_PLANET_HEIGHT_CREATING:             .rs 0x01 ;0xA012

R_A013_STACK_SAVE_IRQ_RTN_B7:            .rs 0x01 ;0xA013


	.org $A015
A015_X_MATCH:                            .rs 0x01 ;0xA015


	.org $A017
A017_COMPARED_TO_A017:                   .rs 0x01 ;0xA017


	.org $A020
R_A020_SCREEN_POS_CHANGE?:               .rs 0x01 ;0xA020


	.org $A022
R_A022_UNK:                              .rs 0x01 ;0xA022


	.org $A024
A024_TIME_PLAYED?:                       .rs 0x01 ;0xA024


	.org $A026
COLOR_PALETTE_RAM_COPY:                  .rs 0x10 ;0xA026 to A035
CURRENT_BANK:                            .rs 0x01 ;0xA036

VAL_FROM_SRAM_C495-C496:                 .rs 0x01 ;0xA037


	.org $A03D
TEXT_PTR_TO_CODE_JSR:                    .rs 0x02 ;0xA03D to A03E
TEXT_PTR_TO_CODE_JMP:                    .rs 0x02 ;0xA03F to A040

	.org $A047
UNK_$47:                                 .rs 0x01 ;0xA047

UNK_$48:                                 .rs 0x01 ;0xA048

UNK_$49_SYS_MENU_FLAG?:                  .rs 0x01 ;0xA049


	.org $A04C
TEXT_DATA_SPACING_XXYY?:                 .rs 0x02 ;0xA04C to A04D
SENTENCE_CURR_SCR_LOC_CR_XXYY?:          .rs 0x02 ;0xA04E to A04F
SENTENCE_CURR_SCR_LOC_XXYY:              .rs 0x02 ;0xA050 to A051
SENTENCE_PTR_WORD_ON:                    .rs 0x02 ;0xA052 to A053
SENTENCE_PTR_TO_WORD:                    .rs 0x01 ;0xA054


	.org $A056
SENTENCE_END_PTR:                        .rs 0x01 ;0xA056


	.org $A058
SENTENCE_FLAG_58:                        .rs 0x01 ;0xA058

TEXT_PTR_UNK:                            .rs 0x02 ;0xA059 to A05A

	.org $A05D
IRQS_COUNTER:                            .rs 0x01 ;0xA05D


	.org $A05F
LIST_?B_CALLBACKS?:                      .rs 0x01 ;0xA05F


	.org $A061
LIST_15B_OBJECTS_AVAILABLE:              .rs 0x01 ;0xA061


	.org $A063
R_A063_CALLBACK_LIST_ADDR?:              .rs 0x01 ;0xA063
 - Default is A05F

	.org $A065
LIST_$65_ON_SCREEN?:                     .rs 0x01 ;0xA065


	.org $A067
LIST_23B_UNUSED_OBJS?:                   .rs 0x01 ;0xA067


	.org $A069
LIST_23B_OBJECTS_AVAILABLE:              .rs 0x01 ;0xA069


	.org $A06B
LIST_$6B_UNK:                            .rs 0x01 ;0xA06B


	.org $A06D
LIST_$6D_UNK:                            .rs 0x01 ;0xA06D


	.org $A073
A073_SCRATCH_LOOP_WORD?:                 .rs 0x02 ;0xA073 to A074

	.org $A077
R_A077_REGISTER_TEMP?:                   .rs 0x02 ;0xA077 to A078
PIA_ROM_DATA_A_RAM_COPY:                 .rs 0x01 ;0xA079

PIA_ROM_DATA_A_RAM_COPY_OLD:             .rs 0x01 ;0xA07A

WGT_DATA_A_RAM_COPY:                     .rs 0x01 ;0xA07B

WGT_DATA_A_RAM_COPY_OLD:                 .rs 0x01 ;0xA07C

WGT_DATA_B_RAM_COPY:                     .rs 0x01 ;0xA07D

7E_TIMER_SLAM?:                          .rs 0x01 ;0xA07E

7F_TIMER_UNK:                            .rs 0x01 ;0xA07F

80_TIMER_UNK:                            .rs 0x01 ;0xA080

81_TIMER_UNK:                            .rs 0x01 ;0xA081


	.org $A086
R_A086_RUN_CALLBACKS?:                   .rs 0x01 ;0xA086


	.org $A08A
R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT?: .rs 0x01 ;0xA08A

A08B_CURRENT_PLAYER:                     .rs 0x01 ;0xA08B

A08C_CURRENT_PLAYER_COUNT:               .rs 0x01 ;0xA08C

A08D_CURRENT_PLAYER_PTR?:                .rs 0x02 ;0xA08D to A08E
IRQ_CMD_LOC:                             .rs 0x03 ;0xA08F to A091
R_A092_PROCESSING_LAST?:                 .rs 0x01 ;0xA092


	.org $A097
R_A097:                                  .rs 0x01 ;0xA097


	.org $A099
ENEMY_UNK_SPAWNED?BULLET?:               .rs 0x01 ;0xA099


	.org $A09F
PTR_TO_A162_POOL:                        .rs 0x01 ;0xA09F


	.org $A0A2
VIDEO_BITS_LOCATION_COPY:                .rs 0x02 ;0xA0A2 to A0A3

	.org $A0A6
RANDOM_PALETTE_ROTATION_DEFENDER_LOGO?:  .rs 0x01 ;0xA0A6


	.org $A0A8
PTR_TO_A1A2_POOL:                        .rs 0x01 ;0xA0A8


	.org $A0AB
R_A0AB:                                  .rs 0x01 ;0xA0AB


	.org $A0B5
A0B5_LASER_COUNT?:                       .rs 0x01 ;0xA0B5

ROTATING_COLOR_INDEX:                    .rs 0x01 ;0xA0B6

R_A0B7_UNK_ATTRACT_CHECKS:               .rs 0x01 ;0xA0B7


	.org $A0BA
A0BA_PLAYER_GAME_STATE:                  .rs 0x01 ;0xA0BA


	.org $A0BF
SHIP_SCR_POS_XXYY:                       .rs 0x02 ;0xA0BF to A0C0

	.org $A0C5
PLAYER.VPOS:                             .rs 0x01 ;0xA0C5


	.org $A0CA
PLAYER_V_MOMENTUM:                       .rs 0x01 ;0xA0CA


	.org $A0DF
A0DF_RAND_BYTE:                          .rs 0x01 ;0xA0DF

A0E0_RAND_WORD:                          .rs 0x02 ;0xA0E0 to A0E1
R_A0E2_UNK_REPLACED_BMP_VAR:             .rs 0x01 ;0xA0E2


	.org $A0ED
R_A0ED:                                  .rs 0x01 ;0xA0ED


	.org $A0EF
R_A0EF:                                  .rs 0x01 ;0xA0EF


	.org $A0FA
A0FA_HUMANOID_COUNT?:                    .rs 0x01 ;0xA0FA

R_A0FB_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA0FB


	.org $A0FE
R_A0FE_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA0FE


	.org $A100
R_A100:                                  .rs 0x01 ;0xA100

R_A101:                                  .rs 0x01 ;0xA101

R_A102:                                  .rs 0x01 ;0xA102

R_A103:                                  .rs 0x01 ;0xA103


	.org $A105
R_A105:                                  .rs 0x01 ;0xA105

R_A106:                                  .rs 0x01 ;0xA106

R_A107:                                  .rs 0x01 ;0xA107

R_A108:                                  .rs 0x01 ;0xA108


	.org $A10A
R_A10A:                                  .rs 0x01 ;0xA10A

R_A10B:                                  .rs 0x01 ;0xA10B

R_A10C:                                  .rs 0x01 ;0xA10C

R_A10D:                                  .rs 0x01 ;0xA10D

R_A10E:                                  .rs 0x01 ;0xA10E

R_A10F:                                  .rs 0x01 ;0xA10F

R_A110:                                  .rs 0x01 ;0xA110

R_A111:                                  .rs 0x01 ;0xA111

R_A112_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA112

R_A113_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA113

R_A114_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA114

R_A115_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA115

R_A116_ENEMY_IDK_COUNT:                  .rs 0x01 ;0xA116

R_A117:                                  .rs 0x01 ;0xA117

R_A118:                                  .rs 0x01 ;0xA118

R_A119_BAITER_COUNT?:                    .rs 0x01 ;0xA119


	.org $A162
DRAW_CMD_TEMP?:                          .rs 0x01 ;0xA162

DRAW_COUNTER_ACTUAL:                     .rs 0x01 ;0xA163

R_A164_HIGHSCORE_DATA_POS:               .rs 0x01 ;0xA164

R_A165:                                  .rs 0x01 ;0xA165

DRAW_PIXEL_POS_XXYY:                     .rs 0x02 ;0xA166 to A167
R_A168:                                  .rs 0x01 ;0xA168


	.org $A16A
DRAW_STEPS_COUNT_SEED_VAL:               .rs 0x01 ;0xA16A

R_A16B_DRAWING_DATA_PTR?:                .rs 0x01 ;0xA16B


	.org $A16D
R_A16D:                                  .rs 0x01 ;0xA16D


	.org $A16F
R_A16F:                                  .rs 0x01 ;0xA16F


	.org $A171
R_A171:                                  .rs 0x01 ;0xA171


	.org $A173
R_A173:                                  .rs 0x01 ;0xA173


	.org $A175
R_IDK_VAL_USED_TO_STORE?:                .rs 0x01 ;0xA175

R_PAIR_UPPER:                            .rs 0x01 ;0xA176

R_PAIR_LOWER:                            .rs 0x01 ;0xA177

R_A178_LEAVE_INITIAL_FLAG?:              .rs 0x01 ;0xA178

PREV_CHAR_MOVEMENT:                      .rs 0x01 ;0xA179

INITIAL_POS_INDEX:                       .rs 0x01 ;0xA17A

R_A17B:                                  .rs 0x01 ;0xA17B


	.org $A17D
INITIAL_ENTER_TIMER?:                    .rs 0x01 ;0xA17D

R_A17E:                                  .rs 0x01 ;0xA17E

R_A17F:                                  .rs 0x01 ;0xA17F


	.org $A181
R_A181_HIGHSCORE_SCR_POS:                .rs 0x01 ;0xA181


	.org $A183
R_A183_VAL_FROM_SRAM:                    .rs 0x01 ;0xA183

R_A184:                                  .rs 0x01 ;0xA184

R_A185:                                  .rs 0x01 ;0xA185

R_A186:                                  .rs 0x01 ;0xA186

R_A187_OBJ_TMP_4?:                       .rs 0x01 ;0xA187


	.org $A189
R_A189_OBJ_TMP?:                         .rs 0x01 ;0xA189


	.org $A18B
R_A18B_OBJ_PTR_SHIP?:                    .rs 0x01 ;0xA18B


	.org $A18D
R_A18D_OBJ_TMP_3?:                       .rs 0x01 ;0xA18D


	.org $A18F
R_A18F_HUMANOID_LOOP_COUNTER:            .rs 0x01 ;0xA18F

R_A190_OBJ_PTR_INIT_LANDER/SCORE?:       .rs 0x01 ;0xA190


	.org $A192
R_A192_OBJ_PTR_SCRATCH:                  .rs 0x01 ;0xA192


	.org $A194
R_A194:                                  .rs 0x01 ;0xA194


	.org $A196
R_A196_ATTRACT_TEXT_CURRENT:             .rs 0x02 ;0xA196 to A197
R_A198_ATTRACT_NEXT_PTR:                 .rs 0x02 ;0xA198 to A199

	.org $A1C6
R_A1C6:                                  .rs 0x01 ;0xA1C6


	.org $A1C8
R_A1C8:                                  .rs 0x01 ;0xA1C8

R_A1C9_P1_SHIPS:                         .rs 0x01 ;0xA1C9


	.org $A1CB
R_A1CB_P1_SMARTBOMBS:                    .rs 0x01 ;0xA1CB


	.org $A206
R_A206_P2_SHIPS:                         .rs 0x01 ;0xA206


	.org $A208
R_A208_P2_SMARTBOMBS:                    .rs 0x01 ;0xA208


	.org $BDD0
R_BDD0:                                  .rs 0x01 ;0xBDD0



;Program ROM code

;Laid out as:
;	0xD000-0xFFFF
;	0xC000 Bank 1
;	0xC000 Bank 2
;	0xC000 Bank 3
;	0xC000 Bank 7

	.org $D000

    DECA
SET_UP_CALLBACK_IN_CURRENT_CALLBACK: ; 0x000001, $D001
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load U from
    STA   4,U ; OBJ[4], Countdown to handler.
    STX   2,U ; OBJ[2], Handler
    JMP   U=U.NEXT,HANDLE_CALLBACK
CALLBACK_REMOVE?: ; 0x00000A, $D00A
    LDX   R_A063_CALLBACK_LIST_ADDR? ; X from callback list.
    BSR   XOBJ_BACK_TO_AVAILABLE_LIST ; Remove from all obj list.
    LEAU  X ; U is X obj, A05F->next.next?
    JMP   U=U.NEXT,HANDLE_CALLBACK ; Goto U handle.
XOBJ[6]_BACK_TO_AVAILABLE_LIST: ; 0x000013, $D013
    LDX   6,X ; X from OBJ[6]
XOBJ_BACK_TO_AVAILABLE_LIST: ; 0x000015, $D015
    PSHS  U,B,A ; Save what we clobber.
    LDU   #$A05F ; Load list callbacks?
OBJX_REMOVE_FROM_A05F_TO_AVAILABLE: ; 0x00001A, $D01A
    CMPX  U ; If X _ U.Next
    BNE   U_TO_NEXT ; !=, goto. Order: U -> X -> U->next.next/X.next
    LDD   X ; D = X.next
    STD   U ; Move to U.next. X now removed from order
    LDA   6,X ; Get data in OBJ[6]
    BEQ   OBJ_SIZE_15B ; If OBJ[6] = 0, put back to 15B list.
    LDD   LIST_23B_OBJECTS_AVAILABLE ; D = List obj
    STX   LIST_23B_OBJECTS_AVAILABLE ; Replace OBJ with X
    BRA   X.NEXT_FROM_REPLACED ; goto
OBJ_SIZE_15B: ; 0x00002C, $D02C
    LDD   LIST_15B_OBJECTS_AVAILABLE ; Load list obj
    STX   LIST_15B_OBJECTS_AVAILABLE ; Replace OBJ with X
X.NEXT_FROM_REPLACED: ; 0x000030, $D030
    STD   X ; Replaced obj is new head's .next
    LEAX  U ; X is original U->next.next, continuing passed list.
    PULS  A,B,U,PC ; RTS
U_TO_NEXT: ; 0x000036, $D036
    LDU   U ; U=U.next, next list item.
    BNE   OBJX_REMOVE_FROM_A05F_TO_AVAILABLE ; if U != NULL, continue search.
SYSTEM_PANIC: ; 0x00003A, $D03A
    NOP ; If it never finds X to remove, runs this. Idk why nop.
    JMP   DEFENDER_GAME_TITLE? ; Assume crash?
GET_OBJ_23B+INIT: ; 0x00003E, $D03E
    PSHS  U,Y,A ; Save
    LDU   LIST_23B_OBJECTS_AVAILABLE ; Get head obj.
    BNE   U_!NULL ; If list has obj. Unintentional jump into inst?
    .db $BD ; JSR NOP+JMP
U_!NULL: ; 0x000045, $D045
    SUBB  $A03A ; SUBB $DP3A
    LDY   U ; Get Y from U.next
    STY   LIST_23B_OBJECTS_AVAILABLE ; New head, U is detatched from list.
    LDA   #$01
    STA   6,U ; OBJ[6] flag.
    LDA   S ; Get A from stack.
    BRA   SCHEDULE_OBJ@U_TO_A063_PTR ; Goto
GET_15B_OBJECT+SCHEDULE: ; 0x000055, $D055
    PSHS  U,Y,A ; Save
    LDU   LIST_15B_OBJECTS_AVAILABLE ; Load PTR
    BNE   PTR_NOT_NULL ; If valid, go here. Should have done BEQ PANIC instead.
    JSR   SYSTEM_PANIC ; Reboot.
PTR_NOT_NULL: ; 0x00005E, $D05E
    LDY   U ; Y = U.next
    STY   LIST_15B_OBJECTS_AVAILABLE ; Store. U is now removed from this list.
    CLR   6,U ; Clear OBJ[6], 15B.
SCHEDULE_OBJ@U_TO_A063_PTR: ; 0x000066, $D066
    STX   2,U ; X passed to OBJ[2], handler?
    STA   5,U ; A passed to OBJ[5], unk.
    LDA   #$01
    STA   4,U ; To OBJ[4], how often to run. BELOW IS A CIRCULAR LIST INSERT.
    LDX   [R_A063_CALLBACK_LIST_ADDR?] ; X = $A063->ROOT.next
    STU   [R_A063_CALLBACK_LIST_ADDR?] ; Attach new $A063->LIST
    STX   U ; Link original list entry to new.
    LEAX  U ; X is now our new obj.
    PULS  A,Y,U,PC ; RTS
PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2: ; 0x00007C, $D07C
    PSHS  X,A ; Save
    LDX   #$A05F ; List start.
X_TO_X.NEXT: ; 0x000081, $D081
    LDX   X ; Get .next
    BEQ   RTS ; If NULL, leave.
    CMPX  R_A063_CALLBACK_LIST_ADDR? ; CMP X to this ptr.
    BEQ   X_TO_X.NEXT ; If match, don't want to sort.
    LDA   5,X ; Load OBJ[5]
    CMPA  #$02 ; If OBJ[5] _ #$02
    BEQ   X_TO_X.NEXT ; ==, keep going.
    BSR   XOBJ_BACK_TO_AVAILABLE_LIST ; Delete
    BRA   X_TO_X.NEXT ; Always traverse again.
RTS: ; 0x000093, $D093
    PULS  A,X,PC ; RTS
FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR: ; 0x000095, $D095
    BSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get obj X
    PSHS  U,Y,B,A ; Save to sys
    STU   6,X ; U to OBJ[6]
    LDU   6,S ; Load X from passed S[0]
    PULU  A,B,Y ; Pull from loaded ptr
    STD   2,X ; to OBJ[2]
    STY   8,X ; To OBJ[8]
    PULU  A,B ; Pull from U
    STD   18,X ; Put to OBJ[18]
    STU   6,S ; Store next instruction.
    PULS  A,B,Y,U,PC ; RTS, restore. FMT:[2.W,8.W,18.W]
LIST_GET_23B,X.next_FROM_$65_ONSCREEN?: ; 0x0000AD, $D0AD
    PSHS  U,B,A ; Save
    LDX   LIST_23B_UNUSED_OBJS? ; Get obj
    BNE   VALID_OBJ ; If valid, goto.
    JSR   SYSTEM_PANIC ; Reboot.
VALID_OBJ: ; 0x0000B6, $D0B6
    LDD   X ; Get X.next
    STD   LIST_23B_UNUSED_OBJS? ; Store to list. X now not in list.
    LDD   LIST_$65_ON_SCREEN? ; Get other list obj
    STD   X ; Store LIST_$65 to X.next
    CLRA ; CLRD
    CLRB
    STD   4,X ; OBJ[4] cleared
    STA   20,X ; OBJ[20] cleared
    PULS  A,B,U,PC ; RTS
REMOVE_X_FROM_LIST_A065|A06B: ; 0x0000C7, $D0C7
    PSHS  U,Y,X ; Save
    LDU   #$A065 ; Ptr, onscreen?
CMP_NEXT_LOOP_A065|A06B: ; 0x0000CC, $D0CC
    CMPX  U ; CMP X to U.next
    BNE   X_NOT_NEXT ; X not next
REMOVE_U.NEXT: ; 0x0000D0, $D0D0
    LDY   [U] ; Get Obj->Obj.next
    STY   U ; Store to U.next, removing X.
    LDY   LIST_23B_UNUSED_OBJS? ; Remember
    STX   LIST_23B_UNUSED_OBJS? ; store removed to loc
    STY   X ; Store remembered to new.next
    PULS  X,Y,U,PC ; RTS
X_NOT_NEXT: ; 0x0000E0, $D0E0
    LDU   U ; U = U.next
    BNE   CMP_NEXT_LOOP_A065|A06B ; If valid, try.
    LDU   #$A06B ; Try other list.
CMP_NEXT_LOOP_GENERIC: ; 0x0000E7, $D0E7
    CMPX  U ; Is X _ U.next
    BEQ   REMOVE_U.NEXT ; If =, remove.
    LDU   U ; U = U.next
    BNE   CMP_NEXT_LOOP_GENERIC ; loop
    JSR   SYSTEM_PANIC ; Do this
REMOVE_X_FROM_LIST_A06D: ; 0x0000F2, $D0F2
    PSHS  U,Y,X ; Save
    LDU   #$A06D ; List ptr
    BRA   CMP_NEXT_LOOP_GENERIC ; Goto
    PSHS  X,DP ; Save...
    STS   R_A077_REGISTER_TEMP? ; Store stack
    BHS   DONT_Y+=2 ; Don't add 2 to Y
    LEAY  2,Y ; Y+=2
DONT_Y+=2: ; 0x000102, $D102
    LDS   2,Y ; Get S from Y+2
    ADDB  #$08 ; Add height
    TFR   D>U ; D is location?
    BRA   GFX_MOVE_4X8
    PSHS  X,DP ; Save
    ADDB  #$08 ; Height
    TFR   D>U ; Pos to U
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear Y
    TFR   A>DP ; Clear
    ANDCC #$00 ; Clear
    BRA   GFX_SET_4X8 ; Set to clear
    PSHS  X,DP ; Save
    ADDB  #$08 ; Add height
    TFR   D>U ; Pos to U
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    TFR   A>DP ; Clear
    ANDCC #$00 ; Clear
    PSHU  Y,X,DP,B,A,CC ; Clear, 10X8?
    LEAU  264,U ; POSX++
    BRA   GFX_SET_8X8 ; Do rest
    PSHS  X,DP ; Save
    STS   R_A077_REGISTER_TEMP? ; Save
    BHS   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000142, $D142
    LDS   2,Y ; Stack from Y+2
    ADDB  #$08 ; Height
    TFR   D>U ; Pos to U
GFX_MOVE_8X8: ; 0x000149, $D149
    PULS  CC,A,B,DP,X,Y
    PSHU  Y,X,DP,B,A,CC
    LEAU  264,U ; POSX++
    PULS  CC,A,B,DP,X,Y
    PSHU  Y,X,DP,B,A,CC
    LEAU  264,U ; POSX++
GFX_MOVE_4X8: ; 0x000159, $D159
    PULS  CC,A,B,DP,X,Y ; Pull 8 bytes. Stack goes up
    PSHU  Y,X,DP,B,A,CC ; Push 8 bytes. 8 vertical, 2 wide. Goes down, hence add >256.
    LEAU  264,U ; Next column, same pos.
    PULS  CC,A,B,DP,X,Y ; Pull 8 bytes.
    PSHU  Y,X,DP,B,A,CC ; Push 8 bytes.
    LDS   R_A077_REGISTER_TEMP? ; Get S
    PULS  DP,X,PC ; RTS
    PSHS  X,DP ; Save
    ADDB  #$08 ; Voff for stack move.
    TFR   D>U ; Screen pos to U
    LDD   #$0000 ; Clear pixels.
    LDX   #$0000
    LEAY  X ; Move X to Y
    TFR   A>DP ; Clear
    ANDCC #$00 ; Clear
GFX_SET_8X8: ; 0x00017D, $D17D
    PSHU  Y,X,DP,B,A,CC ; Push 8x2
    LEAU  264,U ; X++
    PSHU  Y,X,DP,B,A,CC ; Push 8X4
    LEAU  264,U ; X++
GFX_SET_4X8: ; 0x000189, $D189
    PSHU  Y,X,DP,B,A,CC
    LEAU  264,U ; X++
    PSHU  Y,X,DP,B,A,CC
    PULS  DP,X,PC ; RTS
    PSHS  X,DP ; Save
    STS   R_A077_REGISTER_TEMP? ; Save
    BHS   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x00019C, $D19C
    LDS   2,Y ; Get stack from Y+2
    ADDB  #$08 ; Adjust Y pos.
    TFR   D>U ; Pos to U
    PULS  CC,A,B,DP,X,Y ; Pull 8 bytes.
    PSHU  Y,X,DP,B,A,CC ; Push to screen.
    LEAU  264,U ; POSX++
    BRA   GFX_MOVE_8X8 ; We're basically 9x8 lol.
    BHS   SKIP_Y+=2 ; This seems to be the space ship in the scanner?
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x0001B1, $D1B1
    LDY   2,Y ; Add 2...
    TFR   D>U ; Screen pos to U?
    LDD   Y ; D from Y
    STD   U ; D to SCR
    LDD   2,Y ; D to SCRY+2
    STD   2,U
    LDD   4,Y ; D to SCY+4
    STD   256,U ; SCRX+1
    LDD   6,Y
    STD   258,U ; SCRX+1,SCRY+2
    LDD   8,Y
    STD   512,U ; SCRX+2
    LDD   10,Y
    STD   514,U ; SCRX+2,SCRY+2
    RTS ; RTS
    TFR   D>U ; POS to U
    LDD   #$0000 ; Clear
    STD   U ; SCR
    STD   2,U ; SRCY+2
    STD   256,U ; SCRX+1
    STD   258,U ; SCRX+1,SCRY+2
    STD   512,U ; SCRX+2
    STD   514,U ; SCRX+2,SCRY+2
    RTS ; RTS
    BHS   SKIP_Y+=2 ; Other scanner things?
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x0001F5, $D1F5
    LDY   2,Y ; Y+=2
    TFR   D>U ; Screen pos?
    LDD   Y ; Get graphics
    STD   U ; Store to screen
    LDD   2,Y
    STA   2,U ; SCRY+2
    STB   256,U ; SCRX+1
    LDD   4,Y
    STD   257,U ; SCRX+1,Y+2
    RTS ; Leave
    TFR   D>U ; Screen pos?
    LDD   #$0000 ; Clear
    STD   U ; Store SCR
    STA   2,U ; SCRY+2
    STD   256,U ; SCRX+1
    STA   258,U ; SCRX+1,SCRY+2.
    RTS ; RTS
    PSHS  U,X,B,A ; Save
    STS   R_A077_REGISTER_TEMP? ; Save
    BHS   SKIP_Y+=2 ; Do
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000228, $D228
    LDS   2,Y ; S=Y+2
    ADDB  #$04 ; Correct height.
    TFR   D>U ; Screen pos.
    PULS  A,B,X ; Get graphics.
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get graphics.
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LEAU  260,U ; X++
    PULS  A,B,X ; Get
    PSHU  X,B,A ; Push
    LDS   R_A077_REGISTER_TEMP? ; Load stack
    PULS  A,B,X,U,PC ; RTS
    PSHS  U,X,B,A ; Save
    ADDB  #$04 ; Correct pos.
    TFR   D>U ; Pos
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    PSHU  X,B,A ; 4 bytes.
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes.
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes
    LEAU  260,U ; X++
    PSHU  X,B,A ; 4 bytes.
    PULS  A,B,X,U,PC ; RTS
GFX_16X6_MOVE+ADJUST: ; 0x00028E, $D28E
    PSHS  X ; Save
    STS   R_A077_REGISTER_TEMP? ; Save
    BHS   SKIP_Y+=2
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000297, $D297
    LDS   2,Y ; Get S from Y+2
    ADDB  #$06 ; Height
    TFR   D>U ; To SCR
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put 8
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
GFX_12X6_MOVE: ; 0x0002AE, $D2AE
    PULS  A,B,X,Y ; Get 6w
    PSHU  Y,X,B,A ; Put 6
    LEAU  262,U ; X+1
GFX_10X6_MOVE: ; 0x0002B6, $D2B6
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put 5
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LEAU  262,U ; X+1
    PULS  A,B,X,Y ; Get
    PSHU  Y,X,B,A ; Put
    LDS   R_A077_REGISTER_TEMP? ; Restore
    PULS  X,PC ; RTS
GFX_CLEAR_16X6: ; 0x0002DF, $D2DF
    PSHS  X ; Save
    ADDB  #$06 ; Height
    TFR   D>U ; Pos
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    PSHU  Y,X,B,A ; Clear 8w
    LEAU  262,U ; X+1
    PSHU  Y,X,B,A ; Clear
    LEAU  262,U ; X+1
GFX_CLR_12X6: ; 0x0002F9, $D2F9
    PSHU  Y,X,B,A ; Clear
    LEAU  262,U ; X+1
GFX_CLR_10X6: ; 0x0002FF, $D2FF
    PSHU  Y,X,B,A ; Clear
    LEAU  262,U ; X+1
    PSHU  Y,X,B,A
    LEAU  262,U
    PSHU  Y,X,B,A
    LEAU  262,U
    PSHU  Y,X,B,A
    LEAU  262,U
    PSHU  Y,X,B,A
    PULS  X,PC ; RTS
    PSHS  X ; Save
    STS   R_A077_REGISTER_TEMP? ; Save
    BHS   SKIP Y+=2
    LEAY  2,Y ; Y+=2
SKIP Y+=2: ; 0x000324, $D324
    LDS   2,Y ; S+=2
    ADDB  #$06 ; Add height
    TFR   D>U ; Pos
    BRA   GFX_10X6_MOVE ; Move
    PSHS  X ; Save
    ADDB  #$06 ; Height
    TFR   D>U ; Pos
    LDD   #$0000 ; Clear
    LDX   #$0000
    LEAY  X ; Clear
    BRA   GFX_CLR_10X6 ; Do
    PSHS  X ; Save
    STS   R_A077_REGISTER_TEMP? ; Save
    BHS   SKIP_Y+=2 ; Skip
    LEAY  2,Y ; Y+=2
SKIP_Y+=2: ; 0x000346, $D346
    LDS   2,Y ; S = Y+2
    ADDB  #$06 ; Height
    TFR   D>U ; POS
    JMP   GFX_12X6_MOVE ; Move
GFX_CLEAR_12X6: ; 0x000350, $D350
    PSHS  X ; Save
    ADDB  #$06 ; Adj height
    TFR   D>U ; To POS
    LDD   #$0000 ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    BRA   GFX_CLR_12X6 ; Do.
SCORE_ADD_AB: ; 0x000360, $D360
    PSHS  U,Y,X,B,A ; Save
    ORCC  #$01 ; Set CC.c
    ROL   R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT? ; Flag?
    LSRA ; If 1 if shifted off, multiplies value passed by 10
    PSHS  A ; Save
    LDA   #$00 ; Clear if next not taken.
    BHS   SKIP_TIMES_TEN ; If A was odd, take.
    ASLB ; High B...
    ROLA ; to A
    ASLB
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA ; 4x
SKIP_TIMES_TEN: ; 0x000375, $D375
    JSR   GET_PLAYER_PTR_IN_X_FROM_A08B ; Player 1 or 2?
    STD   A073_SCRATCH_LOOP_WORD? ; Store D to loc.
    LDB   #$03 ; Load B
    SUBB  S+ ; Sub B from on stack, clean up stack too?
    LDA   B,X ; Get A from X+B
    ADDA  A073_SCRATCH_LOOP_WORD?+1 ; Add with B stored above.
    DAA ; Dec adjust.
    STA   B,X ; Store back.
    DECB ; B-=1
    BMI   B_NOW_NEGATIVE ; If negative.
LOOP_STILL_POSITIVE: ; 0x000388, $D388
    LDA   B,X ; Get data.
    ADCA  A073_SCRATCH_LOOP_WORD? ; Add with carry now.
    DAA ; Adjust
    STA   B,X ; Store back.
    LDA   #$00
    STA   A073_SCRATCH_LOOP_WORD? ; Clear
    DECB ; Minus another
    BPL   LOOP_STILL_POSITIVE ; If still not negative, loop.
B_NOW_NEGATIVE: ; 0x000396, $D396
    LDD   R_A0AB ; Get D
    BEQ   D_IS_ZERO ; D is 0.
    LEAX  1,X ; X+1
    LEAY  3,X ; Y = X+3
    BSR   IF_X[0].W!=Y[0].W_CMP_X+2_Y+2
    BLO   D_IS_ZERO ; If OBJX state is lower than OBJY?
    LDA   1,Y ; Get val
    ADDA  $A0AC ; Add with val
    DAA ; Adjust
    STA   1,Y ; Store back
    LDA   Y ; Get val
    ADCA  R_A0AB ; Add with carry
    DAA ; Adjust
    STA   Y ; Store back
    INC   6,X ; Inc ships.
    INC   8,X ; Inc smartbombs.
    JSR   DISP_SHIPS_ALL_PLAYERS
    JSR   SMARTBOMBS_TO_SCREEN
    LDD   #$D4B0 ; Idk why
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
    LDB   #$05 ; Score keep entry.
    JSR   GOTO_B3-C00F_BOOKKEEP_UPDATE_+1 ; Track
D_IS_ZERO: ; 0x0003C5, $D3C5
    BSR   CURRENT_PLAYER_SCORE_TO_SCREEN
    PULS  A,B,X,Y,U ; Why not also pull PC???
    RTS ; Ugh
IF_X[0].W!=Y[0].W_CMP_X+2_Y+2: ; 0x0003CA, $D3CA
    PSHS  B,A ; Save
    LDD   X ; Load D from X
    CMPD  Y ; Compare to Y
    BNE   RTS ; RTS, figured.
    LDA   2,X ; Compare score digits 2 instead.
    CMPA  2,Y ; Compare
RTS: ; 0x0003D7, $D3D7
    PULS  A,B,PC ; RTS, Code handles next branch.
CURRENT_PLAYER_SCORE_TO_SCREEN: ; 0x0003D9, $D3D9
    LDA   A08B_CURRENT_PLAYER ; Load val
PLAYER_PASSED_SCORE_TO_SCREEN: ; 0x0003DB, $D3DB
    PSHS  A ; Use passed value.
    DECA ; Dec val
    BNE   PLAYER_TWO_HANDLER ; Do player 2.
    LDX   #$0F1C ; Pos
    LDU   #$A1C3 ; Data ptr
    BRA   USE_REGS ; Use these.
PLAYER_TWO_HANDLER: ; 0x0003E8, $D3E8
    LDX   #$711C ; Pos
    LDU   #$A200 ; Data ptr
USE_REGS: ; 0x0003EE, $D3EE
    CLR   A073_SCRATCH_LOOP_WORD? ; Clear displayed flag.
    LDB   #$06 ; Digit count?
    LDA   CURRENT_BANK ; Save bank.
    PSHS  A ; To stack
    LDA   #$02 ; Switch to bank.
    STA   CURRENT_BANK ; Commit
    STA   BANKSWITCH
LOOP_MORE_DIGITS: ; 0x0003FD, $D3FD
    LDA   U+ ; Get A from U.
    LDY   PALETTE_ENTRY_0x0 ; Get Y val from here, 0xC5something
    BITB  #$01 ; Test if we're high/low nibble.
    BNE   USING_LOW_NIBBLE ; Odd doesn't need shifted, skip code below.
    LEAU  -1,U ; Reset
    LSRA ; Shift high nibble low.
    LSRA
    LSRA
    LSRA
USING_LOW_NIBBLE: ; 0x00040D, $D40D
    ANDA  #$0F ; Isolate. This code basically enables zeros after a valid digit.
    BNE   CHR_TO_SCREEN ; If != 0
    CMPB  #$02 ; If B _ 2
    BLS   CHR_TO_SCREEN ; <=, go. Always show 2 chars.
    TST   A073_SCRATCH_LOOP_WORD? ; Test if went before.
    BNE   CHR_TO_SCREEN ; If did, go again.
    EXG   X-D ; Location to D?
    JSR   GFX_BANK2_CHR_CLEAR ; Clear char.
    BRA   SCORE_CHR_POST ; Done, post put rtn.
CHR_TO_SCREEN: ; 0x000420, $D420
    INC   A073_SCRATCH_LOOP_WORD? ; Since taken, always do.
    ASLA ; *2
    ASLA ; *4, because target fmt is [B,B,W]
    LEAY  A,Y ; Add A to Y
    EXG   X-D ; Loc to D.
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Score digit.
SCORE_CHR_POST: ; 0x00042B, $D42B
    EXG   X-D ; Put loc back to X. Should have ADDA #$04 here instead.
    LEAX  1024,X ; X+=4
    DECB ; Dec digits left.
    BNE   LOOP_MORE_DIGITS ; Do more.
    PULS  A ; Pull bank.
    STA   CURRENT_BANK ; Restore.
    STA   BANKSWITCH
    PULS  A,PC ; RTS
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BPL   REMOVE_X_FROM_LIST ; If positive, goto.
    JSR   BANKSWITCH_TO_3 ; Switch to bank 3..
    JSR   JMP_TO_HIGHSCORES_TO_RAM ; High scores to RAM.
    INC   DRAW_CMD_TEMP? ; Inc
    BRA   REMOVE_X_FROM_LIST ; goto.
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BPL   REMOVE_X_FROM_LIST ; If positive, goto.
    ORCC  #$90 ; Set entire, mask IRQ.
    CLR   BANKSWITCH ; IO bank.
    LDA   #$04 ; REG:IO
    STA   PIA_ROM_CTRL_B ; Store to CTRL.
    LDA   PIA_ROM_DATA_B ; Get. Idk why
    JSR   BANKSWITCH_TO_3 ; Goto bank 3, menu routines.
    LDA   PIA_ROM_DATA_A_RAM_COPY ; Get
    LSRA ; Shift.
    BLO   GOTO_SETTINGS_MENU? ; If shifted off 1,do this instead.
    JMP   JMP_FAILED_W/_AUTO_NOT_PRESSED ; Goto.
GOTO_SETTINGS_MENU?: ; 0x000468, $D468
    JMP   JMP_SETTINGS_MENU? ; Goto.
REMOVE_X_FROM_LIST: ; 0x00046B, $D46B
    JMP   CALLBACK_REMOVE? ; Still need to figure out list stuff.
    LDX   #$A07F ; Ptr
    LDB   #$12 ; Val
    BRA   USE_XB_PROVIDED
    LDX   #$A080 ; PTR
    LDB   #$15 ; Val
    BRA   USE_XB_PROVIDED
    LDX   #$A081 ; Ptr
    LDB   #$18 ; Val
USE_XB_PROVIDED: ; 0x000481, $D481
    LDA   7E_TIMER_SLAM? ; Get val
    BNE   REMOVE_X_FROM_LIST ; If != 0, goto.
    LDA   X ; Get val from ptr.
    BNE   REMOVE_X_FROM_LIST ; If != 0, goto.
    LDA   #$16 ; Idk val.
    STA   X ; Store to ptr.
    LDA   #$C0 ; Val
    STD   9,U ; Store to OBJ[9], ptr.
    LDA   #$0A ; Val
    LDX   #$D499 ; Ptr to unk handler.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Mod obj and unk
    LDA   7E_TIMER_SLAM? ; Load val.
    BNE   REMOVE_X_FROM_LIST ; If != 0, goto.
    LDD   #$D4AB ; PTR to data table below.
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Works with data table and other vars.
    JSR   BANKSWITCH_TO_3 ; Switch to.
    JSR   [9,U] ; JSR to handler pointer.
    BRA   REMOVE_X_FROM_LIST ; Loop.
A0B2_DATA?: ; 0x0004AB, $D4AB
    .db $FF
    .db $01
    .db $18
    .db $19
    .db $00
    .db $FF
    .db $01
    .db $20
    .db $1E
    .db $00
    .db $F0
    .db $02
    .db $08
    .db $11
    .db $01
    .db $20
    .db $17
    .db $00
    .db $F0
    .db $01
    .db $40
    .db $0A
    .db $00
    .db $F0
    .db $01
    .db $10
    .db $0B
    .db $00
    .db $E8
    .db $01
    .db $04
    .db $14
    .db $02
    .db $06
    .db $11
    .db $02
    .db $0A
    .db $17
    .db $00
    .db $E8
    .db $06
    .db $04
    .db $11
    .db $01
    .db $10
    .db $17
    .db $00
    .db $E0
    .db $03
    .db $0A
    .db $08
    .db $00
    .db $E0
    .db $01
    .db $18
    .db $1F
    .db $00
    .db $E0
    .db $01
    .db $18
    .db $11
    .db $00
    .db $D8
    .db $01
    .db $10
    .db $1A
    .db $00
    .db $D0
    .db $01
    .db $30
    .db $15
    .db $00
    .db $D0
    .db $01
    .db $10
    .db $05
    .db $00
    .db $D0
    .db $01
    .db $08
    .db $17
    .db $00
    .db $D0
    .db $01
    .db $08
    .db $07
    .db $00
    .db $D0
    .db $01
    .db $0A
    .db $01
    .db $00
    .db $D0
    .db $01
    .db $0A
    .db $06
    .db $00
    .db $D0
    .db $01
    .db $10
    .db $0B
    .db $00
    .db $C8
    .db $0A
    .db $01
    .db $0E
    .db $00
    .db $C0
    .db $01
    .db $08
    .db $07
    .db $00
    .db $C0
    .db $01
    .db $30
    .db $14
    .db $00
    .db $C0
    .db $01
    .db $20
    .db $18
    .db $00
    .db $C0
    .db $01
    .db $08
    .db $03
    .db $00
    .db $C0
    .db $01
    .db $30
    .db $09
    .db $00
    .db $C0
    .db $01
    .db $08
    .db $03
    .db $00
    .db $C0
    .db $01
    .db $18
    .db $0C
    .db $00
WRITE_ROM_PIA_DATA_REGS_W/_#$3F_AND_B_SOUND?: ; 0x000539, $D539
    PSHS  B,A,CC ; Save. This rtn does sounds maybe?
    ORCC  #$FF ; Mask IRQ's
    CLR   BANKSWITCH ; IO bank.
    LDA   #$3F ; Write val
    STA   PIA_ROM_DATA_B ; Store to...
    COMB ; Invert B
    ANDB  #$3F ; LED's to 0's, other doesn't care
    STB   PIA_ROM_DATA_B ; Store to data reg.
    PULS  CC,A,B,PC ; RTS
SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?: ; 0x00054D, $D54D
    PSHS  X,B,A,CC ; Save
    CLR   $A0AD ; Clear loc.
    TFR   D>X ; X=D
    LDA   X ; Get A from X
    CMPA  $A0B2 ; If A _ $A0B2
    BLO   RTS ; <, RTS'S
    STA   $A0B2 ; If higher, store.
    LEAX  -2,X ; Sub 2 from D
    ORCC  #$10 ; Mask IRQ
    STX   $A0B0 ; Store X to.
    LDD   #$0101
    STD   $A0B3 ; Set these?
RTS: ; 0x000566, $D566
    PULS  CC,A,B,X,PC ; RTS
IDK+THRUST+MORE: ; 0x000568, $D568
    LDA   $A0B3 ; Load timer
    BEQ   SOMETHING_TO_DO_WITH_THRUST ; if 0 skip
    DEC   $A0B3 ; Dec if not 0
    BNE   TEST_IRQ_PIA_ROM_A2 ; Goto if not done.
    LDX   $A0B0 ; Load 
    DEC   $A0B4 ; Dec
    BNE   D_FROM_X+1 ; If not 0, do this. Sets timer it seems.
    LEAX  3,X ; X+=3
    STX   $A0B0 ; Store X back
    LDA   X ; Load A from X ptr
    BNE   STORE_A_TO_$B4 ; If != 0, goto.
    STA   $A0B2 ; Store to otherwise.
SOMETHING_TO_DO_WITH_THRUST: ; 0x000580, $D580
    LDA   WGT_DATA_A_RAM_COPY ; Get inputs on wigit A
    BITA  #$02 ; Test thrust pressed
    BNE   THRUST_NOT_PRESSED ; Thrust not pressed, goto.
    LDA   $A0AD ; Load
    BEQ   TEST_IRQ_PIA_ROM_A2 ; If 0, goto.
    CLR   $A0AD ; Clear otherwise.
    LDB   #$0F ; Load B
    BRA   WRITE_ROM_PIA_WITH_B_RTN ; Always goto.
THRUST_NOT_PRESSED: ; 0x000590, $D590
    LDA   $A0AD ; Load val
    BNE   TEST_IRQ_PIA_ROM_A2 ; If != 0, goto
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$98 ; Test IDK
    BNE   TEST_IRQ_PIA_ROM_A2 ; If none set, goto
    LDB   #$16 ; Load B
    STB   $A0AD ; Store to
    BRA   WRITE_ROM_PIA_WITH_B_RTN ; Goto
STORE_A_TO_$B4: ; 0x0005A0, $D5A0
    STA   $A0B4 ; Store A
D_FROM_X+1: ; 0x0005A2, $D5A2
    LDD   1,X ; Get data from X+1
    STA   $A0B3 ; Store A loaded here
WRITE_ROM_PIA_WITH_B_RTN: ; 0x0005A6, $D5A6
    BSR   WRITE_ROM_PIA_DATA_REGS_W/_#$3F_AND_B_SOUND? ; Write it
TEST_IRQ_PIA_ROM_A2: ; 0x0005A8, $D5A8
    LDA   PIA_ROM_CTRL_A ; Get CTRL
    BITA  #$40 ; Test C2, SLAM switch
    BEQ   C2_CLEAR ; If not set, don't seed.
    LDA   #$3C ; Not clear, seed.
    STA   7E_TIMER_SLAM? ; Store
C2_CLEAR: ; 0x0005B3, $D5B3
    LDA   7E_TIMER_SLAM? ; Get value
    BEQ   7E_ZERO ; If 0, goto
    DEC   7E_TIMER_SLAM? ; Dec otherwise
7E_ZERO: ; 0x0005B9, $D5B9
    LDA   7F_TIMER_UNK ; Load
    BEQ   7F_ZERO ; If 0, goto
    DEC   7F_TIMER_UNK ; Dec otherwise.
7F_ZERO: ; 0x0005BF, $D5BF
    LDA   81_TIMER_UNK ; Load
    BEQ   81_ZERO ; If 0, goto
    DEC   81_TIMER_UNK ; Dec otherwise
81_ZERO: ; 0x0005C5, $D5C5
    LDA   80_TIMER_UNK ; Load
    BEQ   80_ZERO ; If 0, goto
    DEC   80_TIMER_UNK ; Dec otherwise
80_ZERO: ; 0x0005CB, $D5CB
    LDA   WGT_DATA_A_RAM_COPY ; Get copy
    ORA   WGT_DATA_A_RAM_COPY_OLD ; OR with old.
    COMA ; Invert.
    LDB   WGT_DATA_A_RAM_COPY ; Move
    STB   WGT_DATA_A_RAM_COPY_OLD ; to old
    LDB   PIA_WGT_DATA_A ; Move
    STB   WGT_DATA_A_RAM_COPY
    LDB   PIA_WGT_DATA_B ; Move
    STB   WGT_DATA_B_RAM_COPY
    ANDA  WGT_DATA_A_RAM_COPY ; AND with new, gets newly pressed.
    BEQ   CHECK_COINDOOR_INPUT ; No new
    LDU   #$F882 ; Change U...
FILL_IN_$82-$88: ; 0x0005E5, $D5E5
    CLRB ; Clear
LOOP_ADD_4: ; 0x0005E6, $D5E6
    ADDB  #$04 ; Add B
    LSRA ; Shift to carry
    BHS   LOOP_ADD_4 ; If C = 0, loop.
    LEAU  B,U ; U += B
    PULU  A,B,X ; Fill in A,B,X from U
    LDU   $A082 ; Load U from addr
    BNE   U_IS_VALID ; If U != 0
    STD   $A082 ; Ret this on null.
    STX   $A084
    RTS ; Rts
U_IS_VALID: ; 0x0005F8, $D5F8
    STD   R_A086_RUN_CALLBACKS? ; Ret this otherwise.
    STX   $A088
    RTS ; Rts
CHECK_COINDOOR_INPUT: ; 0x0005FD, $D5FD
    LDA   PIA_ROM_DATA_A_RAM_COPY ; Load A with all pressed last 2 reads.
    ORA   PIA_ROM_DATA_A_RAM_COPY_OLD
    COMA ; Invert, 1's are newly pressed now.
    LDB   PIA_ROM_DATA_A_RAM_COPY ; Move last to old
    STB   PIA_ROM_DATA_A_RAM_COPY_OLD
    LDB   PIA_ROM_DATA_A ; Get current buttons.
    ANDB  #$3F ; Get only the buttons.
    STB   PIA_ROM_DATA_A_RAM_COPY ; Update this
    BITA  PIA_ROM_DATA_A_RAM_COPY ; Test if any are newly pressed that we need to catch.
    BEQ   RTS ; If no matches on newly pressed.
    LDX   #$0078 ; Time to wait.
WAIT_FOR_X_TO_0: ; 0x000614, $D614
    LEAX  -1,X ; X--
    BNE   WAIT_FOR_X_TO_0 ; Loop
    LDB   PIA_ROM_DATA_A ; Get buttons again.
    ANDB  PIA_ROM_DATA_A_RAM_COPY ; Get bits pressed both times.
    STB   PIA_ROM_DATA_A_RAM_COPY ; Replace
    ANDA  PIA_ROM_DATA_A_RAM_COPY ; See if any buttons newly pressed.
    BEQ   RTS ; No, RTS
    LDU   #$F8A2 ; PTR to data
    BSR   FILL_IN_$82-$88
RTS: ; 0x000628, $D628
    RTS
DISP_SHIPS_ALL_PLAYERS: ; 0x000629, $D629
    PSHS  U,Y,X,B,A ; Save
    LDX   #$0F14 ; Scr pos, X:30,Y14
    LDA   R_A1C9_P1_SHIPS ; Load ship count?
    BSR   DISPLAY_SHIPS ; Disp
    LDA   A08C_CURRENT_PLAYER_COUNT
    DECA ; See if 1
    BEQ   RTS_SHIPS ; Was 1, leave.
    LDX   #$7114
    LDA   R_A206_P2_SHIPS
    BSR   DISPLAY_SHIPS ; Disp
RTS_SHIPS: ; 0x000640, $D640
    PULS  A,B,X,Y,U,PC ; RTS
DISPLAY_SHIPS: ; 0x000642, $D642
    CMPA  #$05 ; If A _ 5
    BLS   DONT_CAP_COUNT ; <= 5, taken.
    LDA   #$05 ; Cap at 5 ships
DONT_CAP_COUNT: ; 0x000648, $D648
    PSHS  A ; Save val
    LDD   #$2006 ; WWHH, Clear rectangle.
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear it.
    LDA   S ; Get count.
    BEQ   RTS ; Leave if no ships to put on.
    LDY   #$F9D5 ; PTR to CHR
    TFR   X>D ; Position to proper reg.
LOOP_DISPLAY_SHIPS: ; 0x00065A, $D65A
    JSR   GFX_BANK2_CHR_TO_SCREEN
    ADDA  #$06 ; Add X off.
    DEC   S ; One less.
    BNE   LOOP_DISPLAY_SHIPS ; Display loop.
RTS: ; 0x000663, $D663
    PULS  A,PC ; RTS
DISPLAY_SETUP_INGAME: ; 0x000665, $D665
    PSHS  U,Y,X,B,A
    LDD   #$4020 ; POS
    LDX   #$3008 ; XXYY
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear area.
    BSR   SCANNER_TO_SCREEN ; Put scanner to screen.
    BSR   DISP_SHIPS_ALL_PLAYERS ; Ships.
    BSR   SMARTBOMBS_TO_SCREEN ; Smartbombs.
    LDA   A08C_CURRENT_PLAYER_COUNT ; Load which player?
SCORE_LOOP: ; 0x000678, $D678
    JSR   PLAYER_PASSED_SCORE_TO_SCREEN ; Put that player to screen.
    DECA
    BNE   SCORE_LOOP ; Loop again.
    PULS  A,B,X,Y,U,PC ; RTS
SMARTBOMBS_TO_SCREEN: ; 0x000680, $D680
    PSHS  U,Y,X,B,A
    LDX   #$291B ; Pos P1
    LDA   R_A1CB_P1_SMARTBOMBS ; Get count.
    BSR   DISPLAY_SMARTBOMBS_SUB
    LDA   A08C_CURRENT_PLAYER_COUNT ; Player count
    DECA ; DEC
    BEQ   RTS_SMARTBOMBS ; Is only 1 player, leave.
    LDX   #$8B1B ; Pos P2
    LDA   R_A208_P2_SMARTBOMBS ; Count
    BSR   DISPLAY_SMARTBOMBS_SUB
RTS_SMARTBOMBS: ; 0x000697, $D697
    PULS  A,B,X,Y,U,PC
DISPLAY_SMARTBOMBS_SUB: ; 0x000699, $D699
    CMPA  #$03 ; If A _ 3
    BLS   DONT_CAP_SMARTBOMBS ; <=, skip cap.
    LDA   #$03 ; Cap
DONT_CAP_SMARTBOMBS: ; 0x00069F, $D69F
    PSHS  A ; Save count.
    LDD   #$030B ; Clear WWHH
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear
    LDA   S ; Load count
    BEQ   ALL_SMARTBOMBS_DISPLAYED
    LDY   #$F9D9 ; PTR to BMP for Smartbombs.
    TFR   X>D ; Pos X to correct reg for sub.
LOOP_MORE_SMARTBOMBS: ; 0x0006B1, $D6B1
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Display
    ADDB  #$04 ; Add Y pos.
    DEC   S ; Dec count.
    BNE   LOOP_MORE_SMARTBOMBS
ALL_SMARTBOMBS_DISPLAYED: ; 0x0006BA, $D6BA
    PULS  A,PC
SCANNER_TO_SCREEN: ; 0x0006BC, $D6BC
    LDD   #$5555 ; Load color
    LDX   #$0028 ; XXYY pos.
LOOP_SCANNER_ENTIRE_SCREEN_H: ; 0x0006C2, $D6C2
    STD   X ; Store 2x2
    LEAX  256,X ; X++
    CMPX  #$9C00 ; Compare to end of screen.
    BLO   LOOP_SCANNER_ENTIRE_SCREEN_H
    LDX   #$2F08 ; XXYY
LOOP_V_SECTION: ; 0x0006D0, $D6D0
    STD   16640,X ; POS X + 65
    STD   X++ ; POS
    CMPX  #$2F28 ; End V
    BNE   LOOP_V_SECTION
    LDX   #$2F07 ; Pos small H.
H_PART_SMALL: ; 0x0006DE, $D6DE
    STA   X ; Put byte.
    LEAX  256,X ; X+1
    CMPX  #$7107 ; End pos
    BNE   H_PART_SMALL ; Not done loop.
    LDX   #$4C07 ; XXYY pos.
    LDD   #$9999 ; White?
LOOP_WHITE_PART: ; 0x0006EF, $D6EF
    STD   X ; Store top
    STD   33,X ; Bottom
    LEAX  256,X ; X+1
    CMPX  #$5407 ; End X
    BNE   LOOP_WHITE_PART ; Not done, loop.
    RTS
GET_PLAYER_PTR_IN_X_FROM_A08B: ; 0x0006FE, $D6FE
    PSHS  A ; Save A
    LDA   A08B_CURRENT_PLAYER ; Get A
DECIDE_X_A1C2|A1FF_SUB: ; 0x000702, $D702
    LDX   #$A1C2 ; Load X
    DECA ; Dec A
    BEQ   RTS_PULA
    LDX   #$A1FF ; Change X if not 0.
RTS_PULA: ; 0x00070B, $D70B
    PULS  A,PC ; RTS
DECIDE_PLAYER_PTR_FROM_A: ; 0x00070D, $D70D
    PSHS  A
    BRA   DECIDE_X_A1C2|A1FF_SUB
RANDOM_VALUE_FWD+IN_A: ; 0x000711, $D711
    PSHS  B ; Save B
    LDB   A0DF_RAND_BYTE ; Get val.
    LDA   #$03 ; Load A
    MUL ; Multiple B*3
    ADDB  #$11 ; Add with #$11
    LDA   A0E0_RAND_WORD+1 ; Load val
    LSRA ; >>1
    LSRA ; >>2
    LSRA ; >>3
    EORA  A0E0_RAND_WORD+1 ; EOR with original...
    LSRA ; >>1
    ROR   A0E0_RAND_WORD ; Rotate loc...
    ROR   A0E0_RAND_WORD+1 ; Rotate loc...
    ADDB  A0E0_RAND_WORD+1 ; Add B with 
    ADCB  A0E0_RAND_WORD ; Add B with carry.
    STB   A0DF_RAND_BYTE ; Store to.
    LDA   A0DF_RAND_BYTE ; Get A from...
    PULS  B,PC ; Recover B, RTS.
ROM_PIA_DDR_A: ; 0x000730, $D730
    .db $C0 ; 1=Out, 0=Inp
WGT_PIA_DDR_B: ; 0x000731, $D731
    .db $FF
WGT_PIA_DDR_A: ; 0x000732, $D732
    .db $00
WGT_PIA_DDR_B: ; 0x000733, $D733
    .db $00
ROM_PIA_CTRL_A: ; 0x000734, $D734
    .db $14 ; C2 L2H, OUTPUT REG, C1 H2L
ROM_PIA_CTRL_B: ; 0x000735, $D735
    .db $05 ; C2 H2L, OUTPUT REG, C1 H2L+INT
WGT_PIA_CTRL_A: ; 0x000736, $D736
    .db $34 ; C2 OUT+LOW, OUTPUT REG
WGT_PIA_CTRL_B: ; 0x000737, $D737
    .db $3E ; C2 OUT+HIGH, OUTPUT REG, C1 L2H
DEFENDER_GAME_TITLE?: ; 0x000738, $D738
    ORCC  #$FF ; Mask interrupts.
    LDS   #$BFFF ; Set S to top of RAM.
    LDA   #$A0
    TFR   A>DP ; DP=$A0
    CLR   BANKSWITCH ; Bank 0.
    LDB   #$04 ; 3 loops
    LDU   #$CC00 ; IO PIAs
    LDX   #$D730 ; PIA_DATA_D730
PIA_SET_LOOP: ; 0x00074D, $D74D
    CLR   1,U ; Clear CTRL
    LDA   X+ ; Get data from X
    STA   U++ ; Store at DATA
    LDA   3,X ; Get other setup
    STA   -1,U ; Store to PIA CTRL
    DECB ; Loop counter
    BNE   PIA_SET_LOOP
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    LDX   #$9C00 ; Set to start of non-screen RAM.
CLEAR_X_TO_$C000: ; 0x000760, $D760
    CLR   X+
    LDB   #$38 ; Always set watchdog.
    STB   WATCHDOG
    CMPX  #$C000 ; Go to $C000
    BNE   CLEAR_X_TO_$C000 ; Loop
    CLR   PIA_ROM_DATA_A ; Write outputs to 0's.
    CLR   PIA_ROM_DATA_B
    LDX   #$C47D ; SRAM pointer
    JSR   GET_DATA_FROM_SRAM[X]_IN_B
    TFR   B>A ; Put to A
    CMPA  #$20 ; Blank? Space?
    BHI   CLEAR_B ; If above, write cleared.
    ANDA  #$0F ; Get bottom bits.
    CMPA  #$09 ; If _ 9
    BLS   COMMIT_B_AS_IS ; <=, commit same value.
CLEAR_B: ; 0x000784, $D784
    CLRB ; Init to clear.
COMMIT_B_AS_IS: ; 0x000785, $D785
    STB   VAL_FROM_SRAM_C495-C496 ; Set var from B
    LDD   #$A55A ; Not sure of val, ptr?
    STD   A0E0_RAND_WORD ; Seed random.
    LDD   #$FF70 ; PTR to 0's?
    STD   $A0A1 ; Store to...
    CLR   VIDEO_BITS_LOCATION_COPY+1 ; NULL?
    LDB   #$FF ; D=A0FF
    STD   PIA_ROM_DATA_A_RAM_COPY ; Store...
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED ; Set screen+other
    JSR   BANKSWITCH_TO_3 ; Goto bank
    JSR   JMP_TO_HIGHSCORES_TO_RAM ; Move initial to RAM.
    BSR   LIST_INIT_A05F,A061,A063,A069 ; Inits some lists.
    BSR   GAME_OBJECTS_INIT ; Does tons with pools of memory.
    JSR   SETUP_TEXT+UNK ; Sets up idk, also bankswitches?
    LDX   #$D825 ; OBJ+2, BANK 1 - C000
    LDA   #$01 ; OBJ+5
    JSR   GET_15B_OBJECT+SCHEDULE ; Sets up something.
    COM   A0BA_PLAYER_GAME_STATE
    ANDCC #$00 ; Unmask IRQ's
    JMP   MAIN_WAIT_LOOP? ; Jumps to...
GAME_OBJECTS_INIT: ; 0x0007B6, $D7B6
    BSR   SETUP_$A026_TO_$A036
    JSR   LASER_HOLES_POOL_CREATION_FROM_RANDOM
    JSR   INIT_STARS
    BSR   CHAIN_LIST_$67,NULL_$65_$6B_$6D
    JSR   SETUP_A1A2-A1B1_WITH_99/9A/A9/AA
    JMP   SETUP_POOL_4162
LIST_INIT_A05F,A061,A063,A069: ; 0x0007C6, $D7C6
    PSHS  X,B,A ; Save
    CLRA
    CLRB
    LDX   #$AAC5 ; PTR to list start?
    STX   LIST_15B_OBJECTS_AVAILABLE ; Store ptr
LOOP_CREATE_LIST_15: ; 0x0007CF, $D7CF
    LEAX  15,X ; Add 15 to X
    STX   -15,X ; Store current X to last. AKA creating a list.
    CMPX  #$AF1B ; End of list, 0x4A entries.
    BNE   LOOP_CREATE_LIST_15
    STD   X ; NULL OBJ.next
    STD   LIST_?B_CALLBACKS? ; Null whatever list this is.
    LDX   #$AF2A ; PTR to next list.
    STX   LIST_23B_OBJECTS_AVAILABLE ; Point to this list.
LOOP_CREATE_LIST_23: ; 0x0007E1, $D7E1
    LEAX  23,X ; Add 23 bytes.
    STX   -23,X ; Store this to PREV.next
    CMPX  #$AF86 ; End of list, 4 entries.
    BNE   LOOP_CREATE_LIST_23
    STD   X ; Null OBJ.next
    LDX   #$A05F ; Initial location.
    STX   R_A063_CALLBACK_LIST_ADDR? ; For list.
    PULS  A,B,X,PC ; RTS
SETUP_$A026_TO_$A036: ; 0x0007F5, $D7F5
    LDX   #$F8BE ; PTR to data.
    LDU   #$A026 ; PTR to stuff.
    LDB   #$10 ; 0x0F bytes to move.
LOOP_MOVE_DATA: ; 0x0007FD, $D7FD
    LDA   X+ ; Get data from X.
    STA   U+ ; Store to ptr.
    DECB ; Loop counter.
    BNE   LOOP_MOVE_DATA
    RTS ; Leave
CHAIN_LIST_$67,NULL_$65_$6B_$6D: ; 0x000805, $D805
    PSHS  X,B,A,CC ; Save
    ORCC  #$FF ; Mask interrupts?
    LDX   #$A23C ; Initial
    STX   LIST_23B_UNUSED_OBJS? ; Store to...
LIST_23B_LOOP: ; 0x00080E, $D80E
    LEAX  23,X ; Space
    STX   -23,X ; Store PREV.next
    CMPX  #$AAAE ; End of pool. 5E items.
    BNE   LIST_23B_LOOP ; Loop
    CLRA ; Clear D
    CLRB
    STD   X ; NULL OBJ.next
    STD   LIST_$6B_UNK ; Null
    STD   LIST_$65_ON_SCREEN? ; Null
    STD   LIST_$6D_UNK ; Null
    PULS  CC,A,B,X,PC ; RTS
GOTO_B1_C000: ; 0x000825, $D825
    JSR   BANKSWITCH_TO_1
    JMP   JMP_ATTRACT_START?
SRAM_C495_LOAD: ; 0x00082B, $D82B
    LDX   #$C495 ; Ptr
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get data
    DECA ; Sub 1
    BNE   RTS ; Use val if not 0.
    LDA   #$02 ; Default
    STA   VAL_FROM_SRAM_C495-C496 ; Store
RTS: ; 0x000838, $D838
    RTS
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BPL   LIST_RTN_INSTEAD ; If positive, do list rtn.
    BSR   SRAM_C495_LOAD ; Put to RAM
    LDA   VAL_FROM_SRAM_C495-C496 ; Load
    BEQ   LIST_RTN_INSTEAD ; If 0, do instead.
    LDD   #$D4BD ; Ptr to data table idk yet.
JSR_UNK_BSR_IDK: ; 0x000846, $D846
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Mod stuff.
    BSR   L_000861
LIST_RTN_INSTEAD: ; 0x00084B, $D84B
    JMP   CALLBACK_REMOVE? ; Lots goes here.
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BPL   LIST_RTN_INSTEAD ; If positive, AKA not pointing to ROM?
    BSR   SRAM_C495_LOAD ; Put to RAM
    LDA   VAL_FROM_SRAM_C495-C496 ; Load A
    CMPA  #$02 ; If _ #$02
    BLO   LIST_RTN_INSTEAD ; <, goto
    BSR   L_000861
    LDD   #$D4C2 ; Idk why val.
    BRA   JSR_UNK_BSR_IDK ; Mod and list.
L_000861: ; 0x000861, $D861
    CLR   $A038 ; Clear
    NOP
    LDA   R_A0B7_UNK_ATTRACT_CHECKS ; Load
    BEQ   RTS ; RTS if 0.
    LDA   A0BA_PLAYER_GAME_STATE
    BPL   UI_UPDATE_STUFF ; If is positive, goto.
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Find something.
    JSR   CLEAR_ALL_SCREEN ; Clear the entire screen.
    LDA   #$7F
    STA   A0BA_PLAYER_GAME_STATE ; Store
    LDA   #$01
    STA   A08B_CURRENT_PLAYER ; Store
    STA   $A025
    CLR   A08C_CURRENT_PLAYER_COUNT ; Is 0.
    LDX   #$A1C2 ; Load ptr to player data?
CLEAR_DATA_LOOP: ; 0x000881, $D881
    CLR   X+ ; Clear
    CMPX  #$A23C ; End of player data?
    BNE   CLEAR_DATA_LOOP ; Loop
    LDX   #$C485 ; SRAM PTR, initial ships.
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get data
    ANDA  #$0F ; Get bottom bits just to make sure corruption isn't too rewarding.
    STA   R_A1C9_P1_SHIPS ; Store to P1 ships.
    LDB   #$0A ; Idk val.
    STD   R_A1CB_P1_SMARTBOMBS ; Ships and smartbomb count always same, B is IDK.
    CLR   $A039 ; Clear
    NOP ; NOP
    LDX   #$A1C2 ; Ptr to P1 data?
    JSR   END_WAVE_EXTRAS?
    LDX   #$C481 ; Get SRAM
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Get data in.
    STD   R_A0AB ; Store to, word.
    STD   R_A1C6 ; Store to, word.
    CLR   R_A1C8 ; Clear BYTE.
    LDX   #$A1C2 ; PTR to P1 data
LOOP_COPY_P1_DATA_TO_P2: ; 0x0008B2, $D8B2
    LDA   X+ ; Get data in player.
    STA   60,X ; Store to player 2. Off by 1 because of X+ above.
    CMPX  #$A1FF ; Compare to end P1 data.
    BNE   LOOP_COPY_P1_DATA_TO_P2
    LDX   #$D919 ; Ptr to bookkeep 7 below.
    LDA   #$00 ; Idk val
    JSR   GET_15B_OBJECT+SCHEDULE ; Do this.
UI_UPDATE_STUFF: ; 0x0008C4, $D8C4
    INC   A08C_CURRENT_PLAYER_COUNT ; Inc players in game.
    LDA   VAL_FROM_SRAM_C495-C496 ; Load A
    ADDA  #$99 ; Add 99...
    DAA ; Adjust...
    STA   VAL_FROM_SRAM_C495-C496 ; Store back.
    LDX   #$C47D ; Ptr
    JSR   STORE_A_TO_SRAM[X]_BANKED ; Put A here???
    LDA   A08C_CURRENT_PLAYER_COUNT ; Load players?
    DECA ; Dec
    BEQ   RTS ; If was 0 originally, RTS.
    JSR   DISPLAY_SETUP_INGAME ; Update display if not.
RTS: ; 0x0008DB, $D8DB
    RTS
SAVE_BANK+SET_WATCHDOG_NONFLIPPED: ; 0x0008DC, $D8DC
    PSHS  X,A ; Save
    LDA   CURRENT_BANK ; Get bank.
    PSHS  A ; Save
SET_WATCHDOG_NONFLIPPED: ; 0x0008E2, $D8E2
    LDX   #$DF17 ; IRQ handler.
    LDD   #$383C ; A=Watchdog, B=Ctrl (C2 SET HIGH, OUTPUT REG)
    BRA   SETUP_IRQ_RTN+WATCHDOG+WIDGET_B_CTRL+BANK@S
SET_WATCHDOG_GAMEPLAY?: ; 0x0008EA, $D8EA
    PSHS  X,A ; Save
    LDA   CURRENT_BANK ; Get bank.
    PSHS  A ; Save too.
    CLRA ; Zero
    JSR   BANKSWITCH_TO_A ; Switch to A
    LDA   PIA_WGT_DATA_B ; Get widget data.
    BPL   SET_WATCHDOG_NONFLIPPED ; If WGT_DATA_B7 not set, load P1 data.
    LDX   #$DFC3 ; IRQ handler.
    LDD   #$3934 ; A=Watchdog (Flipped screen) and CTRL (C2 SET LOW, OUTPUT REG)
SETUP_IRQ_RTN+WATCHDOG+WIDGET_B_CTRL+BANK@S: ; 0x0008FF, $D8FF
    STX   IRQ_CMD_LOC+1 ; Set up IRQ RTN.
    CLR   CURRENT_BANK ; Switch to bank 0
    CLR   BANKSWITCH ; Actually.
    STB   PIA_WGT_CTRL_B ; Store to widget ctrl.
    STA   WATCHDOG ; Store to watchdog.
    LDA   #$7E ; JMP command.
    STA   IRQ_CMD_LOC ; Store JMP.
    PULS  A ; Pull saved bank.
    STA   CURRENT_BANK ; Restore.
    STA   BANKSWITCH
    PULS  A,X,PC ; Restore regs+RTS
UPDATE_BOOKKEEP_7+GAME_START?: ; 0x000919, $D919
    LDB   #$07 ; Bookkeep to increase.
    JSR   GOTO_B3-C00F_BOOKKEEP_UPDATE_+1 ; ++ it
WAVE_INIT?: ; 0x00091E, $D91E
    JSR   GAME_OBJECTS_INIT ; Init wave?
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Sort them into two others.
    LDA   #$7F ; Store to
    STA   A0BA_PLAYER_GAME_STATE ; Status of some type?
    LDX   R_A063_CALLBACK_LIST_ADDR? ; Get list ptr from here.
    CMPX  LIST_?B_CALLBACKS? ; If X _ $A05F
    BNE   SKIP_X_MOVE ; !=, goto
    LDX   X ; Move to next obj.
    BEQ   DONT_SETUP_U ; If NULL, goto
SKIP_X_MOVE: ; 0x000932, $D932
    LDA   #$0F ; Countdown
    LDX   #$D93A ; Handler
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Leaves
    LDA   7F_TIMER_UNK ; Load val
    ORA   80_TIMER_UNK ; Combine
    ORA   7F_TIMER_UNK ; No function if ran from 93A?
    BNE   SKIP_X_MOVE ; If any set, goto. Always taken possibly?
DONT_SETUP_U: ; 0x000942, $D942
    JSR   LIST_INIT_A05F,A061,A063,A069 ; List init stuff.
    LDX   #$D950 ; Handler
    LDA   #$00 ; Countdown
    JSR   GET_15B_OBJECT+SCHEDULE ; Add to player?
    JMP   MAIN_WAIT_LOOP?
HANDLER_UNK: ; 0x000950, $D950
    CLRA
    JSR   BANKSWITCH_TO_A ; IO bank.
    LDA   PIA_WGT_DATA_B ; Get widget input
    BPL   BIT_7_NOT_SET ; If UP not pressed, go here?
    JSR   CLEAR_ALL_SCREEN ; Clear all screen otherwise? rofl.
    LDA   A08B_CURRENT_PLAYER ; Load val
    DECA ; --
    BNE   VAL_NOT_0 ; !=0, goto.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED
    BRA   SKIP_WATCHDOG_OTHER
VAL_NOT_0: ; 0x000966, $D966
    BSR   SET_WATCHDOG_GAMEPLAY?
SKIP_WATCHDOG_OTHER: ; 0x000968, $D968
    LDA   #$FF ; Set all buttons to on.
    STA   WGT_DATA_A_RAM_COPY
    STA   WGT_DATA_A_RAM_COPY_OLD
BIT_7_NOT_SET: ; 0x00096E, $D96E
    CLRA ; Clear D
    CLRB
    STD   R_A020_SCREEN_POS_CHANGE? ; Clear
    STD   R_A022_UNK ; Clear
    JSR   BANKSWITCH_TO_7 ; Bank 7
    JSR   JMP_TO_GENERATE_LAND_DATA? ; Prep for...?
    JSR   JMP_TO_DRAW_LAND? ; Unsure.
    JSR   CLEAR_GAME_SCREEN ; Clear the screen.
    LDD   #$0300 ; Idk why val
    STD   $A0BD ; To
    STD   $A0BB ; To
    CLR   $A0AD ; Clear
    CLR   A0B5_LASER_COUNT?
    CLR   R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT?
    CLR   $A0AF
    CLR   $A09A
    CLR   ENEMY_UNK_SPAWNED?BULLET? ; These
    LDX   #$A11A ; Idk why val
    STX   $A09B
    JSR   GET_PLAYER_PTR_IN_X_FROM_A08B
    STX   A08D_CURRENT_PLAYER_PTR?
    LDA   8,X ; Get PLAYER[8]
    ANDA  #$07 ; Get bits
    LDU   #$DB53 ; PTR
    LDA   A,U ; Load from ptr
    STA   COLOR_PALETTE_RAM_COPY+5 ; Store to.
    DEC   7,X ; Dec PLAYER[7]
    JSR   DISPLAY_SETUP_INGAME ; Show display.
    LDD   #$2080 ; Unsure val
    STD   $A0C1
    STD   SHIP_SCR_POS_XXYY
    LDD   #$2000 ; Unsure val
    STD   $A0C3
    LDD   #$0800 ; Unsure val.
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add?
    STD   $A0CC ; Store to
    LDD   #$8000 ; VPOS?
    STD   PLAYER.VPOS ; Store to
    CLRA ; Clear with A/B/D now.
    CLRB
    STD   $A0C7
    STA   $A0C9
    STD   PLAYER_V_MOMENTUM
    LDX   #$E9E3 ; Callback
    LDA   #$00 ; Timer
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$E782 ; Callback rotate colors.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$F493 ; Callback idk
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$E9BF ; Callback idk manipulate pools?
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$F464 ; Callback rotate colors.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$F43D ; Callback rotate colors.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDA   $A025
    BEQ   CLEAR_GAME_SCREEN+MORE ; If == 0, goto.
    LDB   A08C_CURRENT_PLAYER_COUNT ; Load count.
    DECB
    BEQ   CLEAR_GAME_SCREEN+MORE ; If 1, goto.
    LDU   #$C0EF ; SENTENCE PTR PLAYER ONE
    LDA   A08B_CURRENT_PLAYER ; Load val
    DECA ; Dec
    BEQ   DONT_MOVE_U ; If was 1, don't move.
    LDU   #$C0F1 ; SENTENCE PTR PLAYER ONE
DONT_MOVE_U: ; 0x000A11, $DA11
    LDX   #$3C80 ; Pos?
    JSR   PSH_ALL_GOTO_B2-C002 ; Print
    LDA   #$80 ; Countdown
    LDX   #$DA1F ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup task it seems. Needs more digging.
CLEAR_GAME_SCREEN+MORE: ; 0x000A1F, $DA1F
    JSR   CLEAR_GAME_SCREEN ; Clear the game screen.
    LDB   #$05 ; Not sure val
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player data pointer
    LDA   10,X ; Load PLAYER[10]
    BSR   OR_B_WITH_2_IF_NOT_ZERO ; Manip B possibly.
    LDA   #$60 ; Timer?
    LDX   #$DA32 ; Callback?
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; I need to figure this out more apparently
CALLBACK_MAIN?: ; 0x000A32, $DA32
    JSR   L_000C1E
    BSR   A_FROM_A0FA,B_CLEARED_OR_2
    CLR   $A025 ; Clear
    JMP   IDK_BUT_CAN_END_WAVE
A_FROM_A0FA,B_CLEARED_OR_2: ; 0x000A3C, $DA3C
    CLRB
OR_AND_STORE_B_NO_HUMANOIDS?: ; 0x000A3D, $DA3D
    LDA   A0FA_HUMANOID_COUNT?
OR_B_WITH_2_IF_NOT_ZERO: ; 0x000A3F, $DA3F
    BNE   SKIP_OR_B
    ORB   #$02 ; Set bit.
SKIP_OR_B: ; 0x000A43, $DA43
    STB   A0BA_PLAYER_GAME_STATE ; Store B
    RTS
L_000A46: ; 0x000A46, $DA46
    LDB   #$58 ; State?
    BSR   OR_AND_STORE_B_NO_HUMANOIDS? ; Or state?
    LDD   R_A020_SCREEN_POS_CHANGE? ; Move
    STD   R_A022_UNK
    LDX   SHIP_SCR_POS_XXYY ; Pos from
    LDD   #$0806 ; Size
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear
    JSR   SAVE_STATE_TO_PLAYER ; Save state to player
    LDD   #$D4B5
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Unsure
    LDY   #$F9C1 ; PTR to BITMAP/BMP
    LDA   $A0BB ; Load val
    BPL   L_000A6B ; If positive, skip ptr change.
    LDY   #$F9CB ; Pos 2 to BMP
L_000A6B: ; 0x000A6B, $DA6B
    LDX   #$DB4B ; Callback unk
    STX   7,U ; Store to OBJ[7]
    LDU   #$AFDD ; Unsure val
    JSR   GFX?_IDK_NIBBLES_#$B_IDK_RESTORE ; Not exactly sure.
    TFR   U>X ; OBJ U to X
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Obj U from var
    STX   11,U ; X to OBJ[11]
    LDD   $A0C1 ; Pos
    LDY   11,U ; BMP ptr, OBJ[11]
    JSR   GFX_BANK2_CHR_CLEAR ; Clear off screen.
    LDA   #$02 ; Countdown
    LDX   #$DA8C ; Handler
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_HANDLER_UNK: ; 0x000A8C, $DA8C
    LDD   $A0C1 ; Pos
    LDY   11,U ; BMP ptr
    JSR   GFX_BANK2_CHR_TO_SCREEN ; To screen
    LDX   7,U ; X from OBJ[7]
    LDA   X+ ; A from X++
    BEQ   LOADED_PTR_ZERO ; If zero, goto.
    STA   COLOR_PALETTE_RAM_COPY+11 ; Store val to palette.
    CLR   COLOR_PALETTE_RAM_COPY ; Clear black
    STX   7,U ; X back to OBJ[7]
    LDA   #$02 ; Countdown
    LDX   #$DA7C ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup callback.
LOADED_PTR_ZERO: ; 0x000AA8, $DAA8
    LDA   #$7F
    STA   A0BA_PLAYER_GAME_STATE ; State to...
    LDA   #$FF ; White
    STA   COLOR_PALETTE_RAM_COPY ; To palette[0]
    LDA   #$02 ; Countdown
    LDX   #$DAB8 ; Handler
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_HANDLER_UNK: ; 0x000AB8, $DAB8
    CLR   COLOR_PALETTE_RAM_COPY ; Color back to 0
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Do IDK
    LDX   $A0C1 ; X from
    LEAX  1027,X ; +IDK
    JSR   BANKSWITCH_TO_7 ; To 7
    JSR   JMP_TO_UNK_RTN ; Idk
    JSR   CURRENT_PLAYER_SCORE_TO_SCREEN ; Score to screen.
    CLR   $A0B3 ; Clear idk
    LDB   #$13 ; Sound?
    JSR   WRITE_ROM_PIA_DATA_REGS_W/_#$3F_AND_B_SOUND?
    JSR   ENEMY_COUNTS_RETURN? ; Load enemy counts.
    BNE   WAVE_NOT_OVER
    JSR   END_OF_WAVE ; End wave
    JSR   CLEAR_GAME_SCREEN ; Clear screen.
WAVE_NOT_OVER: ; 0x000ADE, $DADE
    LDA   A08B_CURRENT_PLAYER ; Load current player
    LDX   A08D_CURRENT_PLAYER_PTR? ; Load player ptr
    LDB   7,X ; Load PLAYER[7]
    BNE   PLAYER_GAME_NOT_OVER ; If not 0, goto.
    LDB   A08C_CURRENT_PLAYER_COUNT ; Load B with same?
    DECB ; DEC
    BEQ   A08C_CURRENT_PLAYER_1 ; If was 1
    EORA  #$03 ; Invert player val in A
    JSR   DECIDE_PLAYER_PTR_FROM_A ; Get PTR from A
    LDB   7,X ; Load PLAYER[7] of other
    BEQ   A08C_CURRENT_PLAYER_1 ; If 0, goto.
    LDU   #$C0EF ; PTR to SENTENCE PLAYER ONE
    CMPA  #$02 ; If is 2
    BEQ   SKIP_LOAD_PLAYER_TWO
    LDU   #$C0F1 ; PTR to SENTENCE PLAYER TWO
SKIP_LOAD_PLAYER_TWO: ; 0x000AFE, $DAFE
    LDX   #$3C78 ; Pos
    JSR   PSH_ALL_GOTO_B2-C002 ; To screen.
    LDU   #$C075 ; PTR to SENTENCE GAME OVER
    LDX   #$3E88 ; POS
    JSR   PSH_ALL_GOTO_B2-C002 ; To screen.
    LDA   #$60 ; Timer
    LDX   #$DB15 ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup.
PLAYER_GAME_NOT_OVER: ; 0x000B15, $DB15
    LDA   A08B_CURRENT_PLAYER ; Current
LOOP_PLAYER_PTR: ; 0x000B17, $DB17
    INCA ; INC
    CMPA  A08C_CURRENT_PLAYER_COUNT ; Compare?
    BLS   DONT_LOAD_ONE ; <=, goto...?
    LDA   #$01
DONT_LOAD_ONE: ; 0x000B1E, $DB1E
    JSR   DECIDE_PLAYER_PTR_FROM_A ; Get ptr
    LDB   7,X ; Load PLAYER[7]
    BEQ   LOOP_PLAYER_PTR ; If 0, goto.
    STA   A08B_CURRENT_PLAYER ; Store A to current
    INC   $A025 ; Inc IDK
    JMP   UPDATE_BOOKKEEP_7+GAME_START? ; Bookkeep, never returns.
A08C_CURRENT_PLAYER_1: ; 0x000B2C, $DB2C
    LDU   #$C075 ; PTR to SENTENCE GAME OVER
    LDX   #$3E80 ; POS
    LDA   #$FF ; State
    STA   A0BA_PLAYER_GAME_STATE ; Update
    JSR   PSH_ALL_GOTO_B2-C002 ; To screen.
    CLR   $A0B3 ; Clear
    LDB   #$13 ; No sound?
    JSR   WRITE_ROM_PIA_DATA_REGS_W/_#$3F_AND_B_SOUND? ; To
    LDA   #$28 ; Timer
    LDX   #$DB48 ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
CALLBACK_GAME_OVER_UNK_REASON: ; 0x000B48, $DB48
    JMP   GOTO_B1_C000
CALLBACK_UNK: ; 0x000B4B, $DB4B
    ASR   R_A007_IRQ_STACK_VAL_2
    ASR   COUNTDOWN_A00F
    SWI1 ; Interrupt
    CLR   BANKSWITCH
DATA_UNK: ; 0x000B53, $DB53
    .db $00 ; NEG [DP]
    .db $81 ; CMPA [IMM]
    .db $28 ; BVC
    .db $07 ; ASR [DP]
    .db $16 ; LBRA
    .db $2F ; BLE
    .db $84 ; AND [IMM]
    .db $15 ; ILL
    .db $00 ; NEG [DP]
GFX?_IDK_NIBBLES_#$B_IDK_RESTORE: ; 0x000B5C, $DB5C
    PSHS  U,X,B,A ; Save
L_000B5E: ; 0x000B5E, $DB5E
    JSR   BANKSWITCH_TO_2 ; Bank 2
    LDD   Y ; Load from Y
    STD   U ; Store to U
    MUL ; MUL
    LEAX  10,U ; X=U[10]
    STX   2,U ; X to UOBJ[2]
    LEAX  D,X ; X+=D
    STX   4,U ; Store X to OBJ[4]
    PSHS  X ; Save X
    LEAX  D,X ; X += D
    PSHS  X ; Save X
    LDD   6,Y ; U[6] = Y[6]
    STD   6,U
    LDD   8,Y ; U[8] = Y[8]
    STD   8,U
    LDX   2,Y ; Load YOBJ[2]
    LEAU  10,U ; U+=10
    BSR   @X_TO_@U,SET_NIBBLES_NOT_0_TO_#$B,END_AT_S+4 ; Do, needs more looking at.
    LDX   4,Y ; X from YOBJ[4]
    LDU   2,S ; U from S+2
    LDD   S ; S[0] to S[2]
    STD   2,S
    BSR   @X_TO_@U,SET_NIBBLES_NOT_0_TO_#$B,END_AT_S+4 ; Do again.
    LEAS  4,S ; Fix up stack.
    PULS  A,B,X,U,PC
@X_TO_@U,SET_NIBBLES_NOT_0_TO_#$B,END_AT_S+4: ; 0x000B90, $DB90
    LDD   X++ ; D from X.
    BITA  #$F0 ; Test upper nibble
    BEQ   SKIP_O_A:UN ; None set, goto.
    ORA   #$F0 ; Set nibble
SKIP_O_A:UN: ; 0x000B98, $DB98
    BITA  #$0F ; Test lower nibble
    BEQ   SKIP_OR_A_LN ; None set, goto.
    ORA   #$0F ; Set nibble
SKIP_OR_A_LN: ; 0x000B9E, $DB9E
    BITB  #$F0 ; Test upper nibble
    BEQ   SKIP_OR_B:UN ; None set, goto.
    ORB   #$F0 ; Set nibble
SKIP_OR_B:UN: ; 0x000BA4, $DBA4
    BITB  #$0F ; Test lower nibble
    BEQ   SKIP_OR_B:LN ; None set, goto.
    ORB   #$0F ; Set bottom bits.
SKIP_OR_B:LN: ; 0x000BAA, $DBAA
    ANDA  #$BB ; Set all nibbles not 0 with #$BB
    ANDB  #$BB
    STD   U++ ; Store to U
    CMPU  4,S ; Compare to S+4 bytes.
    BLO   @X_TO_@U,SET_NIBBLES_NOT_0_TO_#$B,END_AT_S+4 ; Loop
    RTS
SAVE_STATE_TO_PLAYER: ; 0x000BB6, $DBB6
    PSHS  U,X,B,A ; Save
    LDU   A08D_CURRENT_PLAYER_PTR? ; Get player ptr
    LEAU  10,U ; +=10
    LDA   #$33 ; Load val
LOOP_CLEAR_51_BYTES: ; 0x000BBE, $DBBE
    CLR   U+
    DECA ; Clear player ptr +
    BNE   LOOP_CLEAR_51_BYTES
    LDU   A08D_CURRENT_PLAYER_PTR? ; Get player ptr again
    LDA   A0FA_HUMANOID_COUNT? ; Load val
    STA   10,U ; Store to PLAYER[10]
    LEAU  11,U ; +=11
    LDX   #$A0FB ; Ptr
LOOP_MOVE_RAM_TO_PLAYER: ; 0x000BCE, $DBCE
    LDA   X+ ; Load data from
    CMPX  #$A100 ; Compare to
    BHI   DONT_ADD_WITH_22_IN
    ADDA  22,X ; Add with value 22 in, 5 bytes do this.
DONT_ADD_WITH_22_IN: ; 0x000BD8, $DBD8
    STA   U+ ; Store to player ptr.
    CMPX  #$A112 ; A111 is end
    BNE   LOOP_MOVE_RAM_TO_PLAYER
    PULS  A,B,X,U,PC ; RTS
FILL_OUT_HUMANOID?: ; 0x000BE1, $DBE1
    PSHS  B,A ; Save
    STA   A073_SCRATCH_LOOP_WORD?+1 ; Store to...
LOOP_FILL_OUT: ; 0x000BE5, $DBE5
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Fill out obj with data.
    .db $F9
    .db $01
    .db $ED
    .db $70
    .db $66
    .db $66
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random? Not used?
    LDD   A0E0_RAND_WORD ; Load random word.
    ANDA  #$1F ; Get bits.
    ADDA  1,S ; Add with +1 on stack.
    STD   10,X ; Store to OBJ[10]
    LSRB ; Shift B
    BHS   SHIFTED_OFF_ZERO ; If shifted off 0, goto.
    LDD   #$F915 ; Humanoid bitmap.
    STD   2,X ; Store to obj.
SHIFTED_OFF_ZERO: ; 0x000C01, $DC01
    LDA   #$E0 ; Move to OBJ[12]
    STA   12,X
    LDA   #$10 ; Move to OBJ[20]
    STA   20,X
    CLRA ; Clear D
    CLRB
    STD   16,X ; Clear OBJ[16],OBJ[17]
    STD   14,X ; OBJ[14],OBJ[15]
    STD   6,X ; OBJ[6],OBJ[7]
    STX   LIST_$65_ON_SCREEN? ; Store to list?
    STX   Y++ ; Store to Y? Idk what Y is.
    DEC   A073_SCRATCH_LOOP_WORD?+1 ; Dec val.
    BNE   LOOP_FILL_OUT
    PULS  A,B,PC ; RTS
    INC   A08D_CURRENT_PLAYER_PTR?+1
    LDD   -31232,U
    JSR   GET_15B_OBJECT+SCHEDULE
    LDU   #$A11A ; Idk why val
    LEAY  U ; To Y
    STU   7,X ; Store to OBJ[7]
LOOP_CLEAR_A11A-A141: ; 0x000C2D, $DC2D
    CLR   U+
    CMPU  #$A142
    BNE   LOOP_CLEAR_A11A-A141
    LDU   A08D_CURRENT_PLAYER_PTR?
    LDA   10,U ; PLAYER[10] is humanoid count.
    STA   A0FA_HUMANOID_COUNT? ; Store to.
    BEQ   NO_HUMANOIDS ; If 0, no humanoids.
    CMPA  #$07 ; If _ 7
    BLS   HUMANOIDS_COUNT_<=7? ; <=, goto.
    LSRA ; Shift val twice.
    LSRA
    CLRB ; Clear
NOT_ZERO_HUMANOID: ; 0x000C44, $DC44
    BSR   FILL_OUT_HUMANOID?
    ADDB  #$40 ; 4 loops.
    BNE   NOT_ZERO_HUMANOID
    ASLA ; Shift left
    ASLA ;  2x
    NEGA ; Invert
    ADDA  10,U ; Add count?
    BEQ   NO_HUMANOIDS ; If 0, goto.
HUMANOIDS_COUNT_<=7?: ; 0x000C51, $DC51
    STA   A073_SCRATCH_LOOP_WORD? ; Store count <= 7 here?
LOOP_MORE_HUMANOIDS: ; 0x000C53, $DC53
    LDB   A0E0_RAND_WORD ; Load B. TODO: Used for STD 10,X below?
    LDA   #$01 ; Idk val
    BSR   FILL_OUT_HUMANOID?
    DEC   A073_SCRATCH_LOOP_WORD? ; Dec counter
    BNE   LOOP_MORE_HUMANOIDS
NO_HUMANOIDS: ; 0x000C5D, $DC5D
    LDU   A08D_CURRENT_PLAYER_PTR? ; Load player ptr
    LEAU  11,U ; PLAYER[11]
    LDX   #$A0FB ; Ptr to game RAM.
LOOP_PLAYER_TO_GAME_STATE: ; 0x000C64, $DC64
    LDA   U+ ; Load from player
    STA   X+ ; Store to game state.
    CMPX  #$A112 ; End
    BNE   LOOP_PLAYER_TO_GAME_STATE
    LDX   #$A112 ; Useless if ran from above. TODO: Only ran from there?
CLEAR_A112-A11A: ; 0x000C70, $DC70
    CLR   X+
    CMPX  #$A11A
    BNE   CLEAR_A112-A11A
LOOP_$67_TO_$65: ; 0x000C77, $DC77
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get obj
    LDA   A0DF_RAND_BYTE ; Get random.
    LSRA ; Shift
    ADDA  #$2A ; Add
    STA   12,X ; Store to OBJ[12]
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random.
    ANDA  #$3F ; Get bits.
    ADDA  #$80 ; Set top.
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add with this.
    STD   10,X ; Store to OBJ[10]
    LDA   $A0FF ; Load val
    BEQ   UN_RTN_IDK ; If 0, goto.
    CMPA  #$06 ; IF A _ 6
    BLS   DONT_CAP_TO_6 ; <=, goto.
    LDA   #$06 ; Cap at 6
DONT_CAP_TO_6: ; 0x000C96, $DC96
    LEAY  X ; X to Y
    JSR   UNK_MAKE_OBJ_DETAILS_FROM_OBJ@Y? ; Make other obj?
    LDX   LIST_23B_UNUSED_OBJS? ; Get list ptr
    STX   Y ; Store to Y.next
    STY   LIST_23B_UNUSED_OBJS? ; Makes Y new head?
    NEGA ; Invert original A
    ADDA  $A0FF ; Add with val
    STA   $A0FF ; Store back
    BNE   LOOP_$67_TO_$65 ; If not 0, continue.
UN_RTN_IDK: ; 0x000CA9, $DCA9
    LDA   R_A0FE_ENEMY_IDK_COUNT ; Load val
    BEQ   NO_ENEMIES_1 ; If 0, skip.
    JSR   L_001F15
    CLR   R_A0FE_ENEMY_IDK_COUNT
NO_ENEMIES_1: ; 0x000CB2, $DCB2
    LDA   $A0FD
    STA   R_A114_ENEMY_IDK_COUNT
    BEQ   NO_ENEMIES_2
    CLR   $A0FD
    JSR   L_001B36
NO_ENEMIES_2: ; 0x000CBE, $DCBE
    LDA   $A0FC
    STA   R_A113_ENEMY_IDK_COUNT
    BEQ   RTS ; If 0, RTS
L_000CC5: ; 0x000CC5, $DCC5
    CMPA  #$03
    BLS   CAP_AT_3
    LDA   #$03
CAP_AT_3: ; 0x000CCB, $DCCB
    PSHS  A
    JSR   L_00229D
    LDA   $A0FC
    SUBA  S+
    STA   $A0FC
    BNE   L_000CC5
RTS: ; 0x000CD8, $DCD8
    RTS
IDK_BUT_CAN_END_WAVE: ; 0x000CD9, $DCD9
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load list here.
    LDA   #$28 ; Load val
    STA   7,U ; OBJ[7]
    LDA   R_A10F ; Move
    STA   R_A118
    LDA   #$01 ; Val?
    STA   R_A117 ; Set
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BITA  #$08 ; Test bit.
    BNE   SKIP_SUB_COUNT_IDK ; If set, goto.
    JSR   ENEMY_COUNTS_RETURN?
    BNE   WAVE_CONTINUE? ; If A not 0, goto. Enemies number?
    LDA   #$77 ; Move
    STA   A0BA_PLAYER_GAME_STATE
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2
    JSR   SAVE_STATE_TO_PLAYER
    JSR   END_OF_WAVE
    LDX   A08D_CURRENT_PLAYER_PTR?
    INC   7,X ; PLAYER[7], wave?
    JMP   WAVE_INIT? ; Next wave.
WAVE_CONTINUE?: ; 0x000D09, $DD09
    CMPA  #$08 ; 8 enemies left?
    BHI   MORE_THAN_8_ENEMIES ; >, goto
    LDB   R_A10F ; Load val
    LSRB ; Shift
    CMPA  #$03 ; Compare to 3
    BHI   DONT_DIVIDE_AGAIN ; >, goto
    LSRB ; Shift again
DONT_DIVIDE_AGAIN: ; 0x000D16, $DD16
    INCB ; INC
    CMPB  R_A118 ; Compare to val
    BHS   MORE_THAN_8_ENEMIES ; If B > Val, don't store.
    STB   R_A118 ; Store if lower
MORE_THAN_8_ENEMIES: ; 0x000D1F, $DD1F
    DEC   R_A118 ; Just dec counter.
    BNE   DONT_SPAWN_BAITER? ; If not 0, goto.
    CMPA  #$04 ; If A _ #$04
    LDA   R_A10F ; Replace A
    BHS   COMPARE_WAS_>=_4 ; A compared was higher
    LSRA ; /4 otherwise.
    LSRA
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get new val.
COMPARE_WAS_>=_4: ; 0x000D30, $DD30
    STA   R_A118 ; Store to.
    LDA   R_A119_BAITER_COUNT? ; Load val
    CMPA  #$0C ; If _ #$0C
    BHS   DONT_SPAWN_BAITER? ; >=, goto
    JSR   MAKE_BAITER_RTN? ; Do IDC
    INC   R_A119_BAITER_COUNT? ; INC
DONT_SPAWN_BAITER?: ; 0x000D40, $DD40
    DEC   R_A117 ; Dec counter
    BEQ   L_000D4A ; If 0, goto.
    LDA   R_A112_ENEMY_IDK_COUNT ; Load count.
    BNE   SKIP_SUB_COUNT_IDK ; If enemy exists, go here.
L_000D4A: ; 0x000D4A, $DD4A
    LDA   R_A100 ; Move
    STA   R_A117
    LDA   R_A0FB_ENEMY_IDK_COUNT ; Load count
    BEQ   SKIP_SUB_COUNT_IDK ; ==0, goto.
    LDA   R_A112_ENEMY_IDK_COUNT ; Load count
    CMPA  #$08
    BHS   SKIP_SUB_COUNT_IDK ; >=, goto.
    LDA   R_A101 ; Load val
    CMPA  R_A0FB_ENEMY_IDK_COUNT ; If val _ count
    BLS   L_000D64 ; <=, goto.
    LDA   R_A0FB_ENEMY_IDK_COUNT ; Load count
L_000D64: ; 0x000D64, $DD64
    JSR   IDK_BUT_HUMANOIDS_MATTER ; Do
    NEGA ; Negate count we passed
    ADDA  R_A0FB_ENEMY_IDK_COUNT ; Add to, aka sub.
    STA   R_A0FB_ENEMY_IDK_COUNT ; Store
SKIP_SUB_COUNT_IDK: ; 0x000D6C, $DD6C
    LDA   $A0AE ; Load val
    CMPA  #$10 ; If _ #$10
    BHS   DONT_INC_A0AE ; >=, DONT INC
    INC   $A0AE ; Inc IDK
DONT_INC_A0AE: ; 0x000D74, $DD74
    LDA   A024_TIME_PLAYED? ; Load val
    INCA ; Inc
    CMPA  #$F0 ; If _ #$F0
    BLS   SKIP_BOOKKEEP
    LDB   #$06 ; Bookkeep entry
    JSR   GOTO_B3-C00F_BOOKKEEP_UPDATE_+1 ; ++
    CLRA ; Clear
SKIP_BOOKKEEP: ; 0x000D81, $DD81
    STA   A024_TIME_PLAYED? ; Store/clear.
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load OBJ
    DEC   7,U ; DEC OBJ[7]
    BNE   NOT_AT_ZERO
    LDB   #$02 ; Index into difficulty data to modify.
    LDY   #$A0FB ; Ptr to player data
    JSR   PLAYER_DATA_DIFFICULTY_MANIPULATION ; Manip player data
    LDA   #$28 ; Timer
    STA   7,U ; Store back.
NOT_AT_ZERO: ; 0x000D96, $DD96
    LDA   #$0F ; Timer
    LDX   #$DCEA ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup.
GET_NEW_A_THAT_IS_<=_CURRENT: ; 0x000D9E, $DD9E
    PSHS  A ; Save A
    JSR   RANDOM_VALUE_FWD+IN_A ; Random value
LOOP_UNTIL_NEW_IS_LOWER: ; 0x000DA3, $DDA3
    CMPA  S ; Compare with pushed
    BLS   NEW_IS_<=_STACK
    LSRA ; Shift
    BRA   LOOP_UNTIL_NEW_IS_LOWER
NEW_IS_<=_STACK: ; 0x000DAA, $DDAA
    INCA ; ++ when done.
    LEAS  1,S ; Clean up stack, no pull.
    RTS ; Leave
ENEMY_COUNTS_RETURN?: ; 0x000DAE, $DDAE
    LDA   R_A112_ENEMY_IDK_COUNT
    ADDA  R_A0FB_ENEMY_IDK_COUNT
    ADDA  R_A113_ENEMY_IDK_COUNT
    ADDA  R_A114_ENEMY_IDK_COUNT
    ADDA  R_A116_ENEMY_IDK_COUNT
    ADDA  R_A115_ENEMY_IDK_COUNT
    ADDA  R_A0FE_ENEMY_IDK_COUNT
    RTS ; RTS
DECIMAL_BACK_TO_HEX_A: ; 0x000DC2, $DDC2
    PSHS  B ; Save B
    CLRB ; Clear
LOOP_A_SUB: ; 0x000DC5, $DDC5
    CMPA  #$10 ; If A _ #$10
    BLO   A_<_#$10 ; <, goto.
    ADDB  #$0A ; B+=#$0A for every A >= #$10
    SUBA  #$10 ; A -= #$10
    BRA   LOOP_A_SUB ; Loop again
A_<_#$10: ; 0x000DCF, $DDCF
    PSHS  B ; B to stack
    ADDA  S+ ; Add A to B, clean up B push.
    PULS  B,PC ; Restore, RTS.
BYTE_TO_DISP?: ; 0x000DD5, $DDD5
    PSHS  B ; Save B
    TFR   A>B ; A to B
    CLRA ; Clear
LOOP_HIGHER_THAN_0x09: ; 0x000DDA, $DDDA
    CMPB  #$0A
    BLO   NO_FIXING_NEEDED
    ADDA  #$10 ; Add high digit to A
    DAA ; Adjust
    SUBB  #$0A ; Subtract value added decimally.
    BRA   LOOP_HIGHER_THAN_0x09
NO_FIXING_NEEDED: ; 0x000DE5, $DDE5
    PSHS  B ; Push to stack
    ADDA  S+ ; Add low digit to A
    DAA ; Adjust again. TODO: Find 99->00 factor.
    PULS  B,PC
END_OF_WAVE: ; 0x000DEC, $DDEC
    CLR   COLOR_PALETTE_RAM_COPY ; Clear
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load ptr to list.
    PULS  X ; X from stack.
    STX   13,U ; Store to [A063]+13
    JSR   CLEAR_GAME_SCREEN ; Clear game screen.
    LDU   #$C0F9 ; Attack wave
    LDX   #$3850 ; POS
    JSR   PSH_ALL_GOTO_B2-C002 ; To screen.
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player pointer
    LDA   8,X ; Get wave
    BSR   BYTE_TO_DISP?
    TFR   A>B ; To B
    CLRA ; Clear A
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Get location.
    JSR   JMP_TO_VAL_IN_AB_TO_SCREEN
    LDX   #$3D60 ; Pos
    LDU   #$C0FB ; PTR TO SENTENCE COMPLETED
    JSR   PSH_ALL_GOTO_B2-C002
    LDU   #$C0F3 ; PTR TO SENTENCE BONUS X
    LDX   #$3C90 ; Pos
    JSR   PSH_ALL_GOTO_B2-C002 ; To screen.
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player ptr.
    CLRB ; Clear
    LDA   8,X ; Get wave
    CMPA  #$05 ; Compare to 5
    BLS   CAP_BONUS_AT_500 ; If <= 5, use.
    LDA   #$05 ; Cap at 5.
CAP_BONUS_AT_500: ; 0x000E2B, $DE2B
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Get pos.
    JSR   JMP_TO_VAL_IN_AB_TO_SCREEN ; Put to screen.
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load ptr
    LDX   #$3CA0 ; Pos
    LDA   A0FA_HUMANOID_COUNT? ; Load val
    STA   9,U ; Store to list entry?
    BEQ   NO_MORE_HUMANOIDS_TO_DISPLAY ; If 0, goto.
HUMANOID_DISPLAY_LOOP: ; 0x000E3B, $DE3B
    TFR   X>D ; Pos to actual.
    LDY   #$F915 ; Ptr to bmp, humanoid.
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Put to screen.
    LEAX  1024,X ; space 4 pixels.
    LDA   #$01 ; Score add flag, multiply.
    LDY   A08D_CURRENT_PLAYER_PTR? ; Load ptr to player
    LDB   8,Y ; Load wave
    CMPB  #$05
    BLO   DONT_CAP_WAVE_BONUS
    LDB   #$05
DONT_CAP_WAVE_BONUS: ; 0x000E55, $DE55
    ASLB ; Shift to upper nibble.
    ASLB
    ASLB
    ASLB
    JSR   SCORE_ADD_AB ; Add to score
    STX   7,U ; Screen pos to player data.
    LDA   #$04 ; Callback timer.
    LDX   #$DE66 ; Callback area.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Set task.
CALLBACK_WAVE_END_HUMANOIDS: ; 0x000E66, $DE66
    LDX   7,U ; Get screen pos.
    DEC   9,U ; Dec humanoid counter.
    BNE   HUMANOID_DISPLAY_LOOP
NO_MORE_HUMANOIDS_TO_DISPLAY: ; 0x000E6C, $DE6C
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get ptr.
    JSR   END_WAVE_EXTRAS?
    LDA   #$80 ; Timer for callback.
    LDX   #$DE79 ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Set task.
CALLBACK_WAVE_END_WAIT: ; 0x000E79, $DE79
    JMP   [13,U] ; Jumps to RTN in 13,U
END_WAVE_EXTRAS?: ; 0x000E7C, $DE7C
    PSHS  U,X,B,A ; Save
    INC   8,X ; PLAYER[8], wave?
    LDX   #$C49D ; Sram ptr
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get data from.
    STA   A073_SCRATCH_LOOP_WORD? ; Store to.
    LDX   2,S ; Restore player ptr
    TSTA ; Test SRAM loaded.
    BEQ   BANK_7_STUFF? ; If we loaded 0, go here.
    LDA   8,X ; Load wave
TEST_RESET_HUMANOIDS: ; 0x000E8F, $DE8F
    SUBA  A073_SCRATCH_LOOP_WORD? ; Sub with sram val
    BLO   BANK_7_STUFF? ; If we went negative, not modulo even.
    BNE   TEST_RESET_HUMANOIDS ; If it's not 0, try again.
    LDA   #$0A ; Store
    STA   10,X ; PLAYER[10], humanoid count?
BANK_7_STUFF?: ; 0x000E99, $DE99
    JSR   BANKSWITCH_TO_7 ; Goto bank.
    LDA   8,X ; PLAYER[8], wave
    PSHS  A ; Save
    CMPA  #$04 ; Compare to 4
    BLS   DONT_CAP_AT_4
    LDA   #$04 ; Cap
DONT_CAP_AT_4: ; 0x000EA6, $DEA6
    LDU   DIFFICULTY_DATA_START_LOC ; Load PTR from bank 7.
    ADDA  #$03 ; A+=3
    LEAX  11,X ; PLAYER[11] base
LOOP_MOVE: ; 0x000EAD, $DEAD
    LDB   A,U ; Get B from U[A]
    STB   X+ ; Store to X[11]+,
    LEAU  8,U ; U+=8
    CMPU  DIFFICULTY_DATA_END_LOC ; See if at end. 23 bytes
    BNE   LOOP_MOVE ; Loop if not there.
    PULS  A ; Restore A, wave raw
    SUBA  #$04 ; A-=4
    BHS   STILL_POSITIVE
    CLRA ; Clear if went negative.
STILL_POSITIVE: ; 0x000EC0, $DEC0
    STA   A073_SCRATCH_LOOP_WORD? ; Store to.
    LDX   #$C497 ; SRAM PTR
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Get word
    JSR   DECIMAL_BACK_TO_HEX_A ; Back to
    ADDA  A073_SCRATCH_LOOP_WORD? ; Add with wave.
    STA   A073_SCRATCH_LOOP_WORD? ; Store to.
    BEQ   RTS ; If == 0, leave.
    TFR   B>A ; Put B to A.
    JSR   DECIMAL_BACK_TO_HEX_A ; Do rtn on B
    CMPA  A073_SCRATCH_LOOP_WORD? ; If A _ Other
    BHS   SKIP_COMMIT ; >=, skip.
    STA   A073_SCRATCH_LOOP_WORD? ; Commit lower
SKIP_COMMIT: ; 0x000EDC, $DEDC
    LDA   A073_SCRATCH_LOOP_WORD? ; Load lowest
LOOP_MORE_A: ; 0x000EDE, $DEDE
    LDB   #$03 ; Ptr add
    JSR   GET_PLAYER_PTR_IN_X_FROM_A08B ; Get player X ptr
    LEAY  11,X ; Y = PLAYER[11]
    BSR   PLAYER_DATA_DIFFICULTY_MANIPULATION ; Player data manipulation, unk function.
    DECA ; A--
    BNE   LOOP_MORE_A ; Do more.
RTS: ; 0x000EEA, $DEEA
    PULS  A,B,X,U,PC ; RTS
PLAYER_DATA_DIFFICULTY_MANIPULATION: ; 0x000EEC, $DEEC
    PSHS  Y,X,A ; Save
    JSR   BANKSWITCH_TO_7 ; Bank 7
    LDX   DIFFICULTY_DATA_START_LOC ; Get difficult pointer
LOOP_X_PTR: ; 0x000EF4, $DEF4
    LDA   B,X ; Get data at PTR+B
    BMI   DATA_MINUS ; If negative, goto.
    ADDA  Y ; Add positive
    BLO   DONT_COMMIT_TO_PLAYER ; If overflow, taken.
    CMPA  X ; Compare to data pointed to.
    BHI   DONT_COMMIT_TO_PLAYER ; If A higher (signed), goto.
    BRA   COMMIT_TO_PLAYER ; Is good to commit.
DATA_MINUS: ; 0x000F02, $DF02
    ADDA  Y ; Add player data, aka sub.
    BHS   DONT_COMMIT_TO_PLAYER ; If underflow.
    CMPA  1,X ; Compare to PLAYER+1
    BLO   DONT_COMMIT_TO_PLAYER ; If PLAYER+1 is lower, goto.
COMMIT_TO_PLAYER: ; 0x000F0A, $DF0A
    STA   Y ; If it's higher, store to player data.
DONT_COMMIT_TO_PLAYER: ; 0x000F0C, $DF0C
    LEAY  1,Y ; Player data++
    LEAX  8,X ; Difficulty data++
    CMPX  DIFFICULTY_DATA_END_LOC ; See if end.
    BNE   LOOP_X_PTR ; Loop if not end.
    PULS  A,X,Y,PC ; RTS, Restore.
IRQ_INITIAL_P1: ; 0x000F17, $DF17
    CLR   BANKSWITCH ; Set to IO
    LDA   #$A0 ; Setup DP
    TFR   A>DP
    LDA   #$04 ; PIA CTRL setting no interrupts, output reg direction.
    STA   PIA_ROM_CTRL_B ; Set setting
    LDA   PIA_ROM_DATA_B ; Clear IRQs
    LDA   VIDEO_COUNTER_BITS ; Load scanline.
    CMPA  #$80
    BLO   VADD_UPPER_HALF ; Top half, goto lower half stuff?
    LDA   R_A092_PROCESSING_LAST? ; Load val
    BNE   LEAVE_IRQ_RTN ; If != 0, leave IRQ.
    INC   R_A092_PROCESSING_LAST? ; Mark processing?
    JSR   IDK+THRUST+MORE ; Do subs
    JSR   MOVEMENT_STUFF_PLAYERS+IDK
    JSR   STARS_UNK
    LDA   VIDEO_COUNTER_BITS ; Load counter
    SUBA  #$08 ; -=8
    CMPA  #$A8 ; If A _ Scanline 168
    BLS   DONT_CAP_A ; <=, goto.
    LDA   #$A8 ; Cap
DONT_CAP_A: ; 0x000F47, $DF47
    STA   VIDEO_BITS_LOCATION_COPY ; Store to bits
    LDA   #$02
    STA   BANKSWITCH ; Bankswitch to 2
    LDD   VIDEO_BITS_LOCATION_COPY
    JSR   IRQ_RTN_MOVE_OBJS?_A065
    LDD   VIDEO_BITS_LOCATION_COPY
    JSR   SHIP_MOVE_RTN
    JSR   BULLET_RELATED?
    BRA   LEAVE_IRQ_RTN ; Leave IRQ RTN
VADD_UPPER_HALF: ; 0x000F5D, $DF5D
    LDB   R_A092_PROCESSING_LAST? ; Load val
    BEQ   LEAVE_IRQ_RTN ; If 0, nothing to do here.
    CLR   R_A092_PROCESSING_LAST? ; Clear
    INC   IRQS_COUNTER ; Inc
    LDB   #$38
    STB   WATCHDOG ; Set watchdog.
    CMPA  #$08 ; VADDR
    BHI   DONT_SET_PALETTE ; VADDR > 8, dont set palette.
    LDU   #$C010 ; Color palette stack ptr.
    LDD   COLOR_PALETTE_RAM_COPY+10
    LDX   COLOR_PALETTE_RAM_COPY+12
    LDY   COLOR_PALETTE_RAM_COPY+14
    PSHU  Y,X,B,A
    LDD   COLOR_PALETTE_RAM_COPY+4
    LDX   COLOR_PALETTE_RAM_COPY+6
    LDY   COLOR_PALETTE_RAM_COPY+8
    PSHU  Y,X,B,A
    LDD   COLOR_PALETTE_RAM_COPY
    LDX   COLOR_PALETTE_RAM_COPY+2
    PSHU  X,B,A
DONT_SET_PALETTE: ; 0x000F89, $DF89
    JSR   CHECK_COINDOOR_INPUT ; Check coin door input.
    LDA   #$07
    STA   BANKSWITCH ; Bankswitch to 7
    LDA   A0BA_PLAYER_GAME_STATE
    BITA  #$02 ; Test bit on val
    BNE   SKIP_BANK7_RTN ; If set, skip JSR below.
    JSR   JMP_TO_LAND_MODIFY?
SKIP_BANK7_RTN: ; 0x000F9A, $DF9A
    LDA   #$02
    STA   BANKSWITCH ; Bank to 2
    LDD   $A0A1 ; Load val
    JSR   SHIP_MOVE_RTN ; IDK
    LDD   $A0A1 ; Load val again
    JSR   IRQ_RTN_MOVE_OBJS?_A065 ; IDK
    JSR   MOVE_OBJ_LIST_A065? ; IDK
LEAVE_IRQ_RTN: ; 0x000FAC, $DFAC
    ORCC  #$FF ; Mask interrupts.
    CLR   BANKSWITCH ; Set to IO
    LDA   #$05 ; CTRL, C1 enable
    STA   PIA_ROM_CTRL_B ; COUNT_240_IRQ enable.
    LDA   CURRENT_BANK ; Load bank was.
    STA   BANKSWITCH ; Restore.
    LDA   S ; Get CC on stack.
    ANDA  #$6F ; Clear Entire+IRQ mask.
    STA   S ; Put that back.
    PULS  CC,A,B,DP,X,Y,U,PC ; RTI manually since we unset entire?
IRQ_INITIAL_P2: ; 0x000FC3, $DFC3
    CLR   BANKSWITCH ; Set to IO
    LDA   #$A0 ; DP
    TFR   A>DP
    LDA   #$04 ; Sets no interrupts from, DDR Output
    STA   PIA_ROM_CTRL_B ; Store, reading port data.
    LDA   PIA_ROM_DATA_B ; Clear IRQ from ROM PIA.
    LDA   VIDEO_COUNTER_BITS ; Get video counter.
    CMPA  #$58 ; If _ #$58
    BLO   VIDEO_COUNTER_BITS_UNDER_#$58 ; <, goto.
    LDB   R_A092_PROCESSING_LAST? ; Get val
    BNE   LEAVE_IRQ_RTN ; If != 0, goto.
    INC   R_A092_PROCESSING_LAST? ; Inc if 0
    COMA ; Invert video bits because flipped screen.
    NOP ; Nop
    STA   VIDEO_BITS_LOCATION_COPY ; Store inverted here.
    JSR   CHECK_COINDOOR_INPUT ; Do coin door input
    LDA   #$07
    STA   BANKSWITCH ; Bankswitch to 7
    LDA   A0BA_PLAYER_GAME_STATE ; Val
    BITA  #$02 ; If bit 2...
    BNE   SKIP_JSR ; Is set, goto...
    JSR   JMP_TO_LAND_MODIFY? ; Do this if set.
SKIP_JSR: ; 0x000FF4, $DFF4
    LDA   #$02 ; Bank 2
    STA   BANKSWITCH
    LDD   $A0A1 ; Load val
    JSR   SHIP_MOVE_RTN
    LDD   $A0A1 ; Load val
    JSR   IRQ_RTN_MOVE_OBJS?_A065
    BRA   LEAVE_IRQ_RTN ; Leaves
VIDEO_COUNTER_BITS_UNDER_#$58: ; 0x001005, $E005
    LDB   R_A092_PROCESSING_LAST?
    BEQ   LEAVE_IRQ_RTN ; Leaves if 0
    CLR   R_A092_PROCESSING_LAST? ; Clear
    INC   IRQS_COUNTER ; Inc
    LDB   #$39 ; Always flipped?
    STB   WATCHDOG ; Store
    CMPA  #$04 ; Video counter bits.
    BHI   VIDEO_COUNTER_>_4 ; If > 4, goto.
    LDU   #$C010 ; Ptr
    LDD   COLOR_PALETTE_RAM_COPY+10 ; Load
    LDX   COLOR_PALETTE_RAM_COPY+12 ; Load
    LDY   COLOR_PALETTE_RAM_COPY+14 ; Load
    PSHU  Y,X,B,A ; Push all loaded to stack
    LDD   COLOR_PALETTE_RAM_COPY+4 ; Load
    LDX   COLOR_PALETTE_RAM_COPY+6 ; Load
    LDY   COLOR_PALETTE_RAM_COPY+8 ; Load
    PSHU  Y,X,B,A ; Push all to stack.
    LDD   COLOR_PALETTE_RAM_COPY ; Load
    LDX   COLOR_PALETTE_RAM_COPY+2 ; Load
    PSHU  X,B,A ; Push to stack.
VIDEO_COUNTER_>_4: ; 0x001031, $E031
    JSR   IDK+THRUST+MORE
    JSR   MOVEMENT_STUFF_PLAYERS+IDK
    JSR   STARS_UNK
    LDA   #$02
    STA   BANKSWITCH
    LDD   VIDEO_BITS_LOCATION_COPY
    JSR   SHIP_MOVE_RTN
    LDD   VIDEO_BITS_LOCATION_COPY
    JSR   IRQ_RTN_MOVE_OBJS?_A065
    JSR   BULLET_RELATED?
    JSR   MOVE_OBJ_LIST_A065?
    JMP   LEAVE_IRQ_RTN
INIT_STARS: ; 0x001052, $E052
    LDX   #$AF9D ; Ptr to stars data.
    LDB   #$10 ; Num stars?
    STB   $A0AE ; Idk why
    CLRB
LOOP_MORE_STARS: ; 0x00105A, $E05A
    JSR   RANDOM_VALUE_FWD+IN_A ; Get val.
    CMPA  #$9C ; If _ #$9C
    BHS   LOOP_MORE_STARS ; >=, get another number. This is to be anywhere on the screen col wise.
    STA   X ; <9C gets stored.
TRY_NEW_RANDOM_VAL: ; 0x001063, $E063
    JSR   RANDOM_VALUE_FWD+IN_A ; Get val.
    CMPA  #$A8 ; If _ #$A8
    BHI   TRY_NEW_RANDOM_VAL ; >, Get another.
    CMPA  #$2A ; If _ #$2A
    BLS   TRY_NEW_RANDOM_VAL ; <=, get another.
    STA   1,X ; Store to X[1]
    STB   2,X ; Store to X[2]Cleared
    ADDB  #$11 ; Add with value
    ANDB  #$77 ; Limit bits on each nibble.
    LEAX  4,X ; X+=4, next star.
    CMPX  #$AFDD ; End star data
    BNE   LOOP_MORE_STARS ; Do more.
RTS_STARS: ; 0x00107D, $E07D
    RTS ; RTS
STARS_UNK: ; 0x00107E, $E07E
    LDA   A0BA_PLAYER_GAME_STATE ; Load
    BITA  #$20 ; Test bit
    BNE   RTS_STARS ; If not set, RTS
    LDX   #$AF9D ; Load, stars PTR
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load val
    ANDB  #$80 ; Clear bottom 7
    STD   $A06F ; Store
    LDD   R_A022_UNK ; Load
    ANDB  #$80 ; Clear bottom 7
    SUBD  $A06F ; Sub with
    ASLB ; B << 1 into A
    ROLA
    STA   $A06F ; Store to
    LDB   #$F0 ; Load
    LDA   $A021 ; Load
    BITA  #$40 ; Test bit
    BNE   SKIP_INVERT_B 
    COMB ; B = #$0F
SKIP_INVERT_B : ; 0x0010A0, $E0A0
    STB   $A071 ; Store B
    CLRA ; Clear
    STA   [X] ; Write indir 16 times, XOBJ[0]
    STA   [4,X] ; XOBJ[4]
    STA   [8,X] ; XOBJ[8]
    STA   [12,X] ; XOBJ[12]
    STA   [16,X] ; XOBJ[16]
    STA   [20,X] ; XOBJ[20]
    STA   [24,X] ; XOBJ[24]
    STA   [28,X] ; XOBJ[28]
    STA   [32,X] ; XOBJ[32]
    STA   [36,X] ; XOBJ[36]
    STA   [40,X] ; XOBJ[40]
    STA   [44,X] ; XOBJ[44]
    STA   [48,X] ; XOBJ[48]
    STA   [52,X] ; XOBJ[52]
    STA   [56,X] ; XOBJ[56]
    STA   [60,X] ; XOBJ[60]
    LDB   $A0AE ; Get B
SKIP_TONS_OF_INDIR_WRITES: ; 0x0010D4, $E0D4
    LDA   X ; A from X
    ADDA  $A06F ; Add with val
    CMPA  #$9C ; CMP to SCREEN_HIGH_MAX?
    BLO   KEEP_A_SAME ; <, goto.
    CMPA  #$C0 ; Unk val
    BLS   LOAD_A_ZERO ; <=, goto.
    LDA   #$9B ; Idk why val
    BRA   KEEP_A_SAME ; Always goto
LOAD_A_ZERO: ; 0x0010E4, $E0E4
    LDA   #$00 ; Zero
KEEP_A_SAME: ; 0x0010E6, $E0E6
    STA   X ; Store to X
    LDA   2,X ; Load X+2
    ANDA  $A071 ; And with val
    STA   [0,X] ; MISTAKE wrong addrmode? A to X ptr
    LEAX  4,X ; X += 4
    DECB ; B--
    BNE   SKIP_TONS_OF_INDIR_WRITES ; If not 0, loop.
    LDB   A0DF_RAND_BYTE ; Get random byte
    ANDB  #$3C ; Get 0011.1100
    LDX   #$AF9D ; Load list
    ABX ; X+B
    LDA   2,X ; A from X+2
    ADDA  #$11 ; Add star pixels?
    ANDA  #$77 ; Range
    STA   2,X ; Store back
    LDA   A0DF_RAND_BYTE ; Getr random
    BITA  #$01 ; Test bit
    BNE   RTS ; If set, leave.
    CMPA  #$98 ; If _ #$98
    BLO   CLEAR_PTR@X ; <, goto.
    LDU   #$A102 ; Ptr to IDK
    LEAU  -74,U ; U-=74
    LDU   U ; U.next?
    CMPU  #$6245 ; U _ val. Unk val
    BEQ   SUB_A ; If EQ
    TST   A0BA_PLAYER_GAME_STATE ; Test
    BMI   SUB_A ; If top bit set, goto.
    CMPA  #$A0 ; CMP #$A0
    BLO   SUB_A ; <, goto.
    CMPA  #$A1 ; If _ val
    BHS   SUB_A ; >=, goto.
    LDB   A0E0_RAND_WORD+1 ; B random
    TFR   D>X ; D to X, val range A0XX
    LDB   A0E0_RAND_WORD ; Load random val
    STB   X ; Store to X in A0XX range???
SUB_A: ; 0x001130, $E130
    SUBA  #$84 ; A -= 84
CLEAR_PTR@X: ; 0x001132, $E132
    CLR   [0,X] ; Mistake again? Clear ptr@X
    STA   X ; A to X
    LDA   A0BA_PLAYER_GAME_STATE
    BITA  #$02
    BEQ   RTS ; If game state not set, RTS
    LDA   A0E0_RAND_WORD+1 ; Random
    ANDA  #$3F ; Get bits 0011.1111
    LDB   #$03 ; B = 3
    MUL ; Multiply vals.
    ADDB  #$2A ; Add #$2A
    STB   1,X ; Store B to XXYY ptr?
RTS: ; 0x001148, $E148
    RTS
SETUP_POOL_4162: ; 0x001149, $E149
    LDX   #$A162 ; PTR
    STX   PTR_TO_A162_POOL ; Store
LOOP_RANDOM: ; 0x00114E, $E14E
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random.
    STA   32,X ; Store to X+32
    STA   X+ ; Store to X
    CMPX  #$A183 ; End?
    BNE   LOOP_RANDOM ; Loop
    RTS ; Leave
DRAW_THRUST_TO_LEFT: ; 0x00115C, $E15C
    LDX   PTR_TO_A162_POOL ; X from
    LDU   SHIP_SCR_POS_XXYY ; U from
    LEAU  -255,U ; U -= 255
    LDD   X ; Load from X
    STD   U ; Store to U
    LDA   5,X ; Load 
    LDB   9,X ; Load
    STD   2,U ; Store to
    LDA   12,X ; Load
    STA   4,U ; Store
    LDA   WGT_DATA_A_RAM_COPY
    BITA  #$02 ; If thrust pressed.
    BEQ   RTS ; Not pressed, RTS.
    LDA   3,X ; Load
    LDB   6,X ; Load
    STD   -255,U ; Store
    LDA   10,X ; Load
    STA   -253,U ; Store
    LDA   4,X ; Load
    LDB   7,X
    STD   -511,U ; Store
    LDA   11,X ; Load
    STA   -509,U ; Store
    LDA   8,X ; Load
    STA   -766,U ; Store
RTS: ; 0x00119A, $E19A
    RTS
DRAW_SHIP_THRUST_TO_RIGHT?: ; 0x00119B, $E19B
    LDU   PTR_TO_A162_POOL ; Load val
    LDX   SHIP_SCR_POS_XXYY ; Lod val
    LEAX  2049,X ; X += ?
    PULU  A,B,Y ; Pull from U
    STD   X ; Val to X
    STY   2,X ; Val to X[2]
    PULU  A,B,Y ; Pull
    STA   4,X ; Val to OBJ[4]
    LDA   WGT_DATA_A_RAM_COPY ; Load
    BITA  #$02 ; Test thrust
    BEQ   RTS ; Not pressed.
    STB   257,X ; B to. Thrust drawn?
    STY   258,X ; Y to
    PULU  A,B,Y
    STY   513,X ; Y to
    STA   515,X ; A to
    STB   770,X ; B to
RTS: ; 0x0011CC, $E1CC
    RTS
CLEAR_THRUST_MOVING_LEFT: ; 0x0011CD, $E1CD
    LDU   SHIP_SCR_POS_XXYY ; Load stack
    CLRB ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear Y
    LEAU  2054,U ; U,X+16px,Y+6
    PSHU  Y,X,B ; Clear 5Y
    STX   257,U ; Clear +1Y,3H
    STB   259,U
    STX   513,U ; Clear +2Y,3h
    STB   515,U
    STB   770,U ; Clear +3Y, 1h
    RTS
CLEAR_THRUST_MOVING_RIGHT: ; 0x0011F0, $E1F0
    LDU   SHIP_SCR_POS_XXYY ; Load stack
    CLRB ; Clear
    LDX   #$0000 ; Clear
    LEAY  X ; Clear
    LEAU  -250,U ; X-1,Y+6
    PSHU  Y,X,B ; Clear 5
    STX   -255,U ; Clear X-1,Y-1,3B
    STB   -253,U
    STX   -511,U ; Clear X-2,Y-1,3B
    STB   -509,U
    STB   -766,U ; Clear X-3,Y-2,1B
    RTS
SHIP_MOVE_RTN: ; 0x001213, $E213
    STA   R_A077_REGISTER_TEMP? ; Save
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$10 ; Test bit
    BNE   RTS_A_MESSED_UP ; If set, leave.
    LDA   R_A077_REGISTER_TEMP? ; Load saved
    CMPA  SHIP_SCR_POS_XXYY+1 ; If A _ Loc
    BLS   RTS_A_MESSED_UP ; <=, goto.
    CMPB  SHIP_SCR_POS_XXYY+1 ; If B _ Loc
    BHI   RTS_A_MESSED_UP ; >, goto.
    LDA   $A0BD ; Load val
    BMI   Diff_JSR_set ; If negative, goto.
    JSR   CLEAR_THING
    JSR   CLEAR_THRUST_MOVING_RIGHT
    BRA   SKIP_OTHER_SET ; Skip other subs.
Diff_JSR_set: ; 0x001231, $E231
    JSR   CLEAR_THING
    JSR   CLEAR_THRUST_MOVING_LEFT
SKIP_OTHER_SET: ; 0x001237, $E237
    LDD   $A0BB ; Move val
    STD   $A0BD
    BMI   D_NEGATIVE ; If negative, goto.
    JSR   OTHER_BITMAP+MOVE
    JSR   DRAW_THRUST_TO_LEFT
RTS_A_MESSED_UP: ; 0x001243, $E243
    RTS ; Leave
D_NEGATIVE: ; 0x001244, $E244
    JSR   BITMAP+MOVE
    JMP   DRAW_SHIP_THRUST_TO_RIGHT?
OTHER_BITMAP+MOVE: ; 0x00124A, $E24A
    LDY   #$F9C1
MOVE_THING: ; 0x00124E, $E24E
    LDA   $A0C4 ; Load
    ASLA ; Into carry
    LDD   $A0C1 ; Move
    STD   SHIP_SCR_POS_XXYY
    JMP   GFX_16X6_MOVE+ADJUST ; Put to screen
BITMAP+MOVE: ; 0x001258, $E258
    LDY   #$F9CB ; BITMAP ptr
    BRA   MOVE_THING ; Move
CLEAR_THING: ; 0x00125E, $E25E
    LDD   SHIP_SCR_POS_XXYY ; Pos?
    JMP   GFX_CLEAR_16X6 ; Move
MOVEMENT_STUFF_PLAYERS+IDK: ; 0x001263, $E263
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$40 ; Test bit
    LBNE  RTS ; RTS if set.
    CLR   $A06F ; Clear
    LDD   $A0C7 ; Load
    COMA ; Invert
    COMB
    ADDD  #$0001 ; +1
    BPL   SKIP_INVERT_A ; If positive
    COM   $A06F ; Invert again
SKIP_INVERT_A: ; 0x001278, $E278
    ASLB ; B << 2 into A
    ROLA
    ASLB
    ROLA
    ADDD  $A0C8 ; Add to
    STD   $A0C8 ; Store
    LDA   $A06F ; Load
    ADCA  $A0C7 ; Add with carry
    STA   $A0C7 ; Store
    LDD   $A0C7 ; Load into D
    LDA   WGT_DATA_A_RAM_COPY ; Get input
    BITA  #$02 ; Test if thrust
    BEQ   THRUST_NOT_PRESSED ; If 1, taken
    CLR   $A06F ; Clear
    LDD   $A0BD ; Load
    BPL   SKIP_INVERT_A ; If positive, goto
    COM   $A06F ; Invert
SKIP_INVERT_A: ; 0x001296, $E296
    ADDD  $A0C8 ; Add with
    STD   $A0C8 ; Store to
    LDA   $A06F ; Load
    ADCA  $A0C7 ; Add with carry
    STA   $A0C7 ; Store to
THRUST_NOT_PRESSED: ; 0x0012A0, $E2A0
    LDD   $A0C7 ; Get word
    ASRA ; A >> into B
    RORB
    ASRA ; A >> into B
    RORB
    CLRA ; A=0
    ASRB ; B >> 1
    RORA ; Bring B into A...
    STA   $A094 ; Store
    STB   $A093 ; Store
    LDA   $A0BD ; Load
    BMI   A_DIFF_VAL_SKIP_CLEARS_IF_NEGATIVE ; If negative, goto.
    LDA   #$20 ; Load with val
    TSTB ; Test B
    BMI   CLEAR_BEFORE_RTN ; If B negative.
    BRA   SKIP_CLEARS ; Always went to.
A_DIFF_VAL_SKIP_CLEARS_IF_NEGATIVE: ; 0x0012B8, $E2B8
    LDA   #$70 ; Load with val
    TSTB ; Test B
    BMI   SKIP_CLEARS ; If negative, goto. Skip clears.
CLEAR_BEFORE_RTN: ; 0x0012BD, $E2BD
    CLR   $A094 ; Clear
    CLR   $A093 ; Clear
SKIP_CLEARS: ; 0x0012C1, $E2C1
    LDB   $A094 ; Load
    ADDA  $A093 ; Add
    STA   $A093 ; Store
    SUBD  $A0C3 ; Sub value with loc
    BEQ   CLEAR_95 ; If 0, goto
    BLO   CMPD_TO_#$FF00 ; If value subbed was higher, goto.
    CMPD  #$0100 ; Subbed was lower.
    BLS   CLEAR_95 ; If <= val, goto.
    LDD   #$0040 ; Load with
    STD   $A095 ; Store to.
    LDD   #$0100 ; Load
    ADDD  $A0C3 ; Add with
    BRA   D_TO_C3 ; Goto
CMPD_TO_#$FF00: ; 0x0012DF, $E2DF
    CMPD  #$FF00 ; Comp to
    BGT   CLEAR_95 ; If >, goto
    LDD   #$FFC0 ; Load val
    STD   $A095 ; Store to
    LDD   #$FF00 ; Load val
    ADDD  $A0C3 ; Store to
    BRA   D_TO_C3
CLEAR_95: ; 0x0012F1, $E2F1
    CLRA
    CLRB
    STD   $A095 ; Clear
    LDD   $A093 ; Move
D_TO_C3: ; 0x0012F7, $E2F7
    STD   $A0C3 ; Store
    STA   $A0C1 ; Store to
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load
    STD   R_A022_UNK ; Store
    LDD   $A0C7 ; Load
    CMPD  #$0100 ; If D _ val
    BLT   DONT_APPLY_MAX ; <, set
    LDD   #$0100 ; Max
DONT_APPLY_MAX: ; 0x00130A, $E30A
    CMPD  #$FF00 ; Compare to
    BGT   DONT_APPLY_MIN ; If >, don't apply min.
    LDD   #$FF00 ; Min
DONT_APPLY_MIN: ; 0x001313, $E313
    STD   $A0C7 ; Store
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add with
    SUBD  $A095 ; Sub from
    STD   R_A020_SCREEN_POS_CHANGE? ; Store to
    LDD   $A0C3 ; Load
    LSRA ; A >> 2, into B
    RORB
    LSRA
    RORB
    ANDB  #$E0 ; Only bits added in.
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add with
    STD   $A0CC ; Store to
    LDB   PLAYER.VPOS ; Load
    LDA   WGT_DATA_B_RAM_COPY
    LSRA ; Test UP bit
    BLO   UP_SET
    LDA   WGT_DATA_A_RAM_COPY
    BMI   DOWN_SET ; If down set
    LDD   #$0000
    BRA   COMMIT_D
UP_SET: ; 0x001337, $E337
    CMPB  #$2B ; Compare PLAYER.VPos to val
    BLS   RTS ; <=, RTS
    LDD   PLAYER_V_MOMENTUM ; Load momentum?
    BPL   SET_UNIT_UP ; If positive, aka going down, up unit.
    ADDD  #$FFF8 ; Add sub unit
    CMPD  #$FE00 ; If _ val
    BGE   COMMIT_D ; >, write.
    LDD   #$FE00 ; Cap
    BRA   COMMIT_D ; Commit
SET_UNIT_UP: ; 0x00134D, $E34D
    LDD   #$FF00 ; If going down, instantly change to 1 unit up.
    BRA   COMMIT_D ; Commit val
DOWN_SET: ; 0x001352, $E352
    CMPB  #$EE ; PLAYER.VPos
    BHS   RTS ; If >=, RTS
    LDD   PLAYER_V_MOMENTUM ; Get momentum?
    BLE   SET_UNIT_DOWN ; If <= 0, aka going up, set to 1 unit.
    ADDD  #$0008 ; Add with sub unit.
    CMPD  #$0200 ; Map
    BLS   COMMIT_D ; <=, save.
    LDD   #$0200 ; Cap
    BRA   COMMIT_D ; Alaways do.
SET_UNIT_DOWN: ; 0x001368, $E368
    LDD   #$0100 ; Instantly move 1 unit per.
    BRA   COMMIT_D ; This can be taken out rofl.
COMMIT_D: ; 0x00136D, $E36D
    STD   PLAYER_V_MOMENTUM ; Store momentum.
    ADDD  PLAYER.VPOS ; Add to player VPos
    STD   PLAYER.VPOS ; Store to VPos
    STA   $A0C2 ; Store here too, idk why.
RTS: ; 0x001375, $E375
    RTS ; Leave
MOVE_OBJ_LIST_A065?: ; 0x001376, $E376
    LDA   A0BA_PLAYER_GAME_STATE ; State?
    BITA  #$20 ; Test bit
    BNE   RTS ; If set, RTS
    LDX   #$A065 ; List
    BRA   X_TO_X.NEXT
VALID_OBJ_PROCESS: ; 0x001381, $E381
    LDD   10,X ; Load X[10]
    ADDD  14,X ; Add X[14]
    STD   10,X ; Store to X[10]
    LDD   12,X ; Load X[12]
    ADDD  16,X ; Add X[16]
    CMPA  #$2A ; If _ #$2A
    BHS   DONT_WRAP_TO_BOTTOM ; >=, goto.
    LDA   #$F0 ; Wrap to bottom of screen.
DONT_WRAP_TO_BOTTOM: ; 0x001392, $E392
    CMPA  #$F0 ; If _ #$F0
    BLS   DONT_WRAP_TO_TOP_OF_GAMEPLAY_AREA ; <=, goto
    LDA   #$2A ; Wrap to top of play area.
DONT_WRAP_TO_TOP_OF_GAMEPLAY_AREA: ; 0x001398, $E398
    STD   12,X ; Store to OBJ[12]
X_TO_X.NEXT: ; 0x00139A, $E39A
    LDX   X ; X = X.next
    BNE   VALID_OBJ_PROCESS ; Process if !=NULL
RTS: ; 0x00139E, $E39E
    RTS
IRQ_RTN_MOVE_OBJS?_A065: ; 0x00139F, $E39F
    PSHS  B,A
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$20 ; Test bit
    BNE   RTS ; If set, leave.
    LDX   #$A065 ; Load list ptr
    BRA   X_TO_X.next ; Into list obj.
PROCESS_OBJ: ; 0x0013AC, $E3AC
    LDD   4,X ; Load OBJ[4]
    BEQ   OBJ[4]_IS_ZERO ; If zero, goto.
    CMPB  S ; Compare to stack byte
    BHI   X_TO_X.next ; If higher than stack, next obj.
    CMPB  1,S ; Compare to S[1]
    BLS   X_TO_X.next ; <=, next obj.
    LDY   2,X ; Load Y from OBJ[Y]
    JSR   [8,Y] ; Callback+8 holds addr.
    CLRA ; Clear D
    CLRB
    STD   4,X ; Clear OBJ[4]
OBJ[4]_IS_ZERO: ; 0x0013C2, $E3C2
    LDB   12,X ; OBJ[12]
    CMPB  S ; S[0]
    BHI   X_TO_X.next ; If B if higher, next.
    CMPB  1,S ; S[1]
    BLS   X_TO_X.next ; If B <=, goto.
    LDD   10,X ; Load OBJ[10]
    SUBD  R_A020_SCREEN_POS_CHANGE? ; Sub with val
    CMPD  #$2580 ; Compare to val
    BHS   X_TO_X.next ; If D >= Val, goto.
    LDY   2,X ; OBJ[2], callback.
    ASLB ; Shift left
    ROLA ; Bring in shifted
    ASLB ; Shift left
    ROLA ; Bring in shifted.
    ADDA  Y ; Add A with callback val?
    CMPA  #$9C ; If A _ #$9C
    BHI   X_TO_X.next ; >, next obj.
    SUBA  Y ; Subtrack added?
    ASLB ; Shift B, filling out carry. Direction?
    LDB   12,X ; Load OBJ[12]
    STD   4,X ; Store D to OBJ[4]
    JSR   [6,Y] ; JSR to CALLBACK+6
X_TO_X.next: ; 0x0013ED, $E3ED
    LDX   X ; To X.next
    BNE   PROCESS_OBJ ; If not null, process.
RTS: ; 0x0013F1, $E3F1
    PULS  A,B,PC
SPAWNS_SOMETHING_IF_UNDER_20_WITH_6_PAST_JSR: ; 0x0013F3, $E3F3
    PSHS  U,Y,B,A ; Save
    LDA   ENEMY_UNK_SPAWNED?BULLET? ; Load
    CMPA  #$14 ; If A _ #$14, cap?
    BHS   RTS_TO_PC_JSR'D+6 ; >=, goto.
    LDD   10,X ; Load OBJ[10]
    SUBD  R_A020_SCREEN_POS_CHANGE? ; Sub with
    CMPD  #$2580 ; Idk why val
    BHS   RTS_TO_PC_JSR'D+6 ; >= CMP'd, RTS
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    LDB   12,X ; B from OBJ[12]
    CMPB  #$2A ; Off screen top
    BLS   RTS_TO_PC_JSR'D+6 ; <=, goto.
    LDX   LIST_23B_UNUSED_OBJS? ; Get objs free.
    BEQ   RTS_TO_PC_JSR'D+6 ; RTS if none.
    STD   4,X ; D to OBJ[4]
    STD   10,X ; D to OBJ[10]
    EXG   A-B ; Flip D
    STD   12,X ; To OBJ[12]
    STU   6,X ; U to OBJ[6]
    CLRA ; Clear D
    CLRB
    STD   14,X ; Clear
    STD   16,X ; Clear
    LDU   6,S ; U is JSR'd from addr.
    PULU  A,B,Y ; Restore passed.
    STD   18,X ; D to OBJ[18]
    STY   2,X ; Y to OBJ[2] handler?
    PULU  A,B ; Load
    STU   6,S ; Store new U back, RTS's here.
    STD   8,X ; to OBJ[8]
    LDA   #$14 ; Val
    STA   21,X ; To OBJ[21], [22]
    STA   22,X
    LDD   X ; D from X.next
    STD   LIST_23B_UNUSED_OBJS? ; Fix list.
    LDD   LIST_$6D_UNK ; Load list first entry
    STD   X ; Store to X.next
    INC   ENEMY_UNK_SPAWNED?BULLET? ; Inc bullets?
    STX   LIST_$6D_UNK ; Store X to list as head.
    PULS  A,B,Y,U,PC ; RTS, leaving 6 bytes ahead.
RTS_TO_PC_JSR'D+6: ; 0x00144A, $E44A
    LDU   6,S ; U = S[6]
    LEAU  6,U ; U += 6
    STU   6,S ; Replace
    CLRA ; Clear to flag rtn.
    PULS  A,B,Y,U,PC
BULLET_RELATED?: ; 0x001453, $E453
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$20 ; Test bit
    BNE   RTS ; If set, RTS.
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load val
    ANDB  #$E0 ; Clear bottom B
    STD   $A09D ; Store to
    LDD   R_A022_UNK ; Load val
    ANDB  #$E0 ; Clear bottom B
    SUBD  $A09D ; Sub with
    ASLB ; D << 2, 0's in.
    ROLA
    ASLB
    ROLA
    STD   $A09D ; Store to
    LDX   #$A06D ; PTR to list.
    BRA   X_TO_X.NEXT_BULLET?
PROCESS_OBJ_BULLET?: ; 0x001470, $E470
    LDY   4,X ; OBJ[4]
    LDD   16,X ; OBJ[16]
    ADDD  12,X ; OBJ[12]
    CMPA  #$2A ; A _ #$2A
    BLS   OFF_GAME_SCREEN ; <=, goto
    STD   12,X ; Store to OBJ[12]
    LDD   14,X ; OBJ[14]
    ADDD  $A09D ; Add with
    ADDD  10,X ; OBJ[10]
    CMPA  #$98 ; IF A _ #$98
    BHS   OFF_GAME_SCREEN ; >=, goto
    STD   10,X ; To OBJ[10]
    LDB   12,X ; OBJ[12]
    STD   4,X ; OBJ[4]
    LDU   4,X ; OBJ[4]
    JMP   [18,X] ; JMP to OBJ[18]
X_TO_X.NEXT_BULLET?: ; 0x001493, $E493
    LDX   X
    BNE   PROCESS_OBJ_BULLET? ; If valid, process.
RTS: ; 0x001497, $E497
    RTS
    LDU   RANDOM_PALETTE_ROTATION_DEFENDER_LOGO?
    LDB   11,X
    BPL   DELETE_DONT_ADD
    LEAU  6,U ; Switches which bullet shown?
DELETE_DONT_ADD: ; 0x0014A0, $E4A0
    LDD   #$0000 ; Clear
    STD   Y ; Clear Y to Y+2
    STA   2,Y
    STD   256,Y ; X+1, Y+0 to Y+2
    STA   258,Y
    LDY   4,X ; Y from XOBJ[4]
    LDD   U ; D from @U
    STD   Y ; X to Y
    LDD   2,U ; D from U[2]
    STA   2,Y ; A to Y+2
    STB   256,Y ; B to Y+0
    LDD   4,U ; D from U[4]
    STD   257,Y ; To X+1,Y+1 to Y+2
    BRA   X_TO_X.NEXT_BULLET? ; Next
OFF_GAME_SCREEN: ; 0x0014C6, $E4C6
    CLRA ; Clear D
    CLRB
    STA   22,X ; Clear OBJ[22], disabled?
    STD   Y ; Clear Y
    STA   2,Y ; (0,2)
    STD   256,Y ; (2,0)
    STA   258,Y ; (2,2)
    BRA   X_TO_X.NEXT_BULLET? ; Next OBJ
    LDU   PTR_TO_A1A2_POOL ; Graphic ptr?
    LDB   11,X ; OBJ[11]
    ASLB ; Get bit into carry
    LDD   #$0000 ; Clear bullet
    STD   Y ; X to X+1, Y to Y+2
    STA   2,Y
    STD   256,Y
    STA   258,Y
    LDY   4,X ; Get OBJ[4] to Y
    BLO   L_001507 ; If CC.c = 1, goto
    LDD   U ; D from U
    ANDA  #$0F ; Delete top bits.
    STD   Y ; To YOBJ..?
    LDD   2,U ; Load from UOBJ[2]
    ANDA  #$0F ; Delete top bits
    STA   2,Y ; Store A to YOBJ[2]? Unsure why
    ANDB  #$F0 ; Get upper bits only.
    STB   257,Y ; Store to Y,X+1,Y+1
    JMP   X_TO_X.NEXT_BULLET? ; Next OBJ
L_001507: ; 0x001507, $E507
    LDD   U ; D from U
    ANDB  #$0F ; Keep bottom bits.
    STB   1,Y ; Store to Y+1
    ANDA  #$F0 ; Get top bits
    STA   258,Y ; Store to Y,X+1,Y+2
    LDD   2,U ; Load U+2
    ANDA  #$F0 ; Keep top bits.
    STD   256,Y ; Store to Y+1
    JMP   X_TO_X.NEXT_BULLET? ; Next bullet.
CALLBACK_BULLET_HIT_PLAYER?: ; 0x00151E, $E51E
    LDD   #$0025
    JSR   SCORE_ADD_AB ; Score +25, hit by bullet?
    DEC   ENEMY_UNK_SPAWNED?BULLET? ; Dec counter.
    JSR   REMOVE_X_FROM_LIST_A06D ; Remove from list.
    JSR   HANDLER_IN_BANK_2/XOBJ[8]
    LDD   10,X ; D from OBJ[10]
    LSRA ; D >> 2
    RORB
    LSRA
    RORB
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add with val
    STD   10,X ; D to OBJ[10]
    LDA   12,X ; Load A with OBJ[12]
    SUBA  #$02 ; Sub 2
    STA   12,X ; Store back.
    LDD   #$F951 ; Load different callback.
    STD   2,X ; Store to obj.
    JSR   L_002C63
    LDD   #$D4E4
    JMP   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Still unsure.
    .db $5E ; Data?
SETUP_A1A2-A1B1_WITH_99/9A/A9/AA: ; 0x00154B, $E54B
    LDX   #$A1A2 ; Ptr?
    STX   PTR_TO_A1A2_POOL
LOOP_NOT_DONE: ; 0x001550, $E550
    LDB   #$0A ; Initial
    JSR   RANDOM_VALUE_FWD+IN_A
    BMI   NOT_NEGATIVE ; If top bit set, don't modify.
    LDB   #$09 ; Changed
NOT_NEGATIVE: ; 0x001559, $E559
    LSRA ; Shift A
    BLO   SHIFTED_OFF_ONE
    ADDB  #$A0 ; Add to B
    BRA   COMMIT_B
SHIFTED_OFF_ONE: ; 0x001560, $E560
    ADDB  #$90 ; Add this is was 0 shifted off.
COMMIT_B: ; 0x001562, $E562
    STB   X+ ; Store
    CMPX  #$A1C2 ; End?
    BNE   LOOP_NOT_DONE ; Not yet.
    RTS ; Leave
PROCESS_LIST_A06D_BULLETS?: ; 0x00156A, $E56A
    LDX   #$A06D ; List ptr
    BRA   TO_NEXT_OBJ
PROCESS_OBJ_UNK: ; 0x00156F, $E56F
    LDA   22,X ; Load OBJ[22]
    BEQ   REMOVE_BULLET_FROM_SCR? ; If 0, don't dec.
    DEC   21,X ; Dec val.
    BNE   TO_NEXT_OBJ ; To next
REMOVE_BULLET_FROM_SCR?: ; 0x001579, $E579
    LDU   X ; Load next obj
    STU   Y ; To previous, removing OBJ X
    LDU   LIST_23B_UNUSED_OBJS? ; Load list
    STU   X ; List to X.next
    STX   LIST_23B_UNUSED_OBJS? ; X is new head.
    JSR   HANDLER_IN_BANK_2/XOBJ[8]
    DEC   ENEMY_UNK_SPAWNED?BULLET?
    LEAX  Y ; X is now X.prev
TO_NEXT_OBJ: ; 0x00158A, $E58A
    LEAY  X ; Obj X to Y, Y is X.last in rtn
    LDX   X ; X to X.next
    BNE   PROCESS_OBJ_UNK ; If not null, goto.
    RTS ; RTS
    LDA   A0B5_LASER_COUNT? ; Load val
    CMPA  #$04 ; If A _ #$04
    BHS   REMOVE_OBJ+HANDLE ; >=, goto.
    INC   A0B5_LASER_COUNT? ; ++
    LDD   #$D51B
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Difficulty?
    LDX   $A0C1 ; Load X with
    LDA   $A0BB ; Load A with
    BPL   LASER_CONTINUE ; If A positive, goto.
    JMP   LASER_HANDLE_TO_LEFT ; Otherwise.
REMOVE_OBJ+HANDLE: ; 0x0015A8, $E5A8
    JMP   CALLBACK_REMOVE?
HIT_DETECT_LASER_AGAINST_ENEMIES: ; 0x0015AB, $E5AB
    PSHS  U,B,A ; Save
    LDA   #$02 ; Handler in bank 2
    STA   CURRENT_BANK
    STA   BANKSWITCH
    PULS  A,B ; Restore?
    NOP ; Removed something?
    NOP
    NOP
    LDU   #$F96F ; Ptr to IDK
    JSR   L_0016BA ; Do this
    PULS  U,PC ; Restore, leave.
LASER_CONTINUE: ; 0x0015C1, $E5C1
    LEAX  1796,X ; X+7,Y+4?
    STX   7,U ; To UOBJ[7]
    STX   9,U ; To UOBJ[9]
    STX   11,U ; To OBJ[11]
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$40 ; Test bit
    BNE   CLEAR_LASER_OBJ[11]_TO_OBJ[7] ; Set, goto.
    LDA   #$04 ; Idk val
    LDX   7,U ; Load OBJ[7]
    LDB   #$11 ; Load laser color.
    CMPX  #$9800 ; Compare to edge of screen.
    BHS   CLEAR_LASER_OBJ[11]_TO_OBJ[7] ; If >=, goto.
LOOP_STORE_LASER_1: ; 0x0015DC, $E5DC
    STB   X ; B to X
    LEAX  256,X ; X+1
    DECA ; Dec counter
    BNE   LOOP_STORE_LASER_1 ; Loop if not 0.
    LDB   #$99 ; Front of laser?
    STB   X ; B to X
    STX   7,U ; X stored back to obj.
    LDY   $A0A4 ; Load Y
    CMPY  #$A15F ; If Y _ ADDR
    BLO   DONT_SEED_Y ; <, goto.
    LDY   #$A142 ; Seed Y, randomness pool.
DONT_SEED_Y: ; 0x0015F8, $E5F8
    LDX   9,U ; X from OBJ[9]
    LDA   #$03 ; Unsure val
LOOP_STORE_LASER_2: ; 0x0015FC, $E5FC
    LDB   Y+ ; B from Y
    STB   X ; To X
    LEAX  256,X ; X+1
    DECA ; Dec A
    BNE   LOOP_STORE_LASER_2
    STY   $A0A4 ; Laser ptr 2?
    STX   9,U ; Store to OBJ[9]
    CLR   [11,U] ; Clear OBJ[11] PTR
    INC   11,U ; Inc high byte
    LDD   7,U ; D from OBJ[7]
    SUBA  #$06 ; Sub A
    BSR   HIT_DETECT_LASER_AGAINST_ENEMIES ; Need to solve
    BNE   CLEAR_LASER_OBJ[11]_TO_OBJ[7] ; Skip callback.
    LDA   #$01 ; Callback stuff.
    LDX   #$E5CB
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CLEAR_LASER_OBJ[11]_TO_OBJ[7]: ; 0x001621, $E621
    LDX   11,U ; Load OBJ[11]
    CLRA ; Clear A
LOOP_CLEAR_LASER: ; 0x001624, $E624
    STA   X ; Store to X+
    LEAX  256,X ; X+1
    CMPX  7,U ; Catch up to OBJ[7]
    BLS   LOOP_CLEAR_LASER ; If <=, goto.
    BRA   ONE_LESS_LASER
LASER_HANDLE_TO_LEFT: ; 0x001630, $E630
    LEAX  4,X ; X += 4? Idk why, addrmode ranging?
    STX   7,U ; Init obj stuff
    STX   9,U
    STX   11,U
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$40 ; Test bit
    BNE   CLEAR_LEASER_LEFT ; If set, player is dead.
    LDA   #$04 ; Loop count
    LDX   7,U ; PTR to current pos.
    LDB   #$11 ; Laser color.
    CMPX  #$0500 ; Edge of screen.
    BLS   CLEAR_LEASER_LEFT ; If X.pos <= 5, remove laser.
LOOP_PUT_LASER_LEFT: ; 0x001649, $E649
    STB   X ; Pixels to pos
    LEAX  -256,X ; -1
    DECA ; Loop--
    BNE   LOOP_PUT_LASER_LEFT ; != 0, loop
    LDB   #$99 ; White?
    STB   X ; Store to new pos.
    STX   7,U ; Store pos to obj
    LDY   $A0A4 ; Laser dots pool ptr
    CMPY  #$A15F ; End of pool
    BLO   L_001665 ; <, not end
    LDY   #$A142 ; Beginning of pool
L_001665: ; 0x001665, $E665
    LDX   9,U ; Holes pos, in obj.
    LDA   #$03 ; Loops
LOOP_PUT_HOLES_LEFT: ; 0x001669, $E669
    LDB   Y+ ; Load from
    STB   X ; To screen
    LEAX  -256,X ; X-1
    DECA ; Loop--
    BNE   LOOP_PUT_HOLES_LEFT
    STY   $A0A4 ; Store pos in pool back
    STX   9,U ; Store holes next pos to OBJ
    CLR   [11,U] ; Clear end of line.
    DEC   11,U ; X--
    LDD   7,U ; D from laser current
    JSR   HIT_DETECT_LASER_AGAINST_ENEMIES
    BNE   CLEAR_LEASER_LEFT ; If true, hit enemy.
    LDA   #$01 ; Otherwise, continue laser with callback.
    LDX   #$E638
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CLEAR_LEASER_LEFT: ; 0x00168D, $E68D
    LDX   11,U ; Load OBJ[11]
    CLRA ; Clear
LOOP_CLEAR_LASER_LEFT: ; 0x001690, $E690
    STA   X ; Store to screen
    LEAX  -256,X ; X-1
    CMPX  7,U ; Compare to end
    BHS   LOOP_CLEAR_LASER_LEFT
ONE_LESS_LASER: ; 0x00169A, $E69A
    DEC   A0B5_LASER_COUNT? ; 1 less laser on screen.
    JMP   CALLBACK_REMOVE?
LASER_HOLES_POOL_CREATION_FROM_RANDOM: ; 0x00169F, $E69F
    LDX   #$A142 ; PTR?
    STX   $A0A4 ; Put to.
LOOP_WRITE_X: ; 0x0016A4, $E6A4
    JSR   RANDOM_VALUE_FWD+IN_A ; Depends on randomness?
    CLRB ; Clear B
    LSRA ; Random to carry.
    BHS   SKIP_ADD_1 ; If CC.c=0, don't add.
    ADDB  #$01
SKIP_ADD_1: ; 0x0016AD, $E6AD
    LSRA ; Get random again
    BHS   SKIP_ADD_10 ; If CC.c=0, don't add.
    ADDB  #$10
SKIP_ADD_10: ; 0x0016B2, $E6B2
    STB   X+ ; Store B to X.
    CMPX  #$A162 ; Compare to end.
    BNE   LOOP_WRITE_X
    RTS
L_0016BA: ; 0x0016BA, $E6BA
    LDX   #$A065 ; List IDK
L_0016BD: ; 0x0016BD, $E6BD
    STD   $A0D6 ; D from addr
    ADDD  U ; D+=@U
    STD   $A0D8 ; Store to
    BRA   X_TO_X.NEXT
PROCESS_OBJ_UNK: ; 0x0016C5, $E6C5
    LDD   4,X ; OBJ[4]
    BEQ   X_TO_X.NEXT ; If 0, next obj.
    CMPA  $A0D8 ; If A _ addr
    BHS   X_TO_X.NEXT ; >=, next.
    CMPB  $A0D9 ; If B _ addr
    BHS   X_TO_X.NEXT ; >=, next.
    ADDD  [2,X] ; Add to D with OBJ[2] ptr
    CMPA  $A0D6 ; If A _ addr
    BLS   X_TO_X.NEXT ; <=, next.
    CMPB  $A0D7 ; If B _ addr
    BHI   MODIFY_OBJ_UNK ; >, run code finally.
X_TO_X.NEXT: ; 0x0016DC, $E6DC
    LDX   X ; X to X.next
    BNE   PROCESS_OBJ_UNK ; If valid, process.
    RTS ; Leave
MODIFY_OBJ_UNK: ; 0x0016E1, $E6E1
    STU   $A0DC ; U to addr.
    LDY   2,X ; Y = OBJ[2]
    SUBD  Y ; D - @Y
    STD   A073_SCRATCH_LOOP_WORD? ; Store to scratch
    CLRA ; Clear D
    CLRB
    STD   $A0D0 ; Clear
    STD   $A0D2 ; Clear
    LDD   A073_SCRATCH_LOOP_WORD? ; Load scratchpad
    SUBB  $A0D7 ; Subtract with val
    BHI   SUBTRACKED_HIGHER_B ; If subtracted was higher, goto.
    NEGB ; Invert B
    STB   $A0D1 ; Store just B to addr?
    BRA   A_STUFF_NOW
SUBTRACKED_HIGHER_B: ; 0x0016FB, $E6FB
    STB   $A0D3 ; Store B as-is
A_STUFF_NOW: ; 0x0016FD, $E6FD
    SUBA  $A0D6 ; A - addr
    BHI   SUBTRACTED_HIGHER_A ; If subtracted was higher, goto.
    NEGA ; Invert
    STA   $A0D0 ; Store to
    BRA   SKIP_OTHER_STORE
SUBTRACTED_HIGHER_A: ; 0x001706, $E706
    STA   $A0D2 ; Otherwise store to
SKIP_OTHER_STORE: ; 0x001708, $E708
    LDD   A073_SCRATCH_LOOP_WORD? ; D from scratch again
    ADDD  Y ; Add with @Y
    SUBB  $A0D9 ; Sub with
    BHI   SUB_B_W/_HIGHER_2 ; If subtracted higher, goto.
    CLRB ; Clear B
SUB_B_W/_HIGHER_2: ; 0x001711, $E711
    SUBA  $A0D8 ; Sub with
    BHI   SUB_A_W/_HIGHER_2 ; Subbed with higher, goto.
    CLRA ; Clear A
SUB_A_W/_HIGHER_2: ; 0x001716, $E716
    STD   $A0DA ; Store to
    LDD   Y ; D from Y
    SUBD  $A0D0 ; Sub with
    SUBD  $A0DA ; Sub with
    STD   $A0CE ; Store to
    LDA   1,U ; A from OBJ[1]
    STA   $A0D5 ; Store to
    LDB   $A0D2 ; B from addr
    MUL ; Multiply
    LDU   2,U ; U from U[2]
    LEAU  D,U ; U+=D
    LDA   1,Y ; A from YOBJ[1]
    STA   $A0D4 ; To var
    LDY   2,Y ; Y from YOBJ[2]
    LDB   $A0D0 ; B from
    MUL ; Multiply AB to D
    LEAY  D,Y ; Y+=D
    LDA   $A0D1 ; A from
    LEAY  A,Y ; Y+=A
    LDA   $A0D3 ; A from
    LEAU  A,U ; U+=A
L_00173F: ; 0x00173F, $E73F
    LDB   $A0CF ; B from
    DECB ; --
L_001742: ; 0x001742, $E742
    LDA   B,U ; A from U+B
    BEQ   L_001770 ; If 0, goto.
    LDA   B,Y ; A from Y+B
    BEQ   L_001770 ; If 0, goto.
    LEAY  B,Y ; Y += B
    TFR   Y>D ; Y to D
    LDU   2,X ; U from XOBJ[2]
    SUBD  2,U ; D-=UOBJ[2]
    LDY   4,X ; Y from XOBJ[4]
LOOP_UNK_SUB_RTN: ; 0x001755, $E755
    SUBB  1,U ; B-=U+1
    SBCA  #$00 ; Adjust A. CC.c set if borrowed...
    BLO   L_001761 ; If CC.c=1, goto.
    LEAY  256,Y ; Y+=1
    BRA   LOOP_UNK_SUB_RTN
L_001761: ; 0x001761, $E761
    ADDB  1,U ; B+=U+1
    ADCA  #$00 ; Adjust upper byte.
    LEAY  B,Y ; Y += B
    STY   $A0F8 ; To var
    JSR   [8,X] ; JSR XOBJ[8]
    LDA   #$01 ; True
    RTS ; True
L_001770: ; 0x001770, $E770
    DECB ; B--
    BPL   L_001742 ; If positive, loop.
    LDD   $A0D4 ; D from
    LEAY  A,Y ; Y += A
    LEAU  B,U ; U += B
    DEC   $A0CE ; addr--
    BNE   L_00173F ; If not 0, goto.
    LDU   $A0DC ; U from addr.
    JMP   X_TO_X.NEXT ; Process next.
RESET_ROTATING_TEXT_COLOR: ; 0x001782, $E782
    CLR   ROTATING_COLOR_INDEX ; Clear
ROTATING_TEXT_COLOR_CALLBACK: ; 0x001784, $E784
    LDX   #$E799 ; X from
    LDA   ROTATING_COLOR_INDEX ; A from
    LDB   A,X ; B from A+X
    BEQ   RESET_ROTATING_TEXT_COLOR ; If 0, goto.
    INC   ROTATING_COLOR_INDEX ; Inc var
    STB   COLOR_PALETTE_RAM_COPY+1 ; B to Palette+1
    LDA   #$02 ; Callback setup.
    LDX   #$E784
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
COLOR_ROTATION_TABLE: ; 0x001799, $E799
    .db $38
    .db $39
    .db $3A
    .db $3B
    .db $3C
    .db $3D
    .db $3E
    .db $3F
    .db $37
    .db $2F
    .db $27
    .db $1F
    .db $17
    .db $47
    .db $47
    .db $87
    .db $87
    .db $C7
    .db $C7
    .db $C6
    .db $C5
    .db $CC
    .db $CB
    .db $CA
    .db $DA
    .db $E8
    .db $F8
    .db $F9
    .db $FA
    .db $FB
    .db $FD
    .db $FF
    .db $BF
    .db $3F
    .db $3E
    .db $3C
    .db $00 ; EOF
MAIN_WAIT_LOOP?: ; 0x0017BE, $E7BE
    LDX   #$A05F ; PTR
    STX   R_A063_CALLBACK_LIST_ADDR? ; Store...
WAIT_FOR_IRQ_RAN: ; 0x0017C3, $E7C3
    LDA   IRQS_COUNTER ; Get A from
    BEQ   WAIT_FOR_IRQ_RAN ; If 0, wait.
    CLR   IRQS_COUNTER ; Clear.
    LDB   A0BA_PLAYER_GAME_STATE ; Get B
    BITB  #$7D ; Test 0111.1101 bits.
    BEQ   NONE_SET
    CLR   $A05E ; Clear?
    BRA   A_LOT_SKIPS_TO_HERE
NONE_SET: ; 0x0017D3, $E7D3
    ASLA ; Shift
    ADDA  $A05E ; Add with
    SUBA  #$04 ; Sub
    BPL   IS_STILL_POSITIVE
    CLRA ; Clear if negative.
IS_STILL_POSITIVE: ; 0x0017DB, $E7DB
    STA   $A05E ; Store
    CMPA  #$02 ; If _ 2
    BLO   A_LOT_SKIPS_TO_HERE ; <, go.
    LDB   #$03 ; Move
    STB   $A0AE
    CMPA  #$02
    BLS   A_LOT_SKIPS_TO_HERE ; <=, go.
    LDA   #$02 ; Move
    STA   $A05E
L_0017ED: ; 0x0017ED, $E7ED
    LDY   #$A065 ; List
LOOP_FIND_IDK: ; 0x0017F1, $E7F1
    LDX   Y ; X = Y.next
    BEQ   A_LOT_SKIPS_TO_HERE ; If NULL, goto.
    LDA   20,X ; Get data in X
    BEQ   OBJ[20]_WAS_ZERO ; If 0, goto.
    LEAY  X ; Y is now Y.next
    BRA   LOOP_FIND_IDK
OBJ[20]_WAS_ZERO: ; 0x0017FE, $E7FE
    LDU   X ; Y.next.next
    STU   Y ; ...to Y.next
    LDD   A0DF_RAND_BYTE ; Get value from.
    ANDA  #$3F ; And...
    ADDA  #$60 ; Add
    ADDD  10,X ; Add
    STD   10,X ; Store to...
    JSR   HANDLER_IN_BANK_2/XOBJ[8] ; Does tons.
    LDD   #$0000
    STD   4,X ; Clear
    LDU   LIST_$6B_UNK ; Get obj at head
    STX   LIST_$6B_UNK ; Store new head obj.
    STU   X ; Set old head obj to HEAD.next
A_LOT_SKIPS_TO_HERE: ; 0x00181A, $E81A
    LDA   #$02
    STA   CURRENT_BANK
    STA   BANKSWITCH ; Switch to bank 2
    BSR   L_001861 ; Sub
    JSR   L_002C66 ; Sub
    JSR   RANDOM_VALUE_FWD+IN_A ; Forward random.
LOOP_IDK: ; 0x001829, $E829
    LDX   $A082 ; X at addr
    BNE   SKIP_IDK ; If !0, goto.
    LDX   R_A086_RUN_CALLBACKS? ; X from
    BEQ   U_LIST_A05F ; If 0, goto.
    LDD   $A088 ; D from
    CLR   R_A086_RUN_CALLBACKS? ; Clear
    CLR   $A087 ; Clear
    BRA   L_00183F ; Goto
SKIP_IDK: ; 0x001839, $E839
    LDD   $A084 ; D from
    CLR   $A082 ; Clear
    CLR   $A083 ; Clear
L_00183F: ; 0x00183F, $E83F
    ANDB  A0BA_PLAYER_GAME_STATE ; And B with game state
    BNE   LOOP_IDK ; If not 0, goto.
    JSR   GET_15B_OBJECT+SCHEDULE ; IDK why exactly.
    BRA   LOOP_IDK
U_LIST_A05F: ; 0x001848, $E848
    LDU   #$A05F ; Obj handle list.
    BRA   U=U.NEXT,HANDLE_CALLBACK ; Handle
CALLBACK_PTR_VALID,HANDLE: ; 0x00184D, $E84D
    DEC   4,U ; OBJ[4]--
    BNE   U=U.NEXT,HANDLE_CALLBACK ; If not 0, don't call handler.
    STU   R_A063_CALLBACK_LIST_ADDR? ; Callback focused on to addr.
    JMP   [2,U] ; Run handler.
U=U.NEXT,HANDLE_CALLBACK: ; 0x001856, $E856
    LDU   U ; U = U.next
    BNE   CALLBACK_PTR_VALID,HANDLE ; If valid ptr, goto.
    LDS   #$BFFF ; Set stack, idk why
    JMP   MAIN_WAIT_LOOP? ; Goto
L_001861: ; 0x001861, $E861
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$10 ; Test bit
    BNE   CLR_AND_RTS ; If set, CLEAR+RTS
    LDD   SHIP_SCR_POS_XXYY ; Load ship pos.
    LDU   #$F9C1 ; Load U with
    TST   $A0BD ; Test byte.
    BPL   L_001873 ; If positive, goto.
    LDU   #$F9CB ; If negative, load instead.
L_001873: ; 0x001873, $E873
    PSHS  U,B,A ; Save
    INC   $A0DE ; Inc 
    JSR   L_0016BA ; Do
    PULS  A,B,U ; Restore
    BNE   L_001886 ; Always taken?
    LDX   #$A06D ; Load ptr to
    JSR   L_0016BD ; Do
    BEQ   CLR_AND_RTS ; If 0 ret, RTS
L_001886: ; 0x001886, $E886
    LDX   #$DA46 ; Set up callback.
    LDA   #$00 ; Do ASAP
    JSR   GET_15B_OBJECT+SCHEDULE ; Callback.
    LDA   A0BA_PLAYER_GAME_STATE ; Game state
    ORA   #$08 ; Set bit.
    STA   A0BA_PLAYER_GAME_STATE ; Store to.
CLR_AND_RTS: ; 0x001894, $E894
    CLR   $A0DE ; Clear addr
    RTS ; RTS
    LDA   $A0AF ; Load val
    BNE   L_0018BE ; If != 0, goto.
    INC   $A0AF ; Inc val
    LDD   $A0BD ; D from
    COMB ; Invert
    COMA
    ADDD  #$0001 ; Add 1
    STD   $A0BB ; Store to
SETUP_CALLBACK: ; 0x0018A6, $E8A6
    LDA   #$02 ; Callback
    LDX   #$E8AE
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
    LDA   WGT_DATA_A_RAM_COPY ; Load widget
    BITA  #$40 ; Test reverse.
    BNE   SETUP_CALLBACK ; If set,setup callback.
    LDA   #$05 ; Callback setup
    LDX   #$E8BC
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    CLR   $A0AF ; Clear val
L_0018BE: ; 0x0018BE, $E8BE
    JMP   CALLBACK_REMOVE? ; Not exactly sure why.
    LDA   $A09A ; Load val
    BNE   SMARTBOMB_BUTTON_HANDLED? ; If not 0, handle.
    LDX   A08D_CURRENT_PLAYER_PTR? ; Get player ptr.
    LDA   9,X ; Load OBJ[9]
    BEQ   SMARTBOMB_BUTTON_HANDLED? ; Request denied.
    INC   $A09A ; Inc this.
    DEC   9,X ; OBJ[9]--, smartbombs.
    JSR   SMARTBOMBS_TO_SCREEN ; Put new count to screen.
    LDD   #$D4D2 ; D val
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Idk rtn yet.
LOOP_ON_SCREEN_LIST: ; 0x0018D8, $E8D8
    LDX   LIST_$65_ON_SCREEN? ; Load list
LOOP_DESTROY_OBJECTS: ; 0x0018DA, $E8DA
    BEQ   POST_SMARTBOMB_HANDLERS ; If NULL, goto.
    LDD   4,X ; D from OBJ[4]
    BEQ   X_TO_X.NEXT ; If 0, goto.
    LDA   20,X ; A from OBJ[20]
    CMPA  #$02 ; Compare to.
    BHS   X_TO_X.NEXT ; If >=, goto.
    JSR   [8,X] ; OBJ destroy handler?
    BRA   LOOP_ON_SCREEN_LIST
X_TO_X.NEXT: ; 0x0018EC, $E8EC
    LDX   X ; X_TO_X.NEXT
    BRA   LOOP_DESTROY_OBJECTS
POST_SMARTBOMB_HANDLERS: ; 0x0018F0, $E8F0
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load list
    LDA   #$04 ; Load A with timer
    STA   7,U ; Store to OBJ[7]
SETUP_CALLBACK_E900: ; 0x0018F6, $E8F6
    COM   COLOR_PALETTE_RAM_COPY ; Invert to white.
    LDA   #$02 ; Setup callback.
    LDX   #$E900
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    DEC   7,U ; Dec value
    BNE   SETUP_CALLBACK_E900 ; Not done, callback again.
HYPERSPACE_PRESSED: ; 0x001904, $E904
    LDA   #$0A ; Timer
    LDX   #$E90C ; Callback
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
    LDA   WGT_DATA_A_RAM_COPY ; Load PIA
    BITA  #$04 ; Test hyperspace.
    BNE   HYPERSPACE_PRESSED ; Set
    LDA   #$0A ; Callback setup
    LDX   #$E91A
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    CLR   $A09A ; Clear hyperspace disable?
SMARTBOMB_BUTTON_HANDLED?: ; 0x00191C, $E91C
    JMP   CALLBACK_REMOVE? ; Do.
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$FD ; Test 1111.1101
    LBNE  JMP_RMV_X+HANDLED ; If any set, goto.
    LDA   #$77 ; Load 0111.0111
    STA   A0BA_PLAYER_GAME_STATE ; Store to state
    JSR   CLEAR_GAME_SCREEN ; Clear screen.
    LDA   #$0F ; Callback.
    LDX   #$E936
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
LOOP_REMOVE_ALL_FROM_LIST_6D: ; 0x001936, $E936
    LDX   LIST_$6D_UNK ; Load list.
    BEQ   L_00193F ; NULL, goto.
    JSR   REMOVE_X_FROM_LIST_A06D ; Remove all objects from list.
    BRA   LOOP_REMOVE_ALL_FROM_LIST_6D ; Do to all.
L_00193F: ; 0x00193F, $E93F
    CLR   ENEMY_UNK_SPAWNED?BULLET? ; Clear count
    LDD   A0DF_RAND_BYTE ; Random both.
    STD   R_A020_SCREEN_POS_CHANGE? ; To 2x
    STD   R_A022_UNK
    LSRB ; Shift B
    BHS   VAL_SHIFTED_0 ; If 0 shifted off, goto.
    LDD   #$2000 ; Idk val
    LDX   #$0300 ; Idk val
    BRA   VAL_SHIFTED_1
VAL_SHIFTED_0: ; 0x001952, $E952
    LDX   #$FD00 ; Idk val
    LDD   #$7000 ; Idk val
VAL_SHIFTED_1: ; 0x001958, $E958
    STD   $A0C3 ; Val to
    STX   $A0BB ; Val to
    LDB   A0E0_RAND_WORD ; Get random
    LSRB ; Shift
    ADDB  #$2A ; Add 2A
    STB   PLAYER.VPOS ; Store to VPOS
    STD   $A0C1 ; Store IDK
    CLRA ; Clear
    CLRB
    STA   $A0C9 ; Clear
    STD   $A0C7 ; Clear
    STD   PLAYER_V_MOMENTUM ; Clear
    JSR   GOTO_B7-C000 ; Do IDK
    LDB   #$50 ; IDK Val
    JSR   OR_AND_STORE_B_NO_HUMANOIDS? ; Set
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR
    .db $F9
    .db $C1
    .db $ED
    .db $BC
    .db $00
    .db $00
    LDD   #$0000 ; Load
    STD   14,X ; Clear OBJ[14]
    STD   16,X ; OBJ[16]
    LDD   PLAYER.VPOS ; Load VPOS
    STD   12,X ; to OBJ[12]
    LDD   $A0C3 ; Load
    LSRA ; D >> 2
    RORB
    LSRA
    RORB
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add
    STD   10,X ; To OBJ[10]
    LDA   $A0BB ; Val from
    BPL   DONT_SET_OTHER_HANDLER? ; If positive, goto.
    LDU   #$F9CB ; Handler swap.
    STU   2,X ; To OBJ[2]
DONT_SET_OTHER_HANDLER?: ; 0x00199D, $E99D
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load PTR
    STX   7,U ; Store X to OBJ[7]
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN?
    LDA   #$28 ; Setup callback.
    LDX   #$E9AC
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    LDX   7,U ; X from OBJ[7]
    JSR   REMOVE_X_FROM_LISTS_AND+HANDLE_STUFF ; JSR to
    JSR   A_FROM_A0FA,B_CLEARED_OR_2 ; Do
    LDA   A0E0_RAND_WORD+1 ; Random
    CMPA  #$C0 ; If _ val
    LBHI  L_000A46 ; >, goto.
JMP_RMV_X+HANDLED: ; 0x0019BC, $E9BC
    JMP   CALLBACK_REMOVE?
CALLBACK_ADVANCE_POOL_POINTERS: ; 0x0019BF, $E9BF
    LDX   PTR_TO_A162_POOL ; Ptr
    LEAX  1,X ; ++
    CMPX  #$A182 ; See if at end
    BLS   DONT_RESET_PTR_TO_A162 ; <=, goto.
    LDX   #$A162
DONT_RESET_PTR_TO_A162: ; 0x0019CB, $E9CB
    STX   PTR_TO_A162_POOL ; Store to
    LDX   PTR_TO_A1A2_POOL ; Ptr
    LEAX  1,X ; ++
    CMPX  #$A1BA ; Compare to
    BLS   DONT_RESET_PTR ; <=, goto.
    LDX   #$A1A2 ; Reset
DONT_RESET_PTR: ; 0x0019D9, $E9D9
    STX   PTR_TO_A1A2_POOL ; Store back
    LDA   #$04 ; Setup callback
    LDX   #$E9BF
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_ONSCREEN_HANDLE_IDK: ; 0x0019E3, $E9E3
    JSR   INIT_PROCESS_OBJ_INTO_ONSCREEN_LIST ; Put on screen in list.
    LDA   #$02
    LDX   #$E9EE
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Callback
    JSR   PROCESS_IDK ; Do
    JSR   PROCESS_LIST_A06D_BULLETS? ; Do
    LDA   #$02 ; Setup callback.
    LDX   #$E9FC
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    JSR   BANKSWITCH_TO_1 ; To bank 1
    JSR   $C003 ; Call rtn
    LDA   #$04 ; Callback setup.
    LDX   #$E9E3
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
PROCESS_IDK: ; 0x001A0A, $EA0A
    LDD   R_A020_SCREEN_POS_CHANGE? ; D from
    SUBD  #$0C80 ; D -= val
    STD   A073_SCRATCH_LOOP_WORD? ; To scratch.
    LDX   #$A065 ; X to list.
    BRA   PROCESS_NEXT
PROCESS_LOOP: ; 0x001A16, $EA16
    LDD   10,X ; D from XOBJ[10]
    SUBD  A073_SCRATCH_LOOP_WORD? ; Sub with scratch.
    CMPD  #$3E80 ; CMP to val.
    BLO   PROCESS_NEXT ; If <, goto next.
    LDU   X ; U = X.next
    STU   Y ; X.next to Prev.next
    LDU   LIST_$6B_UNK ; Load list
    STU   X ; X.next is list.
    STX   LIST_$6B_UNK ; New head to list.
    LEAX  Y ; X from prev obj.
PROCESS_NEXT: ; 0x001A2C, $EA2C
    LEAY  X ; Y = XOBJ
    LDX   X ; X to X.next
    BNE   PROCESS_LOOP
    RTS
INIT_PROCESS_OBJ_INTO_ONSCREEN_LIST: ; 0x001A33, $EA33
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load val
    SUBD  #$0C80 ; Subtract
    STD   A073_SCRATCH_LOOP_WORD? ; Store to scratchpad
    LDX   #$A06B ; List ptr
    BRA   PROCESS_OBJ_X
PROCESS_OBJ_INTO_ONSCREEN_LIST: ; 0x001A3F, $EA3F
    LDD   16,X ; D from OBJ[16]
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ADDD  12,X ; Add with OBJ[12]
    CMPA  #$2A ; If A _ #$2A
    BHS   DONT_WRAP_TO_F0 ; >=, goto.
    LDA   #$F0 ; If < val, load this.
DONT_WRAP_TO_F0: ; 0x001A50, $EA50
    CMPA  #$F0 ; If A _ #$F0
    BLS   DONT_WRAP_TO_2A
    LDA   #$2A
DONT_WRAP_TO_2A: ; 0x001A56, $EA56
    STD   12,X ; Store to OBJ[12]
    LDD   14,X ; Load OBJ[14]
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ADDD  10,X ; Add to OBJ[10]
    STD   10,X ; Store to OBJ[10]
    SUBD  A073_SCRATCH_LOOP_WORD? ; Subtrack scratchpad.
    CMPD  #$3E80 ; Compare to val
    BHS   PROCESS_OBJ_X ; >=, skip.
    LDU   X ; Load X.next
    STU   Y ; Store to Y.next, removing from whatever list it is in.
    LDU   LIST_$65_ON_SCREEN? ; Load list
    STU   X ; Store LIST.next to X.next
    STX   LIST_$65_ON_SCREEN? ; Store X to LIST.next
    LEAX  Y ; X from previous.
PROCESS_OBJ_X: ; 0x001A78, $EA78
    LEAY  X ; Previous in Y
    LDX   X ; X to X.next
    BNE   PROCESS_OBJ_INTO_ONSCREEN_LIST ; Process if not NULL
    RTS ; Leave
    NEGA
MAKE_BAITER_RTN?: ; 0x001A80, $EA80
    LDX   #$EAB4 ; Callback
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE ; Not exactly sure good name for rtn.
    LEAU  X ; X to U
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Fill out obj info.
    .db $F9
    .db $A3
    .db $EB
    .db $2B
    .db $33
    .db $33
    STX   7,U ; X to UOBJ[7]
    STU   6,X ; U to XOBJ[6]
    LDD   A0DF_RAND_BYTE ; Get random
    ANDA  #$1F ; Bottom bits.
    ADDD  R_A020_SCREEN_POS_CHANGE? ; Add with
    STD   10,X ; Store to OBJ[10]
    LSRB ; B >> 1
    ADDB  #$2A ; Add with
    STB   12,X ; Store B to OBJ[12]
    CLRA ; Clear D
    CLRB
    STD   16,X ; Init
    STD   14,X ; Init
    LDA   #$08 ; Load
    STA   9,U ; To UOBJ[9]
    BSR   MOVE_IDK_ALT? ; Do sub
    JMP   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN? ; Goto
CALLBACK_BAITER?IDK: ; 0x001AB4, $EAB4
    LDX   7,U ; X from U
    LDD   2,X ; D from XOBJ[2]
    CMPD  #$F8EC ; If A _ #$F8EC
    BEQ   SETUP_CALLBACK_AGAIN ; ==, goto.
    DEC   9,U ; Dec UOBJ[9]
    BNE   L_001AD5 ; Not 0, goto.
    LDA   R_A110 ; Load val
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get lower.
    STA   9,U ; Store to UOBJ[9]
    JSR   SPAWN_SOMETHING_IDK ; Do IDK
    BEQ   L_001AD5 ; If Z ret, goto.
    LDD   #$D52F ; Ptr
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
L_001AD5: ; 0x001AD5, $EAD5
    LDU   2,X ; U from XOBJ[2]
    LEAU  10,U ; U+=10
    CMPU  #$F9B7 ; If U _ #$F9B7
    BLS   COMMIT_U ; <=, goto.
    LDU   #$F9A3 ; Reset
    BSR   MOVE_IDK ; Do IDK
COMMIT_U: ; 0x001AE4, $EAE4
    STU   2,X ; Store U to XOBJ[2]
SETUP_CALLBACK_AGAIN: ; 0x001AE6, $EAE6
    LDA   #$06 ; Callback setup
    LDX   #$EAB4
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
MOVE_IDK: ; 0x001AEE, $EAEE
    LDA   A0DF_RAND_BYTE ; Random val
    CMPA  R_A111 ; If _ addr
    BLS   RTS ; <=, leave.
MOVE_IDK_ALT?: ; 0x001AF5, $EAF5
    LDD   #$4001 ; Move
    STD   A073_SCRATCH_LOOP_WORD?
    LDD   10,X ; D from XOBJ[10]
    SUBD  $A0CC ; Sub with
    BMI   DONT_NEGATE_SCRATCH[0] ; If now negative, goto.
    NEG   A073_SCRATCH_LOOP_WORD? ; Invert scratch.
DONT_NEGATE_SCRATCH[0]: ; 0x001B02, $EB02
    ADDD  #$0280 ; Add val
    .db $10 ; If D _ #$0500
    .db $83 ; SUBD val
    .db $05 ; ILL
BAD_BRANCH_LOC: ; 0x001B08, $EB08
    .db $00 ; NEG DP
    .db $23 ; <=, goto.
    .db $07 ; ASR DP
    LDB   A073_SCRATCH_LOOP_WORD? ; B random
    SEX ; Extend sign
    ADDD  $A0C7 ; Add with addr
    STD   14,X ; To OBJ[14]
DONT_USE_SCRATCH[0]_TO_D?: ; 0x001B12, $EB12
    LDA   12,X ; A from OBJ[12]
    SUBA  SHIP_SCR_POS_XXYY+1 ; Sub with ship Y
    BMI   DONT_NEGATE_SCRATCH[1] ; If negative, goto.
    NEG   A073_SCRATCH_LOOP_WORD?+1 ; Invert scratch val
DONT_NEGATE_SCRATCH[1]: ; 0x001B1A, $EB1A
    ADDA  #$0A ; Add val
    CMPA  #$14 ; If A _ #$14
    BLS   RTS ; <=, goto.
    CLRB ; Clear B
    LDA   A073_SCRATCH_LOOP_WORD?+1 ; Load scratch[1]
    ADDD  PLAYER_V_MOMENTUM ; Add with V momentum.
    ASRA ; D >> 1
    RORB
    STD   16,X ; To OBJ[16]
RTS: ; 0x001B2A, $EB2A
    RTS
CALLBACK_UNK: ; 0x001B2B, $EB2B
    DEC   R_A119_BAITER_COUNT? ; Dec counter.
    JSR   REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST ; Shot, add to score.
    .db $01 ; Illegal instruction. 1 byte.
    .db $20 ; Goes to always.
    .db $D4 ; ANDB dp
    .db $FD ; STD addr
    .db $39 ; RTS
L_001B36: ; 0x001B36, $EB36
    STA   A073_SCRATCH_LOOP_WORD? ; A to addr.
LOOP_MAKE_OBJ: ; 0x001B38, $EB38
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Make obj
    .db $F8
    .db $F7
    .db $EB
    .db $74
    .db $CC
    .db $CC
    JSR   RANDOM_VALUE_FWD+IN_A ; Get rand
    LDD   A0E0_RAND_WORD ; D random
    ANDA  #$3F ; Range D to 0011.1111 1111.1111
    ADDA  #$10 ; +0001.0000 in high byte
    STD   10,X ; To XOBJ[10]
    LSRB ; B >> 1
    ADDB  #$2A ; Add #$2A, top of screen avoid?
    STB   12,X ; B to XOBJ[12]
    LDB   A0DF_RAND_BYTE ; B random
    ANDB  #$3F ; Save 0011.1111
    ADDB  #$E0 ; += E0
    SEX ; Sign extend to D
    STD   14,X ; to XOBJ[14]
    LDB   A0E0_RAND_WORD+1 ; B random
    ANDB  #$7F ; Make positive
    SUBB  #$40 ; -=40
    SEX ; Sign extend to D.
    BMI   L_001B67 ; If negative, goto.
    ORB   #$20 ; B |= #$20
    BRA   L_001B69 ; Goto
L_001B67: ; 0x001B67, $EB67
    ANDB  #$DF ; Keep 1101.1111
L_001B69: ; 0x001B69, $EB69
    STD   16,X ; To XOBJ[16]
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN? ; Do
    DEC   A073_SCRATCH_LOOP_WORD? ; Dec scratch.
    BNE   LOOP_MAKE_OBJ
    RTS ; RTS
CALLBACK: ; 0x001B74, $EB74
    JSR   REMOVE_XOBJ_FROM_LISTS_A065|A06B_AND_SCORE+SOUND_FROM_4B_PAST_JSR ; Sub
    .db $02 ; ILL
    .db $10 ; ILL
    .db $D4 ; ANDB dp
    .db $F3 ; ADDD addr
    LDA   #$06 ; A seed
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get lower
    LEAY  X ; Y = XOBJ
    JSR   UNK_MAKE_OBJ_DETAILS_FROM_OBJ@Y? ; Clone obj?
    DEC   R_A114_ENEMY_IDK_COUNT ; Dec count? To make?
    RTS
RANDOM_WORD_TO_OBJ_X_[14],[16]: ; 0x001B89, $EB89
    JSR   RANDOM_VALUE_FWD+IN_A ; Move random
    LDB   A0DF_RAND_BYTE ; Get random in B
    SEX ; Extend B into A
    ASLB ; Shift
    ROLA ; Shift
    STD   16,X ; Store to OBJ[16]
    LDB   A0E0_RAND_WORD+1 ; Get random again
    ANDB  #$3F ; Get bottom bits.
    ADDB  #$E0 ; Add val
    SEX ; Extend again
    STD   14,X ; Store to OBJ[14]
    RTS
UNK_MAKE_OBJ_DETAILS_FROM_OBJ@Y?: ; 0x001B9E, $EB9E
    PSHS  U,Y,X,B,A
    STA   A073_SCRATCH_LOOP_WORD? ; Store A to loop count
LOOP_MAKE_THIS_OBJ: ; 0x001BA2, $EBA2
    LDA   R_A116_ENEMY_IDK_COUNT ; Load val
    INCA ; Inc
    CMPA  #$14 ; If A _ #$14
    BHI   RTS ; >, GOTO
    STA   R_A116_ENEMY_IDK_COUNT ; Store back
L_001BAD: ; 0x001BAD, $EBAD
    LDX   #$EC17 ; Callback?
L_001BB0: ; 0x001BB0, $EBB0
    LDA   #$00 ; Type?
    JSR   GET_15B_OBJECT+SCHEDULE ; Setup
    LEAU  X ; Save X in U
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR
    .db $F9
    .db $7B
    .db $EB
    .db $E9
    .db $24
    .db $24
    LDD   10,Y ; OBJ[10] move. Not sure what Y is.
    STD   10,X
    LDD   12,Y ; OBJ[12] too
    STD   12,X
    STX   7,U ; Obj X ptr to OBJ[7] of U
    STU   6,X ; Obj U ptr to OBJ[6] of X
    BSR   RANDOM_WORD_TO_OBJ_X_[14],[16] ; Get random.
    LDD   A0E0_RAND_WORD ; Get random word.
    ANDB  R_A10E ; And lower with val.
    STB   9,U ; Store to OBJ[9]
    ANDA  #$1F ; Get bottom bits of A
    STA   4,U ; Store to OBJ[4]
    LDA   R_A10D ; Load val
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT
    STA   11,U ; Store to OBJ[11]
    STX   LIST_$65_ON_SCREEN? ; Add to this list.
    DEC   A073_SCRATCH_LOOP_WORD? ; Dec loop counter.
    BNE   LOOP_MAKE_THIS_OBJ
RTS: ; 0x001BE7, $EBE7
    PULS  A,B,X,Y,U,PC ; Leave
    DEC   R_A116_ENEMY_IDK_COUNT ; Dec count
    JSR   REMOVE_X_FROM_LISTS_AND+HANDLE_STUFF ; Remove from list.
    PSHS  X ; Save obj
    JSR   XOBJ[6]_BACK_TO_AVAILABLE_LIST ; Pull from this list too.
    PULS  X ; Restory obj.
    LDD   10,X ; D from OBJ[10]
    SUBD  #$0040 ; Subtract val
    STD   10,X ; Store to OBJ[10]
    LDD   12,X ; D from OBJ[12]
    SUBA  #$02 ; Sub upper byte.
    STA   12,X ; Store back.
    LDU   #$F8E2 ; Change handler? Maybe not handler? Graphic?
    STU   2,X
    JSR   L_002C63 ; Do
    LDD   #$0115 ; Score add +150. Lander, swarmer.
    JSR   SCORE_ADD_AB ; Add to score.
    LDD   #$D516 ; D
    JMP   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do.
L_001C17: ; 0x001C17, $EC17
    LDX   7,U ; X from UOBJ[7]
    LDB   R_A10C ; B from addr
    LDY   $A0CC ; Y from addr
    CMPY  10,X ; CMPY XOBJ[10]
    BHS   SKIP_INVERT_1 ; >=, goto.
    NEGB ; Invert B otherwise.
SKIP_INVERT_1: ; 0x001C25, $EC25
    SEX ; Extend to D
    STD   14,X ; D to XOBJ[14]
    BRA   SKIP_SUB ; Goto
CALLBACK_UNK: ; 0x001C2A, $EC2A
    LDB   9,U ; B from UOBJ[9]
    LDX   7,U ; X from UOBJ[7]
    LDA   SHIP_SCR_POS_XXYY+1 ; A from SHIP.X
    CMPA  12,X ; Cmp to XOBJ[12]
    BHI   SKIP_INVERT_2 ; >, goto.
    NEGB ; Invert
SKIP_INVERT_2: ; 0x001C35, $EC35
    SEX ; Extend to D
    ADDD  16,X ; ADD with XOBJ[16]
    CMPD  #$0200 ; CMP to val
    BLT   DONT_CAP_D ; <, goto.
    LDD   #$0200 ; D cap positive.
DONT_CAP_D: ; 0x001C42, $EC42
    CMPD  #$FE00 ; CMP val
    BGT   CAP_NEGATIVE
    LDD   #$FE00 ; D cap negative.
CAP_NEGATIVE: ; 0x001C4B, $EC4B
    STD   16,X ; To XOBJ[16]
    COMA ; Invert
    COMB
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    TFR   A>B ; A to B
    SEX ; Extend from B
    ADDD  16,X ; += XOBJ[16]
    STD   16,X ; D to XOBJ[16]
    LDB   A0DF_RAND_BYTE ; Random 
    ANDB  #$1F ; Keep 0001.1111
    ADDB  #$F0 ; +=F0
    SEX ; Extend to D
    ADDD  16,X ; D += XOBJ[16]
    STD   16,X ; D to XOBJ[16]
    LDD   $A0CC ; D from
    SUBD  10,X ; D -= XOBJ[10]
    ADDD  #$12C0 ; += val
    CMPD  #$2580 ; CMP to val
    BHI   L_001C17 ; >, goto.
    DEC   11,U ; Dec UOBJ[11]
    BNE   SKIP_SUB ; != 0, goto.
    JSR   SUB_IDK ; Do sub
SKIP_SUB: ; 0x001C7E, $EC7E
    LDA   #$03 ; Setup callback.
    LDX   #$EC2A
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
SUB_IDK: ; 0x001C86, $EC86
    PSHS  X ; Save X
    LDD   $A0CC ; D from
    SUBD  10,X ; D -= XOBJ[10]
    EORA  14,X ; Invert on XOBJ[14]
    BMI   SKIP_XOBJ[16]_UPDATE ; Result negative, goto.
    LEAY  X ; Y = XOBJ
    JSR   SPAWNS_SOMETHING_IF_UNDER_20_WITH_6_PAST_JSR
    ANDB  [-1701,U] ; And B with junk?
    BITB  -2,X ; Bit test B with X-2?
    BEQ   SKIP_XOBJ[16]_UPDATE ; If 0, goto.
    LDD   14,Y ; D from YOBJ[14]
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    STD   14,X ; D to XOBJ[14]
    LDD   #$D534 ; D = val
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do IDK
    CLRB ; Clear B
    LDA   SHIP_SCR_POS_XXYY+1 ; Get ship Y pos.
    SUBA  12,X ; A -= XOBJ[12]
    ASRA ; D >> 5
    RORB
    ASRA
    RORB
    ASRA
    RORB
    ASRA
    RORB
    ASRA
    RORB
    STD   16,X ; D to XOBJ[16]
SKIP_XOBJ[16]_UPDATE: ; 0x001CBF, $ECBF
    LDA   R_A10D ; A from addr
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get A
    STA   11,U ; To UOBJ[11]
    PULS  X,PC ; Restore X, RTS
CALLBACK_UNK: ; 0x001CC9, $ECC9
    LDX   7,U ; X from UOBJ[7]
    LEAX  2,X ; X+=2
    CMPX  #$A13A ; Cmp to pool end.
    BLO   DONT_RESET_POOL_PTR ; If lower, in range, dont reset.
    LDX   #$A11A ; Reset X to pool start.
DONT_RESET_POOL_PTR: ; 0x001CD5, $ECD5
    STX   7,U ; X from UOBJ[7]
    LDX   X ; X to X.next
    BEQ   SETUP_ECC9_CALLBACK ; If 0, goto.
    LDD   4,X ; D from XOBJ[4]
    BEQ   SETUP_ECC9_CALLBACK ; If 0, goto.
    LDD   8,X ; D from XOBJ[8]
    CMPD  #$ED70 ; If D _ val
    BNE   SETUP_ECC9_CALLBACK ; != val, goto.
    LDD   2,X ; D from XOBJ[2]
    CMPD  #$F90B ; If D _ val
    BHI   L_001D1E ; >, goto.
    LDA   A0DF_RAND_BYTE ; Get rand
    CMPA  #$08 ; If _ #$08
    BLS   L_001D45 ; <=, goto.
    JSR   A_FROM_B300+(XOBJ[10]>>6) ; Do sub
    ADDA  #$04 ; A += 4
    CMPA  #$E8 ; If _ #$E8
    BLS   CAP_TO_#$E8 ; <=, goto.
    LDA   #$E8 ; A cap
CAP_TO_#$E8: ; 0x001D00, $ED00
    LDB   #$01 ; B =
    CMPA  12,X ; If A _ XOBJ[12]
    BEQ   L_001D0D ; ==, goto.
    BHI   DONT_INVERT_B ; >, goto.
    NEGB ; Invert
DONT_INVERT_B: ; 0x001D09, $ED09
    ADDB  12,X ; B += XOBJ[12]
    STB   12,X ; to XOBJ[12]
L_001D0D: ; 0x001D0D, $ED0D
    LDU   2,X ; U from UOBJ[2]
    LEAU  10,U ; U+=10
    CMPU  #$F90B ; If U _ #$F90B
    BLS   DONT_RESET_U ; <=, goto.
L_001D17: ; 0x001D17, $ED17
    LDU   #$F901 ; Reset addr.
DONT_RESET_U: ; 0x001D1A, $ED1A
    LDB   #$E0 ; B =
    BRA   L_001D4A ; Goto.
L_001D1E: ; 0x001D1E, $ED1E
    LDA   A0DF_RAND_BYTE ; Random
    CMPA  #$08 ; If A _ #$08
    BLS   L_001D17 ; <=, goto.
    BSR   A_FROM_B300+(XOBJ[10]>>6) ; Do
    ADDA  #$0F ; += #$0F
    CMPA  #$E8 ; CMP to val
    BLS   DONT_CAP_VAL
    LDA   #$E8 ; Cap
DONT_CAP_VAL: ; 0x001D2E, $ED2E
    LDB   #$01 ; B =
    CMPA  12,X ; If A _ XOBJ[12]
    BEQ   L_001D3B ; ==, goto.
    BHI   L_001D37 ; >, goto.
    NEGB ; Invert B
L_001D37: ; 0x001D37, $ED37
    ADDB  12,X ; B += XOBJ[12]
    STB   12,X ; B to XOBJ[12]
L_001D3B: ; 0x001D3B, $ED3B
    LDU   2,X ; U from XOBJ[2]
    LEAU  10,U ; U += 10
    CMPU  #$F91F ; If U _ val
    BLS   DONT_RESET_U ; <=, goto.
L_001D45: ; 0x001D45, $ED45
    LDU   #$F915 ; Set to
DONT_RESET_U: ; 0x001D48, $ED48
    LDB   #$20 ; = val
L_001D4A: ; 0x001D4A, $ED4A
    STU   2,X ; U to XOBJ[2]
    SEX ; Extend B to D
    ADDD  10,X ; D += XOBJ[10]
    STD   10,X ; D to XOBJ[10]
SETUP_ECC9_CALLBACK: ; 0x001D51, $ED51
    LDA   #$02
    LDX   #$ECC9
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
A_FROM_B300+(XOBJ[10]>>6): ; 0x001D59, $ED59
    PSHS  X,B ; Save
    LDD   10,X ; D from XOBJ[10]
    LSRA ; D >> 6
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LSRA
    RORB
    LDX   #$B300 ; X =
    LDA   D,X ; A = $B300 + D
    PULS  B,X,PC
L_001D70: ; 0x001D70, $ED70
    LDA   $A0DE ; Load addr
    BEQ   L_001D77 ; If 0, do.
    CLRA ; Clear A?
    PULS  A,B,PC ; Pull a bit.
L_001D77: ; 0x001D77, $ED77
    BSR   L_001DC4 ; Do
    JSR   REMOVE_X_FROM_LISTS_AND+HANDLE_STUFF ; Remove and handle?
    LDD   #$F8D8 ; D =
    STD   2,X ; To XOBJ[2]
    LDD   10,X ; D from XOBJ[10]
    SUBD  #$0040 ; D -= val
    STD   10,X ; To XOBJ[10]
    JSR   L_002C63 ; Do
    LDD   #$D4E4 ; D =
    JMP   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do
    LDU   6,X ; U from XOBJ[6]
    BEQ   L_001D70 ; If 0, goto.
    LDA   $A0DE ; Load from addr
    BEQ   L_001DBF ; If 0, goto.
    LDD   2,U ; D = UOBJ[2]
    CMPD  #$F24C ; If D _ val
    BEQ   CHANGE_U[2]_AND_RTS ; ==, goto.
    LDD   #$D4DA ; D =
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do
    PSHS  X ; Save XOBJ
    LDX   #$EE73 ; X =
    LDA   #$00 ; A =
    JSR   GET_15B_OBJECT+SCHEDULE ; Do
    LEAY  X ; Y = XOBJ
    PULS  X ; Restore previous X
    STX   7,Y ; To YOBJ[7]
CHANGE_U[2]_AND_RTS: ; 0x001DB7, $EDB7
    LDD   #$F24C ; D =
    STD   2,U ; D to UOBJ[2], changing handler?
    CLRA ; Idk why
    PULS  A,B,PC ; RTS
L_001DBF: ; 0x001DBF, $EDBF
    BSR   L_001D77
    JMP   XOBJ[6]_BACK_TO_AVAILABLE_LIST
L_001DC4: ; 0x001DC4, $EDC4
    LEAY  X ; Y = X
    PSHS  U,X,A ; Save
    LDU   #$A11A ; U to pool
    LDA   #$40 ; A =
L_001DCD: ; 0x001DCD, $EDCD
    CMPY  U++ ; If Y _ U++
    BEQ   L_001DD8 ; ==, goto.
    DECA ; A--
    BNE   L_001DCD ; != 0, goto
    JSR   SYSTEM_PANIC ; Do
L_001DD8: ; 0x001DD8, $EDD8
    CLRA ; Clear D
    CLRB
    STD   -2,U ; D to UOBJ[-2]
    DEC   A0FA_HUMANOID_COUNT? ; --
    BNE   RTS+RESTORE ; != 0, RTS
    LDX   #$EDEA ; Callback?
    LDA   #$00 ; Timer
    JSR   GET_15B_OBJECT+SCHEDULE ; Do
RTS+RESTORE: ; 0x001DE8, $EDE8
    PULS  A,X,U,PC ; RTS
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    ORA   #$02 ; Set 0000.0010
    STA   A0BA_PLAYER_GAME_STATE ; Store back
    CLR   7,U ; Clear UOBJ[7]
    JSR   BANKSWITCH_TO_7 ; In rtn 7
    JSR   JMP_TO_CLEAR_LAND_ONSCREEN? ; Do
    LDX   #$B125 ; X ptr
    LDU   #$0000 ; U ptr
    LDA   #$40 ; A =
LOOP_#$40_TIMES: ; 0x001E00, $EE00
    STU   [X++] ; U to @X,++
    DECA ; Loop--
    BNE   LOOP_#$40_TIMES ; != 0, loop
L_001E05: ; 0x001E05, $EE05
    LDX   LIST_23B_UNUSED_OBJS? ; Load list
    LDD   #$F9F1 ; Ptr to code.
    STD   2,X ; D to XOBJ[2]
    LDB   #$02 ; = val
    STB   A073_SCRATCH_LOOP_WORD? ; B to scratch
LOOP_ON_SCRATCH: ; 0x001E10, $EE10
    JSR   RANDOM_VALUE_FWD+IN_A ; Get rand
    ANDA  #$3F ; Keep 0011.1111
    ADDD  R_A020_SCREEN_POS_CHANGE? ; D += addr
    STD   10,X ; To XOBJ[10]
    JSR   A_FROM_B300+(XOBJ[10]>>6) ; Get A
    STA   12,X ; A to XOBJ[12]
    SUBA  #$0A ; A -= #$0A
    JSR   L_002C63 ; Do
    DEC   A073_SCRATCH_LOOP_WORD? ; Dec scratch loop
    BNE   LOOP_ON_SCRATCH ; != 0, goto.
    LDA   A0DF_RAND_BYTE ; Get random
    ANDA  #$1F ; Keep 0001.1111
    LDX   #$E799 ; X ptr to ?
    LDA   A,X ; A from X[A]
    STA   COLOR_PALETTE_RAM_COPY ; To color 10
    LDD   #$D4E4 ; Val
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do
    LDX   #$EE44 ; Callback
    LDA   #$02
SEED+CALLBACK: ; 0x001E3D, $EE3D
    LDB   #$08 ; Seed idk
    STB   $A05E
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Do
    CLR   COLOR_PALETTE_RAM_COPY ; Clear palette val.
    LDA   7,U ; A from UOBJ[7]
    LSRA ; >> 3
    LSRA
    LSRA
    INCA ; A++
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get new
    LDX   #$EE54 ; Callback
    BRA   SEED+CALLBACK ; Set
CALLBACK_RAND_TIMING: ; 0x001E54, $EE54
    INC   7,U ; UOBJ[7]++
    LDA   7,U ; Load it
    CMPA  #$10 ; If A _ #$10
    BNE   L_001E05 ; !=, goto.
    LDD   #$D4C7 ; D ptr to
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do
    JMP   CALLBACK_REMOVE? ; Goto
BOMBER_BLOWN_UP?: ; 0x001E65, $EE65
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Do
    .db $F9
    .db $DD
    .db $ED
    .db $BC
    .db $00
    .db $00
    LDD   #$0125 ; + 250
    BRA   SCORE_ADD ; Goto
CALLBACK_HUMANOID_DOWN?: ; 0x001E73, $EE73
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR
    .db $F9
    .db $E7
    .db $ED
    .db $BC
    .db $00
    .db $00
    LDD   #$0150 ; +500, putting humanoid down?
SCORE_ADD: ; 0x001E7F, $EE7F
    JSR   SCORE_ADD_AB ; Add D to score.
CALLBACK_UNK: ; 0x001E82, $EE82
    LDY   7,U ; Y from UOBJ[7]
    LDD   $A0C7 ; D from
    STD   14,X ; D to XOBJ[14]
    LDD   #$0000 ; Clear D
    STD   16,X ; Clear XOBJ[16]
    LDA   #$11 ; 11
    STA   20,X ; To XOBJ[20]
    LDD   10,Y ; D from YOBJ[10]
    STD   10,X ; To XOBJ[10]
    LDD   12,Y ; D from YOBJ[10]
    BMI   YOBJ[12]_IS_NEGATIVE_SUBS ; If negative, goto.
    ADDD  #$1800 ; += #$1800
    BRA   SKIP_SUB_WAS_POSITIVE ; Goto
YOBJ[12]_IS_NEGATIVE_SUBS: ; 0x001EA1, $EEA1
    SUBD  #$2000
SKIP_SUB_WAS_POSITIVE: ; 0x001EA4, $EEA4
    STD   12,X ; D to XOBJ[12]
    STX   LIST_$65_ON_SCREEN? ; X to list?
    STX   7,U ; X to UOBJ[7]
    LDA   #$32 ; Callback
    LDX   #$EEB2 ; Callback addr
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK ; Setup
    LDX   7,U ; X from UOBJ[7]
    JSR   REMOVE_X_FROM_LISTS_AND+HANDLE_STUFF ; Do 
    JMP   CALLBACK_REMOVE?
SPAWN_SOMETHING_IDK: ; 0x001EBA, $EEBA
    PSHS  X ; Save X obj
    JSR   SPAWNS_SOMETHING_IF_UNDER_20_WITH_6_PAST_JSR ; Do IDK
    ANDB  [-1701,U] ; And B
    BITB  -2,X ; Test B from X-2
    BEQ   RTS ; If 0, goto.
    LDB   A0DF_RAND_BYTE ; Get rand
    ANDB  #$1F ; Get 0001.1111
    ADDB  #$F0 ; += F0
    ADDB  SHIP_SCR_POS_XXYY ; +=
    SUBB  4,X ; B -= X[4]
    SEX ; Extend to D
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    STD   14,X ; D to XOBJ[14]
    LDB   A0DF_RAND_BYTE ; B rand
    CMPB  #$78 ; If B _ #$78
    BLS   B_IS_<=_#$78 ; <=, goto.
    LDD   $A0C7 ; D from
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    ADDD  14,X ; D += XOBJ[14]
    STD   14,X ; D to XOBJ[14]
B_IS_<=_#$78: ; 0x001EE8, $EEE8
    LDB   A0E0_RAND_WORD+1 ; B from rand+1
    ANDB  #$1F ; Keep 0001.1111
    ADDB  #$F0 ; += #$F0
    ADDB  SHIP_SCR_POS_XXYY+1 ; B += SHIP.Y
    SUBB  5,X ; B -= X[5]
    SEX ; Extend to D
    ASLB ; D >> 2
    ROLA
    ASLB
    ROLA
    STD   16,X ; D to XOBJ[16]
    LDA   #$01 ; True
RTS: ; 0x001EFC, $EEFC
    PULS  X,PC
L_001EFE: ; 0x001EFE, $EEFE
    DEC   13,U ; Dec UOBJ[13]
    BNE   RTS
    LDA   R_A105 ; A from addr
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get <= val
    STA   13,U ; To UOBJ[13]
    BSR   SPAWN_SOMETHING_IDK ; Do idk
    BEQ   RTS ; If not successful, rts.
    LDD   #$D525 ; D from
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
RTS: ; 0x001F14, $EF14
    RTS
L_001F15: ; 0x001F15, $EF15
    PSHS  A ; Save A
    STA   A073_SCRATCH_LOOP_WORD? ; Loop counter
LOOP_MAKE_ENEMY_IDK: ; 0x001F19, $EF19
    LDX   #$F15E ; Handler
    LDA   #$00 ; Type
    JSR   GET_15B_OBJECT+SCHEDULE ; Make obj
    LEAU  X ; Obj to U
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Data to it.
    .db $F8
    .db $CE
    .db $EF
    .db $6D
    .db $CC
    .db $33
    JSR   RANDOM_VALUE_FWD+IN_A ; Get random
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load
    SUBD  #$2580 ; Subtract
    STD   $A075 ; Store
    LDD   A0E0_RAND_WORD ; Loasd
    SUBD  $A075 ; Sub
    CMPD  #$4B00 ; Compare to val
    BHS   DONT_ADD_8000
    ADDD  #$8000 ; Add
DONT_ADD_8000: ; 0x001F43, $EF43
    ADDD  $A075 ; Add always
    STD   10,X ; Store to OBJ[10]
    LDA   A0DF_RAND_BYTE ; Random
    LSRA ; Shift
    ADDA  #$2A ; Add
    STA   12,X ; Store to OBJ[12]
    CLRA ; Clear D
    CLRB
    STD   16,X ; Clear OBJ[16]
    STD   14,X ; Clear OBJ[14]
    LDA   R_A10B ; Load val
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get <= val
    STA   7,U ; Store to OBJ[7]
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN? ; Do sub, idfk what it actually does.
    STU   6,X ; Store OBJ U to OBJ[6]@X
    STX   7,U ; Store OBJ X to OBJ[7]@U
    INC   R_A115_ENEMY_IDK_COUNT ; Inc enemy count
    DEC   A073_SCRATCH_LOOP_WORD?
    BNE   LOOP_MAKE_ENEMY_IDK
    PULS  A,PC
    DEC   R_A115_ENEMY_IDK_COUNT
    JSR   REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST
    .db $01 ; illegal instx2, 1 byte each
    .db $15
    ANDB  $A0F8
    RTS
NOT_RAN_IF_NO_HUMANOIDS?: ; 0x001F78, $EF78
    PSHS  X ; Save
    LDA   A0FA_HUMANOID_COUNT? ; Get count
    BEQ   RTS ; If 0, RTS.
    LDX   $A09B ; X from val
LOOP_X+=2: ; 0x001F80, $EF80
    LEAX  2,X ; +=2
    CMPX  #$A15A ; Compare to
    BLO   DONT_RESET
    LDX   #$A11A ; Reset
DONT_RESET: ; 0x001F8A, $EF8A
    LDD   X ; Load from
    BNE   A09B_UPDATED,WRITE_OBJ_[9]_[11] ; !=0, goto
    CMPX  $A09B ; X _ ADDR
    BNE   LOOP_X+=2 ; !=, goto.
    PULS  X,PC ; RTS
A09B_UPDATED,WRITE_OBJ_[9]_[11]: ; 0x001F94, $EF94
    STX   $A09B ; X to addr
    STD   9,U ; D to UOBJ[9]
    STX   11,U ; X to UOBJ[11]
RTS: ; 0x001F9A, $EF9A
    PULS  X,PC ; RTS
IDK_BUT_HUMANOIDS_MATTER: ; 0x001F9C, $EF9C
    PSHS  A ; Save A
    STA   A073_SCRATCH_LOOP_WORD? ; Again
LOOP_IDK: ; 0x001FA0, $EFA0
    TST   A0FA_HUMANOID_COUNT? ; Test humanoids
    BNE   HUMANOIDS_NOT_ZERO ; If has any
    JMP   LOOP_MAKE_ENEMY_IDK ; Makes IDK
HUMANOIDS_NOT_ZERO: ; 0x001FA7, $EFA7
    LDX   #$EFF6 ; Handler
    LDA   #$00 ; Timer
    JSR   GET_15B_OBJECT+SCHEDULE ; Setup
    LEAU  X ; Obj X to U
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Fill out info past.
    .db $F9
    .db $85
    .db $F2
    .db $0B
    .db $44
    .db $33
    JSR   RANDOM_VALUE_FWD+IN_A ; Random value
    LDD   A0E0_RAND_WORD ; Random word
    STD   10,X ; to OBJ[10]
    LDA   #$2C ; Val
    STA   12,X ; to OBJ[10]
    LDD   R_A103 ; Val
    STD   16,X ; to OBJ[16]
    LDA   R_A105 ; Val
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Manipulate
    STA   13,U ; OBJ[13]. Are X and U the same?
    LDA   R_A102 ; Val
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Manip
    TFR   A>B ; To B
    CLRA ; Clear
    BITB  #$01 ; Test not
    BEQ   DONT_NEGATE_TO_NEGATIVE
    COMB ; Invert
    COMA
DONT_NEGATE_TO_NEGATIVE: ; 0x001FE2, $EFE2
    STD   14,X ; To OBJ[14]
    STU   6,X ; U to XOBJ[6]
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN? ; Needs figured more.
    STX   7,U ; X to UOBJ[7]
    BSR   NOT_RAN_IF_NO_HUMANOIDS? ; Idk
    INC   R_A112_ENEMY_IDK_COUNT ; Inc count
    DEC   A073_SCRATCH_LOOP_WORD? ; Loop count
    BNE   LOOP_IDK
    PULS  A,PC ; RTS
HANDLER_IDK: ; 0x001FF6, $EFF6
    LDX   7,U ; X from UOBJ[7]
    LDY   9,U ; Y from UOBJ[9]
    LDD   [11,U] ; D from UOBJ[11] ptr
    BEQ   L_002016 ; If 0, goto.
    LDA   9,Y ; A = YOBJ[9]
    CMPA  #$70 ; if _ #$70
    BNE   L_002016 ; !=, goto.
    LDA   10,X ; A from XOBJ[10]
    ANDA  #$FC ; Keep 1111.1100
    STA   A073_SCRATCH_LOOP_WORD? ; To scratch
    LDA   10,Y ; A from YOBJ[10]
    ANDA  #$FC ; Keep 1111.1100
    CMPA  A073_SCRATCH_LOOP_WORD? ; If _ to other val
    BEQ   CALLBACK_IDK? ; ==, goto.
    BRA   L_002025 ; Otherwise, goto.
L_002016: ; 0x002016, $F016
    LDA   20,X ; A from XOBJ[20]
    ANDA  #$FE ; Keep 1111.1110
    STA   20,X ; To XOBJ[20]
    JSR   NOT_RAN_IF_NO_HUMANOIDS? ; Do
    LBEQ  CALLBACK_INIT ; If 0 ret, goto.
L_002025: ; 0x002025, $F025
    JSR   A_FROM_B300+(XOBJ[10]>>6) ; Get A
    SUBA  #$32 ; -= val
    SUBA  12,X ; -= XOBJ[12]
    BHI   L_00203D ; > signed, goto.
    CMPA  #$EC ; If A _ #$EC
    BLT   INVERT_D_FROM_A103_AND_GOTO_IDK ; <, goto.
    CLRA ; CLRD
    CLRB
    BRA   D_COMMIT_TO_XOBJ[16] ; Goto
INVERT_D_FROM_A103_AND_GOTO_IDK: ; 0x002036, $F036
    LDD   R_A103 ; D from
    COMA ; Invert
    COMB
    BRA   D_COMMIT_TO_XOBJ[16] ; Goto
L_00203D: ; 0x00203D, $F03D
    LDD   R_A103 ; D from
D_COMMIT_TO_XOBJ[16]: ; 0x002040, $F040
    STD   16,X ; D to XOBJ[16]
    LDD   2,X ; D from XOBJ[2]
    CMPD  #$F8EC ; If callback is?
    BEQ   L_00205D ; ==, goto.
    JSR   L_001EFE ; Do
    LDU   2,X ; U = X+2
    LEAU  10,U ; U += 10
    CMPU  #$F999 ; If U _ #$F999
    BLS   DONT_RESET_U ; <=, goto.
    LDU   #$F985 ; U to val
DONT_RESET_U: ; 0x00205B, $F05B
    STU   2,X ; U to XOBJ[2]
L_00205D: ; 0x00205D, $F05D
    LDA   #$06 ; Callback
    LDX   #$EFF6
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_IDK?: ; 0x002065, $F065
    CLRA ; CLRD
    CLRB
    INC   20,X ; XOBJ[20]++
    STD   14,X ; Clear XOBJ[14]
    STD   16,X ; Clear XOBJ[16]
    LDD   #$F985 ; D =
    STD   2,X ; D to XOBJ[2]
    LDX   7,U ; X to UOBJ[7]
    LDY   9,U ; Y = UOBJ[9]
    LDD   [11,U] ; D from UOBJ[11] ptr
    BEQ   L_002016 ; If 0, goto.
    LDA   9,Y ; A from YOBJ[9]
    CMPA  #$70 ; If A _ #$70
    BNE   L_002016 ; !=, goto.
    LDD   10,Y ; D from YOBJ[10]
    ANDB  #$E0 ; Keep 1110.0000
    STD   $A075 ; D to addr
    LDD   10,X ; D from XOBJ[10]
    ANDB  #$E0 ; Keep 1110.0000
    CMPD  $A075 ; If D _ addr
    BEQ   L_0020A0 ; ==, goto.
    BLT   L_002099 ; <, goto.
    LDB   #$E0 ; Seed FFE0
    BRA   L_00209B ; Goto
L_002099: ; 0x002099, $F099
    LDB   #$20 ; Seed 0020
L_00209B: ; 0x00209B, $F09B
    SEX ; Extend to D
    ADDD  10,X ; D += XOBJ[10]
    STD   10,X ; Back to XOBJ[10]
L_0020A0: ; 0x0020A0, $F0A0
    LDA   12,Y ; A from YOBJ[12]
    SUBA  #$0C ; -= #$0C
    CMPA  12,X ; CMP XOBJ[12]
    BEQ   L_0020BE ; ==, goto.
    LDD   R_A103 ; D from reg
    BHS   DONT_INVERT_D ; If cond, goto.
    COMA ; Invert D
    COMB
DONT_INVERT_D: ; 0x0020AF, $F0AF
    ADDD  12,X ; D += XOBJ[12]
    STD   12,X ; D += XOBJ[12]
L_0020B3: ; 0x0020B3, $F0B3
    JSR   L_001EFE ; Do sub
    LDA   #$01 ; Callback.
    LDX   #$F074
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
L_0020BE: ; 0x0020BE, $F0BE
    LDD   10,X ; D from XOBJ[10]
    ADDD  #$0040 ; +=
    SUBD  10,Y ; D -= YOBJ[10]
    CMPD  #$0080 ; If D _ val
    BHI   L_0020B3 ; >, goto.
    LDD   #$F1E0 ; D = ptr to code.
    STD   8,X ; To XOBJ[8]
    LDD   R_A103 ; D from
    COMB ; Invert
    COMA
    STD   16,X ; To XOBJ[16]
    STD   16,Y ; To YOBJ[16]
    LDD   #$D50C ; D ptr to idk
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do
    LDD   #$ED91 ; D ptr
    STD   8,Y ; To YOBJ[8]
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Load ptr to others
    LDX   7,U ; X from UOBJ[7]
    LDA   12,X ; A from XOBJ[12]
    CMPA  #$32 ; If A _ #$32
    BLS   L_0020FB ; <=, goto.
    JSR   L_001EFE ; Do
    LDA   #$04 ; Callback setup.
    LDX   #$F0E6
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
L_0020FB: ; 0x0020FB, $F0FB
    LDD   #$D511 ; Idk
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
    LDX   7,U ; X from UOBJ[7]
    LDY   9,U ; Y from UOBJ[9]
    LDD   [11,U] ; D from UOBJ[11] ptr. Humanoid ptr?
    BNE   L_002116
    JSR   REMOVE_X_FROM_LISTS_AND+HANDLE_STUFF
    DEC   R_A112_ENEMY_IDK_COUNT ; One less lander?
    INC   R_A0FB_ENEMY_IDK_COUNT ; One more mutant?
    JMP   CALLBACK_REMOVE? ; Do
L_002116: ; 0x002116, $F116
    CLRA ; Clear D
    CLRB
    STD   16,X ; Clear XOBJ[16]
    STD   16,Y ; Clear YOBJ[16]
    LDA   12,Y ; A from YOBJ[12]
    CMPA  12,X ; A _ XOBJ[12]
    BLS   L_002133 ; <=, goto.
    DEC   12,Y ; YOBJ[12]--
    LDA   #$12 ; Sound?
    JSR   WRITE_ROM_PIA_DATA_REGS_W/_#$3F_AND_B_SOUND?
    LDA   #$01 ; Callback.
    LDX   #$F101
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
L_002133: ; 0x002133, $F133
    LEAX  Y ; X = Y obj
    LDD   4,Y ; D from YOBJ[4]
    ADDA  #$01 ; A++
    STD   $A0F8 ; D to addr
    JSR   L_001D77 ; Do
CALLBACK_INIT: ; 0x00213E, $F13E
    DEC   R_A112_ENEMY_IDK_COUNT ; #--
    INC   R_A115_ENEMY_IDK_COUNT ; #++
    LDX   7,U ; X from UOBJ[7]
    CLR   20,X ; Clear XOBJ[20]
    LDD   #$F8CE ; Callback ptr?
    STD   2,X ; To XOBJ[2]
    LDD   #$CC33 ; Ptr to XOBJ[18]
    STD   18,X
    LDD   #$EF6D ; Other ptr to XOBJ[8]
    STD   8,X
    LDA   R_A10B ; Addr to UOBJ[9]
    STA   9,U
CALLBACK_ENTRY_LOC: ; 0x00215E, $F15E
    LDX   7,U ; X from YOBJ[U]
    LDB   R_A10A ; B from addr
    LDY   $A0CC ; Y from addr
    CMPY  10,X ; CMPY to XOBJ[10]
    BGE   DONT_INVERT_B ; >=, goto.
    NEGB
DONT_INVERT_B: ; 0x00216C, $F16C
    SEX ; Extend to D
    STD   14,X ; To XOBJ[14]
    LDD   $A0CC ; D from addr
    SUBD  10,X ; D -= XOBJ[10]
    ADDD  #$017C ; += val
    CMPD  #$0700 ; CMP to val
    BLS   D_LTE_TO_0700 ; <=, goto.
    LDA   SHIP_SCR_POS_XXYY+1 ; A from ship Y
    SUBA  12,X ; -= XOBJ[12]
    BLS   L_00218D ; sub'd <= val, goto.
    CMPA  #$08 ; CMP to val
    BHI   CLEAR_D ; >, goto.
    LDD   R_A108 ; D from
    COMA ; Invert
    COMB
    BRA   COMMIT_D_TO_XOBJ[16] ; Goto
L_00218D: ; 0x00218D, $F18D
    CMPA  #$F8 ; If A _ #$F8
    BGT   D_FROM_R_A108_TO_XOBJ[16] ; >, goto.
CLEAR_D: ; 0x002191, $F191
    CLRA ; Clear D
    CLRB
    BRA   COMMIT_D_TO_XOBJ[16] ; Commit
D_FROM_R_A108_TO_XOBJ[16]: ; 0x002195, $F195
    LDD   R_A108 ; Commit this value
COMMIT_D_TO_XOBJ[16]: ; 0x002198, $F198
    STD   16,X ; To XOBJ[16]
    BRA   L_0021AF ; Goto
D_LTE_TO_0700: ; 0x00219D, $F19D
    LDA   SHIP_SCR_POS_XXYY+1 ; A from ship Y
    CMPA  12,X ; CMP to XOBJ[12]
    LDD   R_A108 ; D seed.
    BHS   DONT_INVERT_D ; A >= val, goto.
    COMA
    COMB
DONT_INVERT_D: ; 0x0021A8, $F1A8
    STD   16,X ; D to XOBJ[16]
    LDD   4,X ; D from XOBJ[4]
    BEQ   SETUP_CALLBACK ; If 0, goto.
L_0021AF: ; 0x0021AF, $F1AF
    LDB   R_A107 ; B from
    LDA   A0DF_RAND_BYTE ; Get rand
    BMI   B_IS_NEG ; If random is negaive, goto.
    NEGB ; Make negative.
B_IS_NEG: ; 0x0021B7, $F1B7
    ADDB  12,X ; B += XOBJ[12]
    CMPB  #$2A ; If B _ #$2A
    BHS   L_0021BF ; >=, goto.
    LDB   #$F0 ; Roll?
L_0021BF: ; 0x0021BF, $F1BF
    STB   12,X ; To XOBJ[12]
    DEC   9,U ; UOBJ[9]--
    BNE   SETUP_CALLBACK ; Not 0, goto.
    LDA   R_A10B ; A from
    JSR   GET_NEW_A_THAT_IS_<=_CURRENT ; Get new
    STA   9,U ; Store to UOBJ[9]
    JSR   SPAWN_SOMETHING_IDK
    BEQ   SETUP_CALLBACK ; Was successful, do.
    LDD   #$D52A ; D val...
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
SETUP_CALLBACK: ; 0x0021D8, $F1D8
    LDA   #$03 ; Setup callback.
    LDX   #$F15E
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    LDU   6,X ; U from XOBJ[6]
    LDD   [11,U] ; D from UOBJ[11] ptr
    BEQ   LOADED_ZERO ; If 0, goto.
    LDD   #$0000 ; D = 0
    LDD   #$0000 ; D = 0, again.
    PSHS  X ; Save X
    LDX   #$F216 ; Code
    LDA   #$00 ; Callback
    JSR   GET_15B_OBJECT+SCHEDULE ; Setup for this rtn
    LDU   9,U ; U from UOBJ[9]
    STU   7,X ; To XOBJ[7]
    LDD   #$D4E9 ; D val?
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
    LDD   #$0000 ; D = 0, again.
    STD   16,U ; Clear UOBJ[16]
    STX   6,U ; X to UOBJ[16]
    PULS  X ; Get X obj
LOADED_ZERO: ; 0x00220B, $F20B
    DEC   R_A112_ENEMY_IDK_COUNT ; -- enemy count.
    JSR   REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST ; Do
    .db $01 ; Score of 150
    .db $15
    .db $D5 ; Sound
    .db $07
    RTS ; Leave?
    LDX   7,U ; X from UOBJ[7]
    LDD   #$0008 ; D =
    ADDD  16,X ; D += XOBJ[16]
    CMPD  #$0300 ; Cap val
    BHS   DONT_STORE_D ; If D >= val, goto.
    STD   16,X ; Store D otherwise.
DONT_STORE_D: ; 0x002227, $F227
    JSR   A_FROM_B300+(XOBJ[10]>>6) ; Get A
    CMPA  12,X ; If A _ XOBJ[12]
    BHI   SETUP_CALLBACK_F216 ; >, goto.
    LDD   16,X ; D from XOBJ[16]
    CMPD  #$00E0 ; If D _ val
    BLS   HUMANOID_LANDED? ; <=, goto.
    LDD   4,X ; D from XOBJ[4]
    ADDD  #$0107 ; D += val
    STD   $A0F8 ; D to addr
    JSR   L_001D77 ; Do
    JMP   CALLBACK_REMOVE? ; Kill callback I think.
SETUP_CALLBACK_F216: ; 0x002244, $F244
    LDA   #$04
    LDX   #$F216
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_IDK: ; 0x00224C, $F24C
    LDX   7,U ; X from UOBJ[7]
    LDD   #$0000 ; Clear XOBJ[16]
    STD   16,X
    LDA   PLAYER.VPOS ; Gedt VPOS
    ADDA  #$0A ; += VAL
    STA   12,X ; To XOBJ[12]
    LDD   $A0CC ; D from
    ADDD  #$0080 ; += val
    STD   10,X ; To XOBJ[10]
    JSR   A_FROM_B300+(XOBJ[10]>>6) ; Get A
    CMPA  12,X ; If A _ XOBJ[12]
    BLO   HUMANOID_SET_DOWN? ; <, goto.
    LDA   #$01 ; Setup callback.
    LDX   #$F24C
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
HUMANOID_LANDED?: ; 0x002270, $F270
    PSHS  X ; Save X obj
    LDX   #$EE65 ; Ptr to code, humanoid falling to ground?
    BRA   SKIP_OTHER_LOAD
HUMANOID_SET_DOWN?: ; 0x002277, $F277
    PSHS  X ; Save X obj
    LDX   #$EE73 ; Ptr to humanoid down?
SKIP_OTHER_LOAD: ; 0x00227C, $F27C
    LDA   #$00 ; Callback counter?
    JSR   GET_15B_OBJECT+SCHEDULE ; Get callback?
    LEAY  X ; Y = X obj
    PULS  X ; Recove X obj
    STX   7,Y ; X to YOBJ[7]
    LDD   #$0000 ; Clear
    STD   6,X ; XOBJ[6]
    STD   16,X ; XOBJ[16]
    LDD   #$ED70 ; Ptr to code
    STD   8,X ; Callback of some type.
    LDD   #$D4DF ; Sound
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Do sound.
    JMP   CALLBACK_REMOVE? ; Handled.
L_00229D: ; 0x00229D, $F29D
    STA   A073_SCRATCH_LOOP_WORD? ; A to scratch.
    LDB   R_A106 ; B from register.
    COM   $A0AA ; Invert addr.
    BMI   DONT_INVERT_B ; If addr now minus, goto.
    NEGB ; Invert B
DONT_INVERT_B: ; 0x0022A7, $F2A7
    STB   A073_SCRATCH_LOOP_WORD?+1 ; B to scratch+1
    LDX   #$F2F7 ; Handler
    LDA   #$00 ; Count
    JSR   GET_OBJ_23B+INIT ; Get obj
    LEAU  X ; U is new obj
    LDA   A073_SCRATCH_LOOP_WORD? ; A from scratch
    STA   15,U ; To UOBJ[15]
    CLRA ; Clear D
    CLRB
    STD   7,U ; Clear UOBJ[7] to UOBJ[14]
    STD   9,U
    STD   11,U
    STD   13,U
MORE_NEW_OBJS: ; 0x0022C1, $F2C1
    JSR   FILL_OUT_NEW_OBJ_IN_X_WITH_DATA[6]_PAST_JSR ; Fill with info.
    .db $F9
    .db $29
    .db $F3
    .db $BC
    .db $88
    .db $88
    LDB   A073_SCRATCH_LOOP_WORD?+1 ; B from scratch
    SEX ; Extend to D
    STD   14,X ; To XOBJ[14]
    CLRA
    CLRB
    STD   16,X ; Clear XOBJ[16]
    LDA   A073_SCRATCH_LOOP_WORD? ; A from scratch
    LSRA ; D >> 1
    RORB
    ADDA  A073_SCRATCH_LOOP_WORD? ; A +=
    ADDD  $A0CC ; D += addr
    ADDA  #$80 ; A += #$80?
    STD   10,X ; D to XOBJ[10]
    LDA   #$50 ; Val
    STA   12,X ; to XOBJ[12]
    STA   16,U ; And XOBJ[16]
    STU   6,X ; U to XOBJ[6]
    STX   LIST_$65_ON_SCREEN? ; X now list head?
    LDA   A073_SCRATCH_LOOP_WORD? ; A from scratch
    ASLA ; A << 1, *2 is reason here?
    ADDA  #$05 ; += 5
    STX   A,U ; X to UOBJ[A]...
    DEC   A073_SCRATCH_LOOP_WORD? ; Scratch--
    BNE   MORE_NEW_OBJS
    RTS ; Leave when all made.
    LDA   A0DF_RAND_BYTE ; Get random
    ANDA  #$06 ; Keep 0000.1010
    ADDA  #$07 ; += 7
    LDX   A,U ; X from UOBJ[A]
    LBEQ  SETUP_CALLBACK ; If 0, goto.
    LDB   A0DF_RAND_BYTE ; Get random
    LDA   #$0A ; A = val
    ANDB  #$3F ; B keep 0011.1111
    ADDB  #$E0 ; += #$E0
    BMI   DONT_INVERT_A ; If negative, goto.
    NEGA ; Invert A
DONT_INVERT_A: ; 0x00230E, $F30E
    LDY   2,X ; Y from XOBJ[2]
    LEAY  A,Y ; Y += A
    CMPY  #$F929 ; If Y _ val
    BHS   DONT_LOWER_Y ; >=, goto.
    LDY   #$F929 ; Y =
DONT_LOWER_Y: ; 0x00231D, $F31D
    CMPY  #$F947 ; If Y _ val
    BLS   DONT_RAISE_Y ; <=, goto.
    LDY   #$F947
DONT_RAISE_Y: ; 0x002327, $F327
    STY   2,X ; Y to XOBJ[2]
    SEX ; Extend B
    ADDD  16,X ; D += XOBJ[16]
    STD   16,X ; D to XOBJ[16]
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    TFR   A>B ; A to B
    NEGB ; Invert B
    SEX ; Extend B
    ADDD  16,X ; D += XOBJ[16]
    STD   16,X ; D to XOBJ[16]
    LDA   5,X ; A from XOBJ[5]
    BNE   L_002380 ; Not 0, goto.
    LDA   A0DF_RAND_BYTE ; Get rand
    CMPA  #$40 ; If _ #$40
    BHI   L_002361 ; >, goto.
    ANDA  #$03 ; Get 0000.0011
    ADDA  #$FE ; += #$FE
    ADDA  16,U ; A += UOBJ[16]
    CMPA  #$40 ; If A _ #$40
    BHS   DONT_RAISE_A_TO_#$40 ; Use A as-is.
    LDA   #$40 ; A =
DONT_RAISE_A_TO_#$40: ; 0x002358, $F358
    CMPA  #$68 ; If A _ val
    BLO   DONT_LOWER_A_TO_#$68 ; <, goto.
    LDA   #$68 ; A =
DONT_LOWER_A_TO_#$68: ; 0x00235E, $F35E
    STA   16,U ; A to UOBJ[16]
L_002361: ; 0x002361, $F361
    LDA   16,U ; Load UOBJ[16]
    SUBA  12,X ; -= XOBJ[12]
    ADDA  #$10 ; A +=
    CMPA  #$20 ; If A _ val
    BLS   SETUP_CALLBACK ; <=, goto.
    SUBA  #$10 ; A -= 10
    BMI   LOAD_D_WITH_#$0010 ; If negative, goto.
    LDD   #$FFF0 ; D =
    BRA   L_002378
LOAD_D_WITH_#$0010: ; 0x002375, $F375
    LDD   #$0010 ; D =
L_002378: ; 0x002378, $F378
    ADDD  16,X ; D += XOBJ[16]
    STD   16,X ; D to XOBJ[16]
    BRA   SETUP_CALLBACK ; Callback.
L_002380: ; 0x002380, $F380
    SUBA  SHIP_SCR_POS_XXYY+1 ; A -= SHIP.Y
    BMI   SKIP_EARLY_CHECKS ; If negative, goto.
    CMPA  #$20 ; If A _ val
    BLO   L_00238D ; <, goto.
    LDD   #$FFF0 ; Going up?
    BRA   D_ADDED_TO_XOBJ[16]
L_00238D: ; 0x00238D, $F38D
    CMPA  #$10 ; If A _ #$10
    BHI   DONT_ADD_D_TO_XOBJ[16] ; >, goto.
    LDD   #$0010 ; Going down?
    BRA   D_ADDED_TO_XOBJ[16]
SKIP_EARLY_CHECKS: ; 0x002396, $F396
    CMPA  #$E0 ; If A _ val
    BGT   L_00239F ; >, goto.
    LDD   #$0010 ; Going down?
    BRA   D_ADDED_TO_XOBJ[16]
L_00239F: ; 0x00239F, $F39F
    CMPA  #$F0 ; If A _ val
    BLT   DONT_ADD_D_TO_XOBJ[16] ; <, goto.
    LDD   #$FFF0 ; Going up?
D_ADDED_TO_XOBJ[16]: ; 0x0023A6, $F3A6
    ADDD  16,X ; D += XOBJ[16]
    STD   16,X ; To XOBJ[16]
DONT_ADD_D_TO_XOBJ[16]: ; 0x0023AC, $F3AC
    LDA   A0E0_RAND_WORD+1 ; Get rand
    ANDA  #$07 ; Get bottom bits.
    BNE   SETUP_CALLBACK ; 1 in 8 chance of skipping sub.
    BSR   MAKE_BULLET_IF_SLOTS_AVAILABLE? ; If 0, runs. Makes bullet?
SETUP_CALLBACK: ; 0x0023B4, $F3B4
    LDA   #$01 ; Setup callback.
    LDX   #$F2F7
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    JSR   REMOVE_XOBJ_FROM_LISTS_A065|A06B_AND_SCORE+SOUND_FROM_4B_PAST_JSR ; Score+Sound
    .db $01 ; +250
    .db $25
    .db $D5 ; Sound
    .db $02
    DEC   R_A113_ENEMY_IDK_COUNT ; Dec count
    LDU   6,X ; U from XOBJ[6]
    LEAY  7,U ; Y = U+7
FIND_X=*Y: ; 0x0023CA, $F3CA
    CMPX  Y++ ; CMPX Y
    BNE   FIND_X=*Y
    CLRA ; Clear D
    CLRB
    STD   -2,Y ; D to Y-2
    DEC   15,U ; Dec UOBJ[15]
    BNE   RTS ; Not 0, RTS.
    LEAX  U ; X = U
    JSR   XOBJ_BACK_TO_AVAILABLE_LIST ; Remove/to other.
RTS: ; 0x0023DB, $F3DB
    RTS
MAKE_BULLET_IF_SLOTS_AVAILABLE?: ; 0x0023DC, $F3DC
    LDA   ENEMY_UNK_SPAWNED?BULLET?
    CMPA  #$0A
L_0023E0: ; 0x0023E0, $F3E0
    BHS   RTS ; Don't spawn bullet?
    JSR   SPAWNS_SOMETHING_IF_UNDER_20_WITH_6_PAST_JSR
    .db $E4
    .db $98
    .db $F9
    .db $5B
    .db $E5
    .db $1E
    BEQ   RTS ; If nothing spawned, RTS.
    LDB   A0E0_RAND_WORD ; Otherwise, do this. Random speed?
    SEX
    ASLB
    ROLA
    LDA   A0DF_RAND_BYTE
    ANDA  #$1F
    INCA
    STA   21,X
RTS: ; 0x0023FA, $F3FA
    RTS
REMOVE_X_FROM_LISTS_AND+HANDLE_STUFF: ; 0x0023FB, $F3FB
    JSR   REMOVE_X_FROM_LIST_A065|A06B
HANDLER_IN_BANK_2/XOBJ[8]: ; 0x0023FE, $F3FE
    PSHS  U,Y,X,B,A ; Save
    JSR   BANKSWITCH_TO_2 ; Switch to bank 2
    LDD   4,X ; D from OBJ[4]
    LDY   2,X ; Y from OBJ[2]
    JSR   [8,Y] ; JSR to ADDR at Y+8
    PULS  A,B,X,Y,U,PC ; RTS+Restore
    PSHS  X
    JSR   XOBJ[6]_BACK_TO_AVAILABLE_LIST
    PULS  X
    BRA   ADD_TO_SCORE+SOUND_FROM_4_BYTES_PAST
REMOVE_XOBJ_FROM_ACTIVE?_AND_SCORE+SCORE/SND_FROM_4_BYTES_PAST: ; 0x002416, $F416
    PSHS  X ; Save obj ptr
    JSR   XOBJ[6]_BACK_TO_AVAILABLE_LIST ; Remove it
    PULS  X ; Restore obj ptr
REMOVE_XOBJ_FROM_LISTS_A065|A06B_AND_SCORE+SOUND_FROM_4B_PAST_JSR: ; 0x00241D, $F41D
    JSR   REMOVE_X_FROM_LIST_A065|A06B ; IDK what this list is.
ADD_TO_SCORE+SOUND_FROM_4_BYTES_PAST: ; 0x002420, $F420
    PSHS  U,B,A
    LDU   4,S ; U from S[4], aka addr that called us.
    PULU  A,B ; Pull add from first 2 bytes past JSR.
    JSR   SCORE_ADD_AB ; Add val pulled. Generic rtn this is?
    BSR   L_002434 ; Particle effects setup?
    PULU  A,B ; Pull sound from 2nd bytes past JSR.
    STU   4,S ; Code position to RTS to.
    JSR   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET? ; Set sound data
    PULS  A,B,U,PC ; RTS
L_002434: ; 0x002434, $F434
    PSHS  U,Y,X,B,A ; Save
    BSR   HANDLER_IN_BANK_2/XOBJ[8] ; Idk why
    JSR   L_002C63
    PULS  A,B,X,Y,U,PC
CALLBACK_PALETTE_CHANGE: ; 0x00243D, $F43D
    LDX   #$F45B ; Palette ptr
RESETUP_CALLBACK_CONTINUED: ; 0x002440, $F440
    STX   7,U ; To UOBJ[7]
    LDA   #$06 ; Setup callback
    LDX   #$F44A
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_UNK_P2: ; 0x00244A, $F44A
    LDX   7,U ; X from UOBJ[7]
    LDD   X++ ; D from X++
    STD   COLOR_PALETTE_RAM_COPY+13
    LDA   X+
    STA   COLOR_PALETTE_RAM_COPY+15
    CMPX  #$F464 ; End ptr.
    BLO   RESETUP_CALLBACK_CONTINUED ; Store ptr as-is.
    BRA   CALLBACK_PALETTE_CHANGE ; Reset ptr
PALETTE_DATA_UNK: ; 0x00245B, $F45B
    .db $81 ; R=3/7,G=0/7,B=1/3, Red-y?
    .db $81
    .db $2F ; R=1/7,G=3/7,B=3/7, Yellow?
    .db $81
    .db $2F
    .db $07 ; R=0/7,G=1/7,B=3/3, Purple?
    .db $2F
    .db $81
    .db $07
CALLBACK_WHITE+BLACK_TO_PALETTE: ; 0x002464, $F464
    LDA   #$FF ; White
    STA   COLOR_PALETTE_RAM_COPY+10
CALLBACK_CLEAR_AND_RANDOM?: ; 0x002468, $F468
    CLR   COLOR_PALETTE_RAM_COPY+12 ; Clear
    LDA   #$03 ; Setup callback.
    LDX   #$F472
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    LDA   A0DF_RAND_BYTE ; Random
    ANDA  #$1F ; Range 0 to 1F
    LDX   #$E799 ; Color rotation table.
    LDA   A,X ; Get A from X+A
    STA   COLOR_PALETTE_RAM_COPY+10 ; Store to palette.
    STA   COLOR_PALETTE_RAM_COPY+12
    LDX   #$CCB0 ; Idk val
    CMPX  RANDOM_PALETTE_ROTATION_DEFENDER_LOGO? ; If X _ addr
    BNE   DONT_SWAP_PTR ; !=, use ptr as-is.
    LDX   #$CCBC ; Swap val otherwise.
DONT_SWAP_PTR: ; 0x002489, $F489
    STX   RANDOM_PALETTE_ROTATION_DEFENDER_LOGO? ; Store to
    LDA   #$06 ; Schedule above.
    LDX   #$F464
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_UNK: ; 0x002493, $F493
    LDA   R_A08A_UPDATE_SCORE_FLAG?SCORE_CURRENT? ; Load addr
    BNE   REMOVE_OBJ_END? ; Not 0, goto.
    LDX   #$0F1C ; P1_SCORE_LOC
    LDA   A08B_CURRENT_PLAYER
    DECA
    BEQ   L_0024A2
    LDX   #$711C ; P2_SCORE_LOC
L_0024A2: ; 0x0024A2, $F4A2
    LDD   #$1808 ; Clear WWHH
    JSR   CLEAR_SCREEN_FLEX_SETUP ; Clear
    LDA   #$08 ; Callback
    LDX   #$F4B0
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
    JSR   CURRENT_PLAYER_SCORE_TO_SCREEN ; Put score to screen.
    LDA   #$0C
    LDX   #$F493
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
REMOVE_OBJ_END?: ; 0x0024BB, $F4BB
    JMP   CALLBACK_REMOVE?
SCHEDULE_BANKED_CALLBACK_IN_CURRENT: ; 0x0024BE, $F4BE
    LDU   R_A063_CALLBACK_LIST_ADDR? ; Ptr from here
    STX   13,U ; X to OBJ[13], banked callback.
    LDB   CURRENT_BANK ; Bank to OBJ[12]
    STB   12,U
    LDX   #$F4CC ; Callback for bank specifically.
    JMP   SET_UP_CALLBACK_IN_CURRENT_CALLBACK
CALLBACK_HANDLER_BANKED: ; 0x0024CC, $F4CC
    LDA   12,U ; Load bank
    BSR   BANKSWITCH_TO_A ; switch to bank
    JMP   [13,U] ; JMP to OBJ[13]
GOTO_PAST_JSR: ; 0x0024D3, $F4D3
    LEAS  -3,S ; Save 3 bytes of stack. FORMAT: [ptr,bank]
    PSHS  U,A ; STACK S 0:A 2:U 3-5:RSV 6:RTS
    LDA   CURRENT_BANK ; Get current bank.
    STA   5,S ; Save bank up stack.
    LDU   6,S ; Pull location from.
    LDA   2,U ; Pull bank going to into A.
    LDU   U ; Get ptr past JSR.
    STU   3,S ; Save on stack.
    BSR   BANKSWITCH_TO_A ; Goto bank past JSR.
    PULS  A,U ; Pull saved.
    JSR   [S] ; JSR to location past original JSR.
    PSHS  U,A ; Save new info.
    LDA   5,S ; Load bank from up stack.
    BSR   BANKSWITCH_TO_A ; Switch back to it.
    LDU   6,S ; Load location from.
    LEAU  3,U ; Add 3 to skip data.
    STU   6,S ; Store new RTS location.
    PULS  A,U ; Pull saved.
    LEAS  3,S ; Unreserve stack.
    RTS ; RTS
GOTO_B7-C000: ; 0x0024FA, $F4FA
    BSR   BANKSWITCH_TO_7
    JMP   JMP_TO_DRAW_LAND?
BANKSWITCH_TO_7: ; 0x0024FF, $F4FF
    LDA   #$07
    BRA   BANKSWITCH_TO_A
BANKSWITCH_TO_2: ; 0x002503, $F503
    LDA   #$02
    BRA   BANKSWITCH_TO_A
BANKSWITCH_TO_3: ; 0x002507, $F507
    LDA   #$03
    BRA   BANKSWITCH_TO_A
BANKSWITCH_TO_1: ; 0x00250B, $F50B
    LDA   #$01
BANKSWITCH_TO_A: ; 0x00250D, $F50D
    STA   CURRENT_BANK
    STA   BANKSWITCH
    RTS
PSH_ALL_GOTO_B2-C002: ; 0x002513, $F513
    PSHS  U,Y,X,DP,B,A,CC
    BSR   BANKSWITCH_TO_2
    JSR   JMP_SENTENCE_TO_SCREEN
    PULS  CC,A,B,DP,X,Y,U,PC
GOTO_B3-C00F_BOOKKEEP_UPDATE_+1: ; 0x00251C, $F51C
    BSR   BANKSWITCH_TO_3
    JMP   JMP_BOOKKEEP_UPDATE_+1
    RTS
GFX_BANK2_CHR_TO_SCREEN: ; 0x002522, $F522
    PSHS  U,Y,X,B,A ; Save state
    TFR   D>X ; TFR location to X
    LDA   CURRENT_BANK ; Get bank
    PSHS  A ; Save
    LDA   #$02 ; Switch to bank 2.
    STA   CURRENT_BANK
    STA   BANKSWITCH
    LDD   Y ; Get WWHH?
    LDY   2,Y ; LDY from Y
    PSHS  B,A ; Save from Y
    BITB  #$01 ; Test lowest bit...
    BNE   LOOP_ON_BBOUNDRY
LOOP_ON_WBOUNDRY: ; 0x00253C, $F53C
    SUBB  #$02 ; Taking 2
LOOP_NO_OFFSET: ; 0x00253E, $F53E
    LDU   B,Y ; Get data from Y+B
    STU   B,X ; Store to X+B
    SUBB  #$02
    BPL   LOOP_NO_OFFSET ; If next data exists.
    LDB   1,S ; Get A pushed to stack.
    LEAX  256,X ; Add 256 to X
    LEAY  B,Y ; Add offset from B, height?
    DECA ; Dec A normally.
    BNE   LOOP_ON_WBOUNDRY ; Loop if not done.
    BRA   POST_COL_DATA_MOVED
LOOP_ON_BBOUNDRY: ; 0x002553, $F553
    DECB ; -= consumed
    LDA   B,Y ; Get byte
    STA   B,X ; Store byte
    SUBB  #$02 ; Sub 2
    BMI   END_MOVE_COL
LOOP_ON_BBOUNDRY_WORD: ; 0x00255C, $F55C
    LDU   B,Y ; Get word
    STU   B,X ; Store word
    SUBB  #$02
    BPL   LOOP_ON_BBOUNDRY_WORD
END_MOVE_COL: ; 0x002564, $F564
    LDB   1,S ; Get A pushed onto stack.
    LEAX  256,X ; Add 256 to X
    LEAY  B,Y ; Y+=B
    DEC   S ; Decrease A on stack
    BNE   LOOP_ON_BBOUNDRY ; Loop if not written
POST_COL_DATA_MOVED: ; 0x002570, $F570
    LEAS  2,S ; Fix stack
    PULS  A ; Pull bank from.
    STA   CURRENT_BANK
    STA   BANKSWITCH ; Switch to bank.
    PULS  A,B,X,Y,U,PC ; RTS
GFX_BANK2_CHR_CLEAR: ; 0x00257B, $F57B
    PSHS  U,X,B,A ; Save
    TFR   D>X ; D is location on screen.
    LDA   CURRENT_BANK ; Get bank in.
    PSHS  A ; Save
    LDA   #$02 ; Switch to bank 2.
    STA   CURRENT_BANK ; Store val.
    STA   BANKSWITCH ; Switch
    LDD   Y ; Load with Y ptr, WWHH of obj
CLR_SCRN_SLOW_X=POS,A=W,B=H: ; 0x00258C, $F58C
    LDU   #$0000 ; Clearing value.
    PSHS  B ; Save loaded B, height
    BITB  #$01 ; Test bottom bit.
    BNE   B_BOUNDARY ; Is on byte boundary.
W_BOUNDARY: ; 0x002595, $F595
    SUBB  #$02 ; Taking 2
LOOP_CLEAR_W: ; 0x002597, $F597
    STU   B,X ; Clear X[B]
    SUBB  #$02 ; Wrote 2 rows.
    BPL   LOOP_CLEAR_W
    LDB   S ; Reset Y addition.
    LEAX  256,X ; Next col.
    DECA ; Dec A
    BNE   W_BOUNDARY ; Not done.
    BRA   EXIT_RESTORE_BANK ; Exit
B_BOUNDARY: ; 0x0025A8, $F5A8
    DECB ; One byte clearing.
    CLR   B,X ; Clear
    SUBB  #$02
    BMI   ONE_GOOD_ENOUGH ; If we under flow, one was all that was needed, since we said -2
MORE_ROWS_BYTE_WORD: ; 0x0025AF, $F5AF
    STU   B,X ; Clear 2 rows.
    SUBB  #$02 ; Did 2
    BPL   MORE_ROWS_BYTE_WORD ; Loop clear.
ONE_GOOD_ENOUGH: ; 0x0025B5, $F5B5
    LDB   S ; Reset Y addition.
    LEAX  256,X ; Next col.
    DECA ; More width?
    BNE   B_BOUNDARY ; Yes, loop this.
EXIT_RESTORE_BANK: ; 0x0025BE, $F5BE
    PULS  A,B ; Pull A=Y Off, B=Bank from. Expected.
    STB   CURRENT_BANK ; Store bank.
    STB   BANKSWITCH
    PULS  A,B,X,U,PC ; Restore state, RTS.
CLEAR_SCREEN_FLEX_SETUP: ; 0x0025C7, $F5C7
    PSHS  U,X,B,A ; Save. X=POS,A=W,B=H,U gets clobbered so save too.
    LDA   CURRENT_BANK ; RTN expects this.
    PSHS  A
    LDA   1,S ; Get A pushed onto stack originally.
    BRA   CLR_SCRN_SLOW_X=POS,A=W,B=H
CLEAR_ALL_SCREEN: ; 0x0025D1, $F5D1
    PSHS  U,Y,X,B,A
    LDU   #$9C00
    LDX   #$0000
    TFR   X>Y
    TFR   X>D
CLEAR_SCREEN_ALL_LOOP: ; 0x0025DD, $F5DD
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  Y,X,B,A
    PSHU  X
    CMPU  #$0000 ; All cleared
    BNE   CLEAR_SCREEN_ALL_LOOP ; If not end of screen.
    PULS  A,B,X,Y,U,PC ; restore, RTS
CLEAR_GAME_SCREEN: ; 0x0025F1, $F5F1
    PSHS  U,Y,X,DP,B,A
    LDU   #$9C00
    LDX   #$0000
    TFR   X>Y
    TFR   X>D
    TFR   A>DP
CLEAR_GAME_SCREEN_COL_LOOP: ; 0x0025FF, $F5FF
    LDB   #$08 ; loop count
CLEAR_COUNT_LOOP: ; 0x002601, $F601
    PSHU  Y,X,DP,A ; 6 rows.
    PSHU  Y,X,DP,A
    PSHU  Y,X,DP,A
    PSHU  Y,X,DP,A ; 24 rows.
    DECB
    BNE   CLEAR_COUNT_LOOP ; 192 rows.
    PSHU  Y,X,DP,A ; 198
    PSHU  Y,X,DP,A
    PSHU  Y,X,DP,A ; 210
    PSHU  Y,X ; 214
    LEAU  -42,U ; 256. Adjust to miss scanner.
    CMPU  #$0000 ; Is end?
    BNE   CLEAR_GAME_SCREEN_COL_LOOP ; No, keep looping.
    PULS  A,B,DP,X,Y,U,PC
DEFENDER_BOOTUP: ; 0x00261F, $F61F
    CLR   BANKSWITCH ; Set bankswitch to 0.
    LDX   #$CC00 ; Set to PIA's.
    CLR   1,X ; Clear data ctrl registers.
    CLR   3,X
    CLR   5,X
    CLR   7,X
    LDA   #$C0 ; Set top two bits. 1=Input, 0=Output.
    STA   X ; PIA-ROM-A-DATA
    LDA   #$FF ; Set all bits to input.
    STA   2,X ; PIA-ROM-B-DATA
    CLR   4,X ; PIA-WIG-A-DATA
    CLR   6,X ; PIA-WIG-B-DATA
    LDA   #$04 ; Set data to report.
    STA   3,X ; PIA-ROM-B-CTRL
    STA   5,X ; PIA-WIG-A-CTRL
    STA   7,X ; PIA-WIG-B-CTRL
    ORA   #$10 ; Set CTRL to interrupt on 0->1 transition.
    STA   1,X ; PIA-ROM-A-CTRL
    LDX   #$C000 ; Ptr, IO space.
    LDA   #$C0 ; Seed palette gen.
INITIAL_PALETTE_LOAD: ; 0x00264A, $F64A
    STA   X+ ; Store A/D Upper to palette.
    LDB   #$B5 ; Seed B
    MUL ; Figure next palette byte.
    CMPX  #$C010 ; Compare to end.
    BNE   INITIAL_PALETTE_LOAD
    ORCC  #$80 ; Set entire flag.
    ANDCC #$EF ; Enable IRQs, unmask.
    LDY   #$0002 ; Set number of times to do pattern.
    CLRA ; Clear A.
    TFR   A>DP ; Set DP to 0.
    ANDCC #$BF ; Enable FIRQs, unmask.
    CLRB
RUG_PATTERN_SETUP: ; 0x002662, $F662
    TFR   D>U ; Save D to U
    LDX   #$0000 ; Set X to screen memory.
RUG_PATTERN_LOOP: ; 0x002667, $F667
    COMB ; Invert B
    BITB  #$09 ; Test bits.
    BNE   BITS_SET
    COMB ; Re-invert
    RORA ; rotate
    RORB
    BRA   STR_D_TO_SCR[X]
BITS_SET: ; 0x002671, $F671
    COMB ; re-invert
    BITB  #$09 ; Test bits.
    BNE   BITS_SET2
    RORA ; rotate
    RORB
    BRA   STR_D_TO_SCR[X]
BITS_SET2: ; 0x00267A, $F67A
    LSRA ; rotate in 0.
    RORB
STR_D_TO_SCR[X]: ; 0x00267C, $F67C
    STD   X++ ; Store D to screen.
    EXG   X-D ; Screen loc to D
    TSTB ; Test if column
    BNE   RUG_DISP_NOT_COL
    LDB   #$38
    STB   WATCHDOG ; Set watchdog.
    TFR   CC>B ; CC to B
    BITB  #$10 ; Test if IRQ mask
    BEQ   IRQ_NO_MASK
    CLR   BANKSWITCH ; Set to IO bank.
    LDB   PIA_ROM_DATA_A ; Get switches from coin door. 1=Active
    COMB ; Invert, active low.
    BITB  #$03 ; Test if auto/man or adv weren't set.
    BEQ   RUG_BOTH_INPUTS_ACTIVE ; Both active.
IRQ_NO_MASK: ; 0x002699, $F699
    CLRB ; Set init to proper val.
RUG_DISP_NOT_COL: ; 0x00269A, $F69A
    EXG   X-D ; Put screen location back to X.
    CMPX  #$C000 ; End of screen.
    BNE   RUG_PATTERN_LOOP ; Not done, loop.
    TFR   U>D ; D=0
    LDX   #$0000 ; Set X.
COMPARE_RUG_LOOP: ; 0x0026A6, $F6A6
    COMB
    BITB  #$09
    BNE   BITS_SET
    COMB
    RORA
    RORB
    BRA   COMPARE_RUG
BITS_SET: ; 0x0026B0, $F6B0
    COMB
    BITB  #$09
    BNE   BITS_SET2
    RORA
    RORB
    BRA   COMPARE_RUG
BITS_SET2: ; 0x0026B9, $F6B9
    LSRA
    RORB
COMPARE_RUG: ; 0x0026BB, $F6BB
    CMPD  X++ ; Test what is on screen.
    BEQ   RUG_MATCH
    EXG   D-Y ; Save value to Y.
    TFR   CC>A
    BITA  #$10 ; Test if IRQ mask.
    BEQ   RUG_MISMATCH_IRQ_NOMASK
    LDA   #$03
    STA   CURRENT_BANK
    STA   BANKSWITCH
    JMP   JMP_RUG_MISMATCH
RUG_MISMATCH_IRQ_NOMASK: ; 0x0026D2, $F6D2
    CLRA ; Start over by clearing the top byte?
    EXG   Y-D ; Put screen value back to D.
    ORCC  #$40 ; Mask FIRQ
RUG_MATCH: ; 0x0026D7, $F6D7
    EXG   X-D ; Save screen pos to X.
    TSTB ; See if at column.
    BNE   NOT_COLUMN_RUG_MATCH
    TFR   CC>B
    BITB  #$10 ; Test if IRQ mask.
    BEQ   RUG_MATCH_NOT_ADMIN_MENU ; No mask goes here.
    LDB   PIA_ROM_DATA_A ; Get coin door buttons. 1=Active
    COMB ; Active low.
    BITB  #$03 ; Test auto/man and adv switch.
    BNE   WATCHDOG+RUG_REENTER ; If neither active, reenter.
RUG_BOTH_INPUTS_ACTIVE: ; 0x0026EA, $F6EA
    LDA   #$03 ; Otherwise, leave. Bank val.
    STA   CURRENT_BANK
    STA   BANKSWITCH ; Switch
    JMP   JMP_RUG_LEAVE_ADMIN_MENU? ; Leave to admin menu.
RUG_MATCH_NOT_ADMIN_MENU: ; 0x0026F4, $F6F4
    TFR   CC>B
    BITB  #$40 ; Test if FIRQ mask.
    BEQ   WATCHDOG+RUG_REENTER ; Not set, reenter.
    ANDCC #$BF ; Clear FIRQ mask.
    TFR   DP>B ; DP to B...
    TFR   A>DP ; A to DP. Val?
SUB_LOOP: ; 0x002700, $F700
    SUBA  #$03 ; A-=3
    BHS   SUB_LOOP ; Loop until underflow.
    INCA ; Test if was 2
    BNE   A_NOT_FF ; Skip setting DP.
    ORB   #$02 ; A=FF, set.
    BRA   COMMIT_DP
A_NOT_FF: ; 0x00270B, $F70B
    INCA ; Test if was 1
    BNE   A_IS_FD ; No, was 0, take this.
    ORB   #$01 ; A=FE, set.
    BRA   COMMIT_DP ; Always taken.
A_IS_FD: ; 0x002712, $F712
    ORB   #$04 ; A=FD, set.
COMMIT_DP: ; 0x002714, $F714
    TFR   DP>A ; Put A back.
    TFR   B>DP ; Failure value to DP.
WATCHDOG+RUG_REENTER: ; 0x002718, $F718
    LDB   #$38 ; Reset watchdog.
    STB   WATCHDOG
    CLRB ; Set B back to value.
NOT_COLUMN_RUG_MATCH: ; 0x00271E, $F71E
    EXG   X-D ; Put screen back to X.
    CMPX  #$C000 ; Is end of screeen.
    LBNE  COMPARE_RUG_LOOP ; No, loop.
    LEAY  -1,Y ; Rug pattern finished, minus 1 loop.
    LBNE  RUG_PATTERN_SETUP ; Repeat if not 0.
    TFR   CC>B ; RUG PATTERN CONFIRMED HERE.
    TSTB ; Test CC
    BMI   RUG_POST_ENTIRE_SET(BOOTUP?) ; If bit 7 set
    LDB   #$03 ; If not bootup do this?
    STB   BANKSWITCH
    JSR   SETUP_TEXT+UNK ; Idk
    JMP   JUMP_RUG_MATCH_UNK ; Exit
RUG_POST_ENTIRE_SET(BOOTUP?): ; 0x00273D, $F73D
    BITB  #$10 ; Test for IRQ mask.
    LBNE  RUG_PATTERN_SETUP ; IRQ masked, keep going. In menu call?
    LDA   #$9E ; Init A, eventually gets put to stack?
    TFR   DP>B ; Put marks to B
    TSTB ; Test if was failures?
    BEQ   NO_DP_MARKS ; No marks, use A as-is.
BIT_0_WAS_SET: ; 0x00274A, $F74A
    INCA ; ++, 1>+1,2=+1,3=+2
    LSRB ; Get bit off B (DP)
    BLO   BIT_0_WAS_SET ; If bit 0 was 1, repeat.
NO_DP_MARKS: ; 0x00274E, $F74E
    TFR   A>DP ; Write A to DP. 0x9E to 0xA6.
    ADDA  #$01 ; ++
    CLRB ; D=##00
    TFR   D>S ; Put S stack there.
    JSR   SETUP_TEXT+UNK ; Setup stuff.
ROM_CHECK_START: ; 0x002758, $F758
    LDU   #$F86E ; Load U stack.
BANK_TEST_CHECK_LOOP: ; 0x00275B, $F75B
    CLR   BANKSWITCH ; Set to IO
    LDA   #$38 ; Set watchdog.
    STA   WATCHDOG
    LDA   U ; Load pointed data.
    LDB   U ; Load pointed.
    BEQ   CORRECT_CHECKSUM ; If is 0, skip check.
    ANDB  #$0F ; Get bank bits.
    STB   BANKSWITCH ; Switch to bank
    ANDA  #$70 ; Get upper bits.
    LSRA ; Shift once.
    ADDA  #$C0 ; Add value to get offset.
    CLRB ; Clear bottom byte of D.
    TFR   D>X ; Addr made to X
    LDY   #$0800 ; Set Y to check size
    TFR   U>D ; Tfr location for check...
    SUBB  #$6C ; location.lower - 2
    LSRB ; Divide by 2. This is init value.
    CLRA ; Clear A
LOOP_0x800: ; 0x002780, $F780
    ADCB  X+ ; +=, w/ carry
    LEAY  -1,Y ; --
    BNE   LOOP_0x800
    CMPB  #$80 ; If B ends up being #$80...
    BEQ   CORRECT_CHECKSUM
    TFR   CC>A ; Incorrect here.
    BITA  #$10 ; Test IRQ mask
    BEQ   WRONG_CHECKSUM_NO_IRQ ; No IRQ Mask.
RTS_INTO_BANK3_FROM_CHECK: ; 0x002790, $F790
    JMP   BANKSWITCH_TO_3 ; Go back to system menu.
CORRECT_CHECKSUM: ; 0x002793, $F793
    LEAU  1,U ; Ptr += 1
    CMPU  #$F886 ; End
    BNE   BANK_TEST_CHECK_LOOP ; Not at end.
    TFR   CC>A ; Get CC. All passed here.
    BITA  #$10 ; Test IRQ
    BNE   RTS_INTO_BANK3_FROM_CHECK ; Go back into menu?
    TFR   DP>A ; Get DP
    CMPA  #$9E ; Check if DP was originally 0
    BNE   DP_ORIGINALLY_NOT_0 ; If taken, original DP!=0
    JSR   BANKSWITCH_TO_3 ; Switch to bank.
    JSR   JMP_BOOTUP_UNIT_OK ; UNIT OK.
    BRA   RUG_PASS_SRAM_CHECK ; NOTE: Goes to main loop here!
DP_ORIGINALLY_NOT_0: ; 0x0027AF, $F7AF
    LDB   #$40 ; LED 4+2
    BSR   WRITE_B_TO_ROM_DATA_PIA_REGS+BANK3 ; Turn on.
    JSR   JMP_BOOTUP_RAM_FAILURE
    BRA   RUG_PASS_SRAM_CHECK
WRITE_B_TO_ROM_DATA_PIA_REGS+BANK3: ; 0x0027B8, $F7B8
    LDX   #$CC00
    STB   X ; Write to ROM_DATA_A
    STB   2,X ; And B
    CLR   BANKSWITCH ; Change to IO bank.
DISPLAY_MESSAGE_WAIT: ; 0x0027C2, $F7C2
    LDA   #$38
    STA   WATCHDOG ; Clear watchdog...
    LEAX  -1,X
    BNE   DISPLAY_MESSAGE_WAIT
    JMP   BANKSWITCH_TO_3 ; Switch to bank 3, abuse RTS
WRONG_CHECKSUM_NO_IRQ: ; 0x0027CE, $F7CE
    LDB   #$80 ; LED 3+1
    BSR   WRITE_B_TO_ROM_DATA_PIA_REGS+BANK3 ; Turn on.
    JSR   JMP_BOOTUP_ROM_FAILURE
RUG_PASS_SRAM_CHECK: ; 0x0027D5, $F7D5
    JSR   JMP_SRAM_CHECK_UNK ; SRAM check to see if menu?
    JMP   DEFENDER_GAME_TITLE? ; Goto game if SRAM check didn't take over.
STORE_B[X]_BANK0: ; 0x0027DB, $F7DB
    PSHS  A,CC ; Save A,CC
    LDA   CURRENT_BANK ; Load bank
    PSHS  A ; Push to the stack to save.
    CLR   CURRENT_BANK ; Set to bank 0
    CLR   BANKSWITCH
    STB   X ; Store B to X
RESTORE_BANK+A+CC_@S: ; 0x0027E8, $F7E8
    PULS  A
    STA   CURRENT_BANK
    STA   BANKSWITCH
    PULS  CC,A,PC ; Restore regs. RTS
LOAD_B[X]_BANK0: ; 0x0027F1, $F7F1
    PSHS  A,CC ; Save A,CC
    LDA   CURRENT_BANK ; Loaded because restores.
    PSHS  A ; Push current bank to save.
    CLR   CURRENT_BANK ; Set to bank 0.
    CLR   BANKSWITCH
    LDB   X ; Load B
    BRA   RESTORE_BANK+A+CC_@S ; Restore last bank
SETUP_TEXT+UNK: ; 0x002800, $F800
    PSHS  B,A ; Save B,A
    CLR   SENTENCE_PTR_WORD_ON ; Clear
    CLR   UNK_$49_SYS_MENU_FLAG?
    LDA   #$03
    STA   CURRENT_BANK ; Bank info without switching?
    STA   UNK_$48 ; Set
    LDD   #$FFFF
    STD   TEXT_PTR_UNK ; Set
    PULS  A,B,PC ; Get reg, RTS.
GET_DATA_FROM_SRAM(IN_A): ; 0x002813, $F813
    LDA   1,X ; Get val at X+1
    ANDA  #$0F ; Bottom bits.
    PSHS  A ; Save
    LDA   X++ ; Get val, X+=2
    ASLA ; Lower bits higher.
    ASLA
    ASLA
    ASLA
    ADDA  S+ ; Get bottom bits, fix stack too.
    RTS ; RTS
GET_DATA_FROM_SRAM[X]_IN_A: ; 0x002822, $F822
    PSHS  B ; Save B.
    LDB   CURRENT_BANK ; Get bank.
    PSHS  B ; Save
    CLR   CURRENT_BANK ; Bank 0.
    CLR   BANKSWITCH ; Bank 0.
    BSR   GET_DATA_FROM_SRAM(IN_A) ; Get data. X+=2
    PULS  B
    STB   CURRENT_BANK ; Restore bank from stack.
    STB   BANKSWITCH
    PULS  B,PC ; Rest+ret, data in A.
GET_DATA_FROM_SRAM[X]_IN_AB: ; 0x002838, $F838
    BSR   GET_DATA_FROM_SRAM[X]_IN_A
GET_DATA_FROM_SRAM[X]_IN_B: ; 0x00283A, $F83A
    PSHS  A ; INFO: X+=2
    BSR   GET_DATA_FROM_SRAM[X]_IN_A
    TFR   A>B
    PULS  A,PC
STORE_A_TO_SRAM[X]: ; 0x002842, $F842
    PSHS  A ; Store low bits.
    STA   1,X ; above
    LSRA ; Shift high bits low
    LSRA
    LSRA
    LSRA
    STA   X++ ; Store at X
    PULS  A,PC ; Return
STORE_A_TO_SRAM[X]_BANKED: ; 0x00284E, $F84E
    PSHS  B ; Save B
    LDB   CURRENT_BANK ; Get bank
    PSHS  B ; Save bank
    CLR   CURRENT_BANK
    CLR   BANKSWITCH ; Set to IO bank.
    BSR   STORE_A_TO_SRAM[X] ; Write
    PULS  B ; Restore bank.
    STB   CURRENT_BANK
    STB   BANKSWITCH
    PULS  B,PC ; RTS
STORE_D_TO_SRAM[X]: ; 0x002864, $F864
    BSR   STORE_A_TO_SRAM[X]_BANKED ; Store A
STORE_B_TO_SRAM[X]: ; 0x002866, $F866
    PSHS  A ; Save A
    TFR   B>A ; Put B to SRAM.
    BSR   STORE_A_TO_SRAM[X]_BANKED ; Store.
    PULS  A,PC ; RTS.
BANK_CHECK_DATA: ; 0x00286E, $F86E
    .db $20 ; BANK CHECK ARRAY, FMT[-AAABBBB, A=Addr*0x200+0xC000,B=BANK]
    .db $00
    .db $40
    .db $50
    .db $60
    .db $70
    .db $30
    .db $00
    .db $00
    .db $00
    .db $07
    .db $00
    .db $03
    .db $00
    .db $02
    .db $00
    .db $01
    .db $00
    .db $13
    .db $00
    .db $12
    .db $00
    .db $11
    .db $00 ; END OF DATA
    .db $E5 ; THIS DATA IS USED IN THE FAILURE STUFF
    .db $91
    .db $00
    .db $E8
    .db $00
    .db $00
    .db $00
    .db $00
    .db $E8
    .db $C1
    .db $00
    .db $F8
    .db $E9
    .db $1F
    .db $00
    .db $F8
    .db $D8
    .db $4E
    .db $00
    .db $00
    .db $D8
    .db $39
    .db $00
    .db $00
    .db $E8
    .db $97
    .db $00
    .db $E8
DATA_FOR_$82-$88: ; 0x0028A2, $F8A2
    .db $00 ; fmt: [4 bytes]
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D4
    .db $4C
    .db $00
    .db $00
    .db $D4
    .db $75
    .db $02
    .db $00
    .db $D4
    .db $3D
    .db $00
    .db $00
    .db $D4
    .db $6E
    .db $02
    .db $00
    .db $D4
    .db $7C
    .db $02
    .db $00
INIT_DATA_FOR_$A026: ; 0x0028BE, $F8BE
    .db $00 ; 0x10 bytes
    .db $00
    .db $07
    .db $28
    .db $2F
    .db $81
    .db $A4
    .db $15
    .db $C7
    .db $FF
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $05
    .db $08
    .db $F9
    .db $FB
    .db $FA
    .db $23
    .db $D1
    .db $93
    .db $D1
    .db $1F
    .db $04
    .db $08
    .db $FA
    .db $4B
    .db $FA
    .db $4B
    .db $D1
    .db $39
    .db $D1
    .db $6B
    .db $04
    .db $08
    .db $FA
    .db $6B
    .db $FA
    .db $6B
    .db $D1
    .db $39
    .db $D1
    .db $6B
    .db $01
    .db $01
    .db $F8
    .db $F6
    .db $F8
    .db $F6
    .db $D8
    .db $DB
    .db $D8
    .db $DB
    .db $00
    .db $04
    .db $08
    .db $FA
    .db $8B
    .db $FA
    .db $AB
    .db $D1
    .db $39
    .db $D1
    .db $6B
DATA_IDK: ; 0x002901, $F901
    .db $02
    .db $08
    .db $FA
    .db $CB
    .db $FA
    .db $DB
    .db $D0
    .db $F9
    .db $D1
    .db $0B
    .db $02
    .db $08
    .db $FA
    .db $EB
    .db $FA
    .db $FB
    .db $D0
    .db $F9
    .db $D1
    .db $0B
HUMANOID_BITMAP: ; 0x002915, $F915
    .db $02
    .db $08
    .db $FB
    .db $0B
    .db $FB
    .db $1B
    .db $D0
    .db $F9
    .db $D1
    .db $0B
    .db $02
    .db $08
    .db $FB
    .db $2B
    .db $FB
    .db $3B
    .db $D0
    .db $F9
    .db $D1
    .db $0B
    .db $04
    .db $08
    .db $FB
    .db $4B
    .db $FB
    .db $6B
    .db $D1
    .db $39
    .db $D1
    .db $6B
    .db $04
    .db $08
    .db $FB
    .db $8B
    .db $FB
    .db $AB
    .db $D1
    .db $39
    .db $D1
    .db $6B
    .db $04
    .db $08
    .db $FB
    .db $CB
    .db $FB
    .db $EB
    .db $D1
    .db $39
    .db $D1
    .db $6B
    .db $04
    .db $08
    .db $FC
    .db $0B
    .db $FC
    .db $2B
    .db $D1
    .db $39
    .db $D1
    .db $6B
CALLBACK?_SHIP_EXPLODE_COUNTDOWN?: ; 0x002951, $F951
    LSR   HIGHSCORE_INITIALS_ADDR
    LDD   #$90CC
    SUBA  $A0D1
    RTS
    .db $D1
    .db $6B
    .db $02
    .db $03
    .db $CC
    .db $B0
    .db $CC
    .db $B6
    .db $D1
    .db $F1
    .db $D2
    .db $0D
    .db $02
    .db $03
    .db $CC
    .db $BC
    .db $CC
    .db $C2
    .db $D1
    .db $F1
    .db $D2
    .db $0D
    .db $08
    .db $01
    .db $F9
    .db $73
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $03
    .db $04
    .db $CC
    .db $C8
    .db $CC
    .db $D4
    .db $D1
    .db $AD
    .db $D1
    .db $D7
BMP_LANDER?: ; 0x002985, $F985
    .db $05
    .db $08
    .db $CC
    .db $E0
    .db $CD
    .db $08
    .db $D1
    .db $93
    .db $D1
    .db $1F
    .db $05
    .db $08
    .db $CD
    .db $30
    .db $CD
    .db $58
    .db $D1
    .db $93
    .db $D1
    .db $1F
    .db $05
    .db $08
    .db $CD
    .db $80
    .db $CD
    .db $A8
    .db $D1
    .db $93
    .db $D1
    .db $1F
    .db $06
    .db $04
    .db $CD
    .db $D0
    .db $CD
    .db $E8
    .db $D2
    .db $1F
    .db $D2
    .db $60
    .db $06
    .db $04
    .db $CE
    .db $00
    .db $CE
    .db $18
    .db $D2
    .db $1F
    .db $D2
    .db $60
    .db $06
    .db $04
    .db $CE
    .db $30
    .db $CE
    .db $48
    .db $D2
    .db $1F
    .db $D2
    .db $60
BITMAP_SHIP_FACING_RIGHT?: ; 0x0029C1, $F9C1
    .db $08
    .db $06
    .db $CE
    .db $60
    .db $CE
    .db $90
    .db $D2
    .db $8E
    .db $D2
    .db $DF
BITMAP_SHIP_FLYING_LEFT?: ; 0x0029CB, $F9CB
    .db $08
    .db $06
    .db $CE
    .db $C0
    .db $CE
    .db $F0
    .db $D2
    .db $8E
    .db $D2
    .db $DF
BMP_SHIP: ; 0x0029D5, $F9D5
    .db $05 ; Player ship.
    .db $04
    .db $CF
    .db $20
BMP_SMARTBOMB: ; 0x0029D9, $F9D9
    .db $03 ; Smartbomb graphic here.
    .db $03
    .db $CF
    .db $34
    .db $06
    .db $06
    .db $CF
    .db $3D
    .db $CF
    .db $61
    .db $D3
    .db $3D
    .db $D3
    .db $50
BITMAP_IDK: ; 0x0029E7, $F9E7
    .db $06
    .db $06
    .db $CF
    .db $85
    .db $CF
    .db $A9
    .db $D3
    .db $3D
    .db $D3
    .db $50
    .db $08
    .db $06
    .db $CF
    .db $CD
    .db $CF
    .db $CD
    .db $F5
    .db $22
    .db $F5
    .db $7B
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $0C
    .db $3C
    .db $0C
    .db $08
    .db $38
    .db $30
    .db $00
    .db $00
    .db $C0
    .db $C0
    .db $C8
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $00
    .db $30
    .db $03
    .db $03
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $03
    .db $30
    .db $30
    .db $03
    .db $03
    .db $30
    .db $00
    .db $CC
    .db $CC
    .db $CC
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $00
    .db $03
    .db $80
    .db $80
    .db $83
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $00
    .db $0D
    .db $6C
    .db $6C
    .db $0D
    .db $00
    .db $00
    .db $06
    .db $E6
    .db $C8
    .db $83
    .db $82
    .db $C8
    .db $EC
    .db $06
    .db $60
    .db $6D
    .db $8C
    .db $28
    .db $28
    .db $8C
    .db $6D
    .db $60
    .db $00
    .db $00
    .db $E0
    .db $C6
    .db $C6
    .db $E0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $02
    .db $22
    .db $24
    .db $02
    .db $00
    .db $00
    .db $02
    .db $22
    .db $44
    .db $44
    .db $24
    .db $42
    .db $22
    .db $00
    .db $20
    .db $22
    .db $44
    .db $44
    .db $24
    .db $42
    .db $22
    .db $00
    .db $00
    .db $00
    .db $20
    .db $22
    .db $22
    .db $20
    .db $00
    .db $00
    .db $00
    .db $0E
    .db $00
    .db $D8
    .db $00
    .db $0E
    .db $00
    .db $00
    .db $0F
    .db $08
    .db $8C
    .db $C8
    .db $8C
    .db $08
    .db $0F
    .db $00
    .db $00
    .db $0E
    .db $80
    .db $C8
    .db $80
    .db $0E
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $E0
    .db $08
    .db $8C
    .db $08
    .db $E0
    .db $00
    .db $00
    .db $F0
    .db $80
    .db $C8
    .db $8C
    .db $C8
    .db $80
    .db $F0
    .db $00
    .db $00
    .db $E0
    .db $00
    .db $8D
    .db $00
    .db $E0
    .db $00
    .db $00
    .db $33
    .db $43
    .db $43
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $03
    .db $04
    .db $04
    .db $08
    .db $08
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $38
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $33
    .db $43
    .db $43
    .db $87
    .db $87
    .db $77
    .db $77
    .db $77
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $03
    .db $04
    .db $04
    .db $08
    .db $08
    .db $07
    .db $07
    .db $07
    .db $30
    .db $30
    .db $38
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $03
    .db $03
    .db $83
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $30
    .db $40
    .db $40
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $08
    .db $08
    .db $08
    .db $00
    .db $00
    .db $00
    .db $33
    .db $34
    .db $34
    .db $78
    .db $78
    .db $70
    .db $70
    .db $70
    .db $03
    .db $03
    .db $83
    .db $87
    .db $87
    .db $07
    .db $07
    .db $07
    .db $30
    .db $40
    .db $40
    .db $80
    .db $80
    .db $70
    .db $70
    .db $70
    .db $00
    .db $00
    .db $08
    .db $08
    .db $08
    .db $00
    .db $00
    .db $00
    .db $33
    .db $34
    .db $34
    .db $78
    .db $78
    .db $77
    .db $77
    .db $77
    .db $08
    .db $08
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $88
    .db $88
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $00
    .db $88
    .db $88
    .db $D8
    .db $D8
    .db $D8
    .db $D0
    .db $D0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $88
    .db $88
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $00
    .db $88
    .db $88
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $08
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $00
    .db $88
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $88
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $D0
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $00
    .db $88
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $88
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $DE
    .db $DE
    .db $DE
    .db $DD
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $FE
    .db $EE
    .db $DD
    .db $88
    .db $00
    .db $00
    .db $D0
    .db $D8
    .db $D8
    .db $D8
    .db $D8
    .db $88
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $00
    .db $00
    .db $DD
    .db $EE
    .db $EF
    .db $EE
    .db $DD
    .db $88
    .db $00
    .db $00
    .db $DD
    .db $ED
    .db $ED
    .db $ED
    .db $DD
    .db $88
    .db $00
    .db $00
    .db $00
    .db $80
    .db $80
    .db $80
    .db $80
    .db $80
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN?: ; 0x002C60, $FC60
    JMP   REPLACES_BMP_AND_DOES_ALOT
L_002C63: ; 0x002C63, $FC63
    JMP   L_002CCC
L_002C66: ; 0x002C66, $FC66
    JMP   L_002D2D
REPLACES_BMP_AND_DOES_ALOT: ; 0x002C69, $FC69
    PSHS  U,Y,B,A ; Save
    LDD   2,X ; Load OBJ[2], BMP.
    PSHS  B,A ; Save to stack.
    LDD   DATA_W_F8EC ; Get data from ROM
    STD   2,X ; Store to BMP
    STX   LIST_$65_ON_SCREEN? ; Store obj to list.
    LDD   10,X ; Load OBJ[10]
    SUBD  R_A020_SCREEN_POS_CHANGE? ; Sub with
    CMPD  #$2600 ; Compare to top of screen?
    BHI   RESTORE_BMP_POINTER+RTS ; If >, restore.
    LDY   R_A0E2_UNK_REPLACED_BMP_VAR ; Load Y from
    BEQ   Y_TO_#$9C00 ; If 0, goto.
Y+=64,CMP_TO_#$A000: ; 0x002C85, $FC85
    LEAY  64,Y ; Y+=64
    CMPY  #$A000 ; If Y _ #$A000
    BNE   DONT_CAP_Y ; !=, goto
Y_TO_#$9C00: ; 0x002C8E, $FC8E
    LDY   #$9C00 ; Cap to val.
DONT_CAP_Y: ; 0x002C92, $FC92
    CMPY  R_A0E2_UNK_REPLACED_BMP_VAR ; Compare to
    BNE   Y_NO_MATCH_A0E2 ; !=, goto
RESTORE_BMP_POINTER+RTS: ; 0x002C97, $FC97
    PULS  A,B ; Get old handler.
    STD   2,X ; Restore
    BRA   RTS ; RTS
Y_NO_MATCH_A0E2: ; 0x002C9D, $FC9D
    LDA   Y ; Load A from Y
    BMI   Y+=64,CMP_TO_#$A000 ; If negative, goto.
    BEQ   SKIP_JSR ; If 0, goto.
    JSR   L_002DD5 ; IDK
SKIP_JSR: ; 0x002CA6, $FCA6
    LDA   A0BA_PLAYER_GAME_STATE ; Load val
    BITA  #$80 ; Test
    BNE   EXIT_STUFF ; If set, goto.
    LDD   DATA_W_2CAC ; Load val
    JSR   JMP_SET_A0B0-A0B3_WHEN_@D>A0B2 ; Sets IDK.
EXIT_STUFF: ; 0x002CB2, $FCB2
    LDA   20,X ; Load OBJ[20]
    ORA   #$02 ; Set bit
    STA   20,X ; Store back
    LDD   #$AF00 ; Load D
    STD   Y ; Store to Y...?
    PULS  A,B ; Restore handler?
    STD   2,Y
    LEAU  64,Y ; U = Y+64
    STU   4,Y ; Store to OBJ[4]
    STX   10,Y ; Store OBJ PTR to OBJ[10]
RTS: ; 0x002CCA, $FCCA
    PULS  A,B,Y,U,PC ; RTS+Restore
L_002CCC: ; 0x002CCC, $FCCC
    PSHS  U,Y,B,A ; Save
    LDD   10,X ; Load OBJ[10]
    SUBD  R_A020_SCREEN_POS_CHANGE? ; Sub
    CMPA  #$26 ; CMP
    BHI   RTS+RESTORE ; >, goto.
    STD   $A0E9 ; D to
    LDY   R_A0E2_UNK_REPLACED_BMP_VAR ; Y from
    BEQ   L_002CE6 ; If 0, goto.
L_002CDD: ; 0x002CDD, $FCDD
    LEAY  64,Y ; += 64
    CMPY  #$A000 ; Cmp to 
    BNE   Y_!=_A000 ; !=, goto.
L_002CE6: ; 0x002CE6, $FCE6
    LDY   #$9C00 ; Cap val
Y_!=_A000: ; 0x002CEA, $FCEA
    CMPY  R_A0E2_UNK_REPLACED_BMP_VAR ; Cmp Y to
    BEQ   RTS+RESTORE ; ==, goto.
    LDA   Y ; A from Y
    BMI   L_002CDD ; If minus, goto.
    BEQ   SKIP_SUB ; If zero, goto.
    JSR   L_002DD5 ; Otherwise, sub.
SKIP_SUB: ; 0x002CF8, $FCF8
    STY   R_A0E2_UNK_REPLACED_BMP_VAR ; Store Y
    LDD   #$0100 ; D val
    STD   Y ; Store to Y
    LDD   2,X ; Store to XOBJ[2]
    STD   2,Y ; Store to YOBJ[2]
    LEAU  64,Y ; +=64
    STU   4,Y ; U to YOBJ[4]
    LDD   $A0E9 ; D from
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    LDB   12,X ; B from XOBJ[12]
    STD   8,Y ; D to YOBJ[8]
    SUBD  $A0F8 ; D -= addr
    LDU   2,Y ; U to YOBJ[2]
    ADDA  U ; Add a with @U
    BHS   L_002D23 ; >= prev, goto.
    ADDB  1,U ; Add B from @U+1
    BHS   L_002D23 ; >= prev, goto.
    LDD   $A0F8 ; D from addr
    BRA   L_002D29 ; Always goto.
L_002D23: ; 0x002D23, $FD23
    LDD   U ; D from @U
    LSRA ; D >> 1
    LSRB
    ADDD  8,Y ; Add with YOBJ[8]
L_002D29: ; 0x002D29, $FD29
    STD   6,Y ; D to YOBJ[6]
RTS+RESTORE: ; 0x002D2B, $FD2B
    PULS  A,B,Y,U,PC ; RTS
L_002D2D: ; 0x002D2D, $FD2D
    LDY   #$9C00 ; Y with val
L_002D31: ; 0x002D31, $FD31
    LDA   A0BA_PLAYER_GAME_STATE ; Load state
    BITA  #$04 ; Test
    BEQ   L_002D43 ; Not set, goto.
    LDA   Y ; A from Y
    BMI   L_002D91 ; If negative, goto.
    LDD   #$0000 ; D=0
    STD   Y ; Store to Y
    JMP   L_002DC9 ; Goto
L_002D43: ; 0x002D43, $FD43
    LDD   Y ; D from Y
    LBEQ  L_002DC9 ; If 0, goto.
    BMI   L_002D7E ; If negative, goto.
    ADDD  #$00AA ; Add with
    STD   Y ; D to Y
    CMPA  #$30 ; Cmp top
    BLS   LOTS_OF_D_MANIP ; <=, goto.
    JSR   L_002DD5 ; Do sub
    LDD   #$0000 ; D=0
    STD   Y ; To Y
    BRA   L_002DC9
LOTS_OF_D_MANIP: ; 0x002D5E, $FD5E
    LDD   R_A020_SCREEN_POS_CHANGE? ; D from
    ANDB  #$C0 ; Get bits 1100.0000
    PSHS  B,A ; Save D
    LDD   R_A022_UNK ; D from
    ANDB  #$C0 ; Get bits 1100.0000
    SUBD  S++ ; Sub D with pushed.
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    PSHS  A ; Save upper.
    LDA   6,Y ; A from YOBJ[6]
    ADDA  S ; Add with other upper.
    STA   6,Y ; To YOBJ[6]
    LDA   8,Y ; A from YOBJ[8]
    ADDA  S+ ; Add with stack.
    STA   8,Y ; Store to YOBJ[8]
    BRA   L_002DC3 ; Goto
L_002D7E: ; 0x002D7E, $FD7E
    SUBD  #$0100 ; D -= val
    STD   Y ; D to Y
    BPL   L_002D91 ; If positive, goto.
    LDX   10,Y ; X from YOBJ[10]
    LDD   10,X ; D from XOBJ[10]
    SUBD  R_A020_SCREEN_POS_CHANGE? ; D -= addr
    ADDA  #$0C ; A += #$0C
    BITA  #$C0 ; Test 1100.0000
    BEQ   L_002DA9 ; If equal, goto.
L_002D91: ; 0x002D91, $FD91
    LDD   #$0000 ; D = 0
    STD   Y ; D to Y.next?
    LDD   2,Y ; D from YOBJ[2]
    LDX   10,Y ; X from YOBJ[10]
    STD   2,X ; D to XOBJ[2]
    LDA   20,X ; A from XOBJ[20]
    ANDA  #$FD ; Save 1111.1101
    STA   20,X ; to XOBJ[20]
    JSR   L_002DD5 ; Do sub
    BRA   L_002DC9
L_002DA9: ; 0x002DA9, $FDA9
    SUBA  #$0C ; A -= #$0C
    ASLB ; D << 2
    ROLA
    ASLB
    ROLA
    LDB   12,X ; B from XOBJ[12]
    STD   8,Y ; D to YOBJ[8]
    LDB   #$DA ; D =
    MUL ; A*B
    ASLA ; << 1
    LDU   2,Y ; U from YOBJ[2]
    LDB   U ; B from U[0]
    MUL ; A*B
    LDB   1,U ; B from UOBJ[1]
    LSRB ; >> 1
    ADDD  8,Y ; D += YOBJ[8]
    STD   6,Y ; D to YOBJ[6]
L_002DC3: ; 0x002DC3, $FDC3
    JSR   L_002DD5 ; Do sub
    JSR   L_002DEF ; Do sub
L_002DC9: ; 0x002DC9, $FDC9
    LEAY  64,Y ; Y += 64
    CMPY  #$A000 ; CMP
    LBNE  L_002D31 ; !=, goto.
    RTS ; RTS
L_002DD5: ; 0x002DD5, $FDD5
    PSHS  X,B,A ; Save
    LDD   #$0000 ; D =  0
    LEAX  64,Y ; X = Y + 64
    STX   $A0F3 ; X to addr
    LDX   4,Y ; X from YOBJ[4]
    CMPX  $A0F3 ; CMP to stored.
    BEQ   RTS ; ==, goto.
LOOP_TO_$A0F3: ; 0x002DE5, $FDE5
    STD   [X++] ; D to
    CMPX  $A0F3 ; Cmp to addr
    BNE   LOOP_TO_$A0F3
    STX   4,Y ; X to YOBJ[4]
RTS: ; 0x002DED, $FDED
    PULS  A,B,X,PC
L_002DEF: ; 0x002DEF, $FDEF
    PSHS  U,Y,X,B,A ; Save
    STY   $A0F6 ; Y to addr
    LDA   Y ; A from Y
    ANDA  #$7F ; Save 0111.1111
    STA   $A0E7 ; Store to
    LEAU  64,Y ; U = Y + 64
    CLR   $A0E6 ; Clear addr
    LDX   2,Y ; X from YOBJ[2]
    LDD   2,X ; D from XOBJ[2]
    STD   $A0F3 ; D to
    LDD   X ; D from X
    STA   $A0F1 ; A to.
    STB   $A0F2 ; B to. Idk why not STD above. Mistake?
    BITB  #$01 ; Test bit
    BNE   L_002E14 ; If set, goto.
    LDX   #$FF27 ; Ptr to ?
    BRA   L_002E17 ; Goto
L_002E14: ; 0x002E14, $FE14
    LDX   #$FEF3 ; Ptr to ?
L_002E17: ; 0x002E17, $FE17
    STX   R_A0ED ; X to addr
    LDD   6,Y ; D from YOBJ[6]
    SUBD  8,Y ; D -= YOBJ[8]
    STA   $A0E4 ; A to
    LSRB ; B >> 1
    STB   $A0E5 ; B to. Mistake no STD again?
    ROL   $A0E6 ; << 1 addr
    LDA   $A0E7 ; A from
    LDB   $A0E4 ; B from
    MUL ; Multiply
    STD   $A0E9 ; D to
    LDB   6,Y ; B from YOBJ[6]
    CLRA ; Clear A
    SUBD  $A0E9 ; D -= addr
    STD   $A0E9 ; D to addr.
LOOP_A_TEST: ; 0x002E32, $FE32
    TSTA ; Test A
    BEQ   L_002E4D ; == 0, goto.
    LDD   $A0F3 ; D from
    ADDB  $A0F2 ; B += addr
    ADCA  #$00 ; Carry to upper.
    STD   $A0F3 ; D to
    DEC   $A0F1 ; Dec addr
    LBEQ  L_002F35 ; If 0, goto.
    LDD   $A0E9 ; D from
    ADDB  $A0E7 ; B += addr
    ADCA  #$00 ; Carry to upper.
    STD   $A0E9 ; D to.
    BRA   LOOP_A_TEST ; Loop
L_002E4D: ; 0x002E4D, $FE4D
    CMPB  #$98 ; If B _ #$98
    LBHI  L_002F35 ; >, goto.
    LDA   $A0E7 ; A from
    ASLA ; << 1
    STA   $A0E8 ; To
    LDB   $A0E5 ; B from
    MUL ; A * B
    STD   $A0EB ; D to
    LDB   7,Y ; B from YOBJ[7]
    CLRA ; Clear A
    SUBD  $A0EB ; D -= addr
    SUBB  $A0E6 ; B -= addr
    ADCA  #$00 ; Add 1 to A if sub borrowed to bit 7.
    CLR   $A0F5 ; Clear
L_002E68: ; 0x002E68, $FE68
    TSTA ; Test A
    BNE   L_002E6F ; != 0, goto.
    CMPB  #$2A ; B _ #$2A
    BHS   L_002E7F ; >=, goto.
L_002E6F: ; 0x002E6F, $FE6F
    INC   $A0F5 ; Addr += 1
    DEC   $A0F2 ; Addr -= 2
    DEC   $A0F2
    LBLE  L_002F35 ; If val <= original, goto.
    ADDB  $A0E8 ; B += addr
    ADCA  #$00 ; Carry into high byte.
    BRA   L_002E68 ; Goto
L_002E7F: ; 0x002E7F, $FE7F
    STD   $A0EB ; D to
    LDA   $A0F2 ; A from
    ANDA  #$FE ; First bit 0?
    LDX   #$FF48 ; X from
    LDX   A,X ; X from X+A
    STX   R_A0EF ; X to addr
    LDX   $A0F3 ; X from
    ASL   $A0F5 ; addr << 1
    LDA   $A0EA ; A from addr
L_002E92: ; 0x002E92, $FE92
    LDB   $A0F5 ; B from
    ABX ; X += B
    LDB   $A0EC ; B from
    JMP   [R_A0EF] ; Goto addr pointed by.
    STD   --U ; D to --U
    LDY   X++ ; Y from X
    STY   [U] ; U to pointed by U
    ADDB  $A0E8 ; B += addr
    BLO   X+=12_JMP ; If lower, goto.
    STD   --U ; D to --U
    LDY   X++ ; Y from X
    STY   [U] ; Y to @U
    ADDB  $A0E8 ; B += addr
    BLO   X+=10_JMP ; If lower, goto.
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  $A0E8 ; B += addr
    BLO   X+=8_JMP ; If lower, goto.
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  $A0E8 ; B += addr
    BLO   X+=6_JMP ; If lower, goto.
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  $A0E8 ; B += addr
    BLO   X+=4_JMP ; If lower, goto.
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  $A0E8 ; B += addr
    BLO   X+=2_JMP ; If lower, goto.
    STD   --U ; D to --U
    LDY   X++ ; Y from X++
    STY   [U] ; Y to @U
    ADDB  $A0E8 ; B += addr
    BLO   X+=0_JMP ; If lower, goto.
    JMP   [R_A0ED] ; Goto @Addr
    BLO   L_002F25 ; Callback? If lower, goto.
    STD   --U ; D to --U
    LDB   X+ ; B from X+
    STB   [U] ; B to @U
    BRA   L_002F27 ; Goto
X+=12_JMP: ; 0x002EFD, $FEFD
    LEAX  12,X
    JMP   [R_A0ED]
X+=10_JMP: ; 0x002F03, $FF03
    LEAX  10,X
    JMP   [R_A0ED]
X+=8_JMP: ; 0x002F09, $FF09
    LEAX  8,X
    JMP   [R_A0ED]
X+=6_JMP: ; 0x002F0F, $FF0F
    LEAX  6,X
    JMP   [R_A0ED]
X+=4_JMP: ; 0x002F15, $FF15
    LEAX  4,X
    JMP   [R_A0ED]
X+=2_JMP: ; 0x002F1B, $FF1B
    LEAX  2,X
    JMP   [R_A0ED]
X+=0_JMP: ; 0x002F21, $FF21
    JMP   [R_A0ED]
L_002F25: ; 0x002F25, $FF25
    LEAX  1,X ; X += 1
L_002F27: ; 0x002F27, $FF27
    DEC   $A0F1 ; Dec addr
    BEQ   L_002F35 ; If 0, goto.
    ADDA  $A0E7 ; A += addr
    BLO   L_002F35 ; If lower, goto.
    CMPA  #$98 ; If A _ #$98
    LBLS  L_002E92 ; <=, goto.
L_002F35: ; 0x002F35, $FF35
    LDX   $A0F6 ; X from addr
    STU   4,X ; U to XOBJ[4]
    LDD   6,X ; D from XOBJ[6]
    CMPA  #$98 ; If A _ #$98
    BHI   RTS+RESTORE ; If >, goto.
    SUBB  $A0E6 ; B -= addr
    LDX   #$0000 ; X = 0
    STX   D,X ; 0 to X+D, pretty nifty.
RTS+RESTORE: ; 0x002F46, $FF46
    PULS  A,B,X,Y,U,PC ; RTS
    .db $FE
    .db $EF
    .db $FE
    .db $E3
    .db $FE
    .db $D7
    .db $FE
    .db $CB
    .db $FE
    .db $BF
    .db $FE
    .db $B3
    .db $FE
    .db $A7
    .db $FE
    .db $9B
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
DATA_W_F8EC: ; 0x002F9D, $FF9D
    .db $F8
    .db $EC
DATA_W_$F86E: ; 0x002F9F, $FF9F
    .db $F8
    .db $6E
JMP_GET_DATA_FROM_SRAM[X]: ; 0x002FA1, $FFA1
    JMP   GET_DATA_FROM_SRAM[X]_IN_A
JMP_GET_DATA_FROM_SRAM@X_IN_B: ; 0x002FA4, $FFA4
    JMP   GET_DATA_FROM_SRAM[X]_IN_B
JMP_GET_DATA_FROM_SRAM@X_IN_AB: ; 0x002FA7, $FFA7
    JMP   GET_DATA_FROM_SRAM[X]_IN_AB
JMP_STORE_A_TO_SRAM_@X_BANKED: ; 0x002FAA, $FFAA
    JMP   STORE_A_TO_SRAM[X]_BANKED
JMP_STORE_B_TO_SRAM[X]: ; 0x002FAD, $FFAD
    JMP   STORE_B_TO_SRAM[X]
JMP_STORE_D_TO_SRAM[X]: ; 0x002FB0, $FFB0
    JMP   STORE_D_TO_SRAM[X]
JMP_GFX_BANK2_CHR_TO_SCREEN: ; 0x002FB3, $FFB3
    JMP   GFX_BANK2_CHR_TO_SCREEN ; Puts bank 2 char to screen.
JMP_GFX_BANK2_CHR_CLEAR: ; 0x002FB6, $FFB6
    JMP   GFX_BANK2_CHR_CLEAR ; Clears bank 2 char from screen.
L_002FB9: ; 0x002FB9, $FFB9
    JMP   CLEAR_SCREEN_FLEX_SETUP
JMP_CLEAR_ALL_SCREEN: ; 0x002FBC, $FFBC
    JMP   CLEAR_ALL_SCREEN
JMP_ROM_CHECK_START: ; 0x002FBF, $FFBF
    JMP   ROM_CHECK_START
JMP_CORRECT_CHECKSUM: ; 0x002FC2, $FFC2
    JMP   CORRECT_CHECKSUM
JMP_RUG_SETUP: ; 0x002FC5, $FFC5
    JMP   RUG_PATTERN_SETUP
JMP_TO_RUG_PASS_SRAM_CHECK: ; 0x002FC8, $FFC8
    JMP   RUG_PASS_SRAM_CHECK
JMP_TO_GOTO_B7-C000: ; 0x002FCB, $FFCB
    JMP   GOTO_B7-C000
JMP_GOTO_PAST_JSR: ; 0x002FCE, $FFCE
    JMP   GOTO_PAST_JSR
JMP_TO_R_A063_OBJ_SETUP_BANKED_HANDLER?: ; 0x002FD1, $FFD1
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
JMP_STORE_B@X_BANK0: ; 0x002FD4, $FFD4
    JMP   STORE_B[X]_BANK0
LOAD_B@X_BANK0: ; 0x002FD7, $FFD7
    JMP   LOAD_B[X]_BANK0
JMP_SET_A0B0-A0B3_WHEN_@D>A0B2: ; 0x002FDA, $FFDA
    JMP   SET_A0B0-A0B3_WHEN_@D>A0B2_SOUND_SET?
DATA_W_2CAC: ; 0x002FDD, $FFDD
    .db $D4
    .db $EE
    .db $2A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $F6 ; Interrupt vectors.
    .db $1F
    .db $F6
    .db $1F
    .db $F6
    .db $1F
    .db $F6
    .db $1F
    .db $A0 ; IRQ, Goes to $A08F in RAM.
    .db $8F
    .db $F6
    .db $1F
    .db $F6
    .db $1F
    .db $F6
    .db $1F

;Bank 1
	.org $C000

JMP_ATTRACT_START?: ; 0x003000, $C000
    JMP   ATTRACT_START? ; Main screen loop?
    JMP   L_003CAD
ATTRACT_START?: ; 0x003006, $C006
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Sort
    LDA   #$FF ; Player state.
    STA   A0BA_PLAYER_GAME_STATE ; Game state.
    JSR   INIT_STARS ; Init stars
    LDA   VAL_FROM_SRAM_C495-C496 ; Get sram val
    STA   R_A183_VAL_FROM_SRAM ; Store
    CLRA
    STA   R_A184 ; Clear
    STA   R_A178_LEAVE_INITIAL_FLAG? ; Clear
    LDA   R_A0B7_UNK_ATTRACT_CHECKS ; A from addr.
    LBEQ  FIRST_ATTRACT_INTRO_WILLIAMS? ; If 0, goto.
    LDX   #$C8F4 ; Show credits handler.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE ; Schedule task.
    LDY   #$A1C2 ; Score ptr?
    LDA   #$01 ; Normal.
PUT_IN_OTHER_PLAYER_INITIALS: ; 0x003030, $C030
    STA   R_A006_SCORE_POS_CHAR ; A to
    STY   R_A17B ; Y to.
    LDX   #$B2B4 ; Ptr to daily scores?
    JSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER
    LBHS  PLAYER_SCORE_LOWER_THAN_TABLE_ENTRY ; Table >=, goto.
    INC   R_A178_LEAVE_INITIAL_FLAG? ; Inc IDK
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    LDA   R_A006_SCORE_POS_CHAR ; Index into table?
    DECA ; -=1
    BNE   ENTERING_P2_INITIALS ; P2, flip.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED ; Set normal watchdog.
    BRA   SKIP_OTHER_WATCHDOG
ENTERING_P2_INITIALS: ; 0x003050, $C050
    JSR   SET_WATCHDOG_GAMEPLAY? ; Set possibly flipped watchdog.
SKIP_OTHER_WATCHDOG: ; 0x003053, $C053
    LDB   #$85 ; R=4/7,G=1/7,B=1/3, purple?
    STB   COLOR_PALETTE_RAM_COPY+1 ; Set color 1.
    LDA   #$3E ; Used post JSR
    LDX   #$B260 ; Todays greatest list?
    JSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER
    BHS   SKIP_LOAD_A ; If D/A >= Y[1]/Y[3]
    LDA   #$3D ; A = 0011.1101
SKIP_LOAD_A: ; 0x003063, $C063
    LDX   #$CC02 ; X =
    LDB   #$3F ; Store 0011.1111
    JSR   JMP_STORE_B@X_BANK0
    LDB   #$24 ; Store 0010.0100
    JSR   JMP_STORE_B@X_BANK0
WAIT_A_LITTLE: ; 0x003070, $C070
    DECB ; B--
    BNE   WAIT_A_LITTLE ; For sound board to read val.
    LDB   #$3F ; Store 0011.1111
    JSR   JMP_STORE_B@X_BANK0
    TFR   A>B ; A from above, 3E or 3D.
    JSR   JMP_STORE_B@X_BANK0 ; Store to
    LDU   #$C0ED ; SENTENCE ELETRONICS INC. PRESENTS
    LDA   R_A006_SCORE_POS_CHAR ; Get val from
    ASLA ; << 1, *2
    LEAU  A,U ; U += A, U is now either PLAYER ONE or PLAYER TWO sentence ptrs.
    LDX   #$3E38
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $02
    .db $02
    LDU   #$C0FD ; SENTENCE YOU HAVE COMPLETED...
    LDX   #$1458
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $02
    .db $02
    LDD   #$412F ; Move to A000-A001
    STD   $A000 ; D to
    LDA   #$40 ; A =
    STD   R_A002 ; D to
    STD   $A004 ; D to
    JSR   A000,A002,A004_TO_SCREEN ; To screen
    LDA   #$28 ; A to
    STA   INITIAL_ENTER_TIMER?
    LDX   #$C1DC ; Callback timer for input?
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$C1E7 ; Callback PALETTE[13] rotate
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$C1FA ; Callback char select.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    CLR   INITIAL_POS_INDEX ; Clear idk
    JSR   L_00316B ; Do sub
L_0030CB: ; 0x0030CB, $C0CB
    CLRA ; Clear addr's.
    STA   R_A186
    STA   R_A185
L_0030D2: ; 0x0030D2, $C0D2
    LDA   #$01
    LDX   #$C0DA
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDA   WGT_DATA_A_RAM_COPY
    BITA  #$01
    BNE   L_0030F4
    TST   INITIAL_ENTER_TIMER?
    BEQ   L_00310E
    INC   R_A186
    LDA   R_A186
    CMPA  #$05
    BNE   L_0030D2
    STA   R_A185
    BRA   L_0030D2
L_0030F4: ; 0x0030F4, $C0F4
    CLR   R_A186
    TST   R_A185
    BEQ   L_0030D2
    LDA   #$14
    STA   INITIAL_ENTER_TIMER?
    INC   INITIAL_POS_INDEX
    JSR   L_00316B
    LDA   INITIAL_POS_INDEX
    CMPA  #$03
    BNE   L_0030CB
L_00310E: ; 0x00310E, $C10E
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2
    LDX   #$B2A8
    LDU   #$B254
    JSR   L_003194
    LDX   #$C471
    BSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER
    BHS   PLAYER_SCORE_LOWER_THAN_TABLE_ENTRY
    LDX   #$C465
    LDU   #$C411
    JSR   L_003194
PLAYER_SCORE_LOWER_THAN_TABLE_ENTRY: ; 0x00312A, $C12A
    LDY   #$A1FF ; Load P2 score ptr?
    LDA   R_A006_SCORE_POS_CHAR ; Load which player put in initials.
    INCA ; ++
    CMPA  #$03 ; If was 2, done.
    LBNE  PUT_IN_OTHER_PLAYER_INITIALS ; Wasn't 2, goto.
    TST   R_A178_LEAVE_INITIAL_FLAG? ; Test addr
    BNE   SKIP_SCHEDULE_TO_HERE ; Set, don't schedule.
    LDA   #$FF ; Schedule callback way into future.
    LDX   #$C144
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
SKIP_SCHEDULE_TO_HERE: ; 0x003144, $C144
    JMP   SHOW_HIGH_SCORE_TABLES?
HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER: ; 0x003147, $C147
    PSHS  X,B,A ; Save
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB ; Abuse to get X lower bits only?
    CMPD  1,Y ; If D _ Y[1]
    BNE   RTS ; !=, goto, got >= result val we need.
    JSR   GET_DATA_FROM_SRAM[X]_IN_A ; Get 3rd byte.
    CMPA  3,Y ; If A _ Y[3]
RTS: ; 0x003156, $C156
    PULS  A,B,X,PC ; RTS CMP results.
A000,A002,A004_TO_SCREEN: ; 0x003158, $C158
    LDX   #$46AC
    LDD   #$1408
    JSR   CLEAR_SCREEN_FLEX_SETUP
    LDU   #$C0FF ; PTR to A000, A002, A004
    JSR   JMP_GOTO_PAST_JSR ; To screen.
    .db $C0
    .db $02
    .db $02
    RTS ; RTS
L_00316B: ; 0x00316B, $C16B
    CLR   DRAW_CMD_TEMP?
    LDX   #$45B7
L_003171: ; 0x003171, $C171
    LDU   #$1111
    LDA   DRAW_CMD_TEMP?
    CMPA  INITIAL_POS_INDEX
    BNE   L_00317F
    LDU   #$DDDD
L_00317F: ; 0x00317F, $C17F
    LDD   #$0400
L_003182: ; 0x003182, $C182
    STU   D,X
    DECA
    BNE   L_003182
    INC   DRAW_CMD_TEMP?
    LEAX  2048,X
    CMPX  #$5DB7
    BNE   L_003171
    RTS
L_003194: ; 0x003194, $C194
    STU   R_A164_HIGHSCORE_DATA_POS
    LDY   R_A17B
L_00319B: ; 0x00319B, $C19B
    BSR   HIGH_SCORE_TEST_IF_REPLACE_Y=PLAYER,X=RAM_CMPTBL2PLAYER
    BHS   L_0031A8
    BSR   L_0031C5
    LEAX  -12,X
    CMPX  R_A164_HIGHSCORE_DATA_POS
    BHI   L_00319B
L_0031A8: ; 0x0031A8, $C1A8
    LEAX  12,X
    LDD   1,Y
    JSR   STORE_D_TO_SRAM[X]
    LDA   3,Y
    JSR   STORE_A_TO_SRAM[X]_BANKED
    LDU   #$A000
L_0031B7: ; 0x0031B7, $C1B7
    LDA   U
    JSR   STORE_A_TO_SRAM[X]_BANKED
    LEAU  2,U
    CMPU  #$A006
    BNE   L_0031B7
    RTS
L_0031C5: ; 0x0031C5, $C1C5
    PSHS  X
L_0031C7: ; 0x0031C7, $C1C7
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB
    LEAX  8,X
    JSR   STORE_D_TO_SRAM[X]
    LEAX  -24,X
    CMPX  S
    BEQ   RTS
    LEAX  12,X
    BRA   L_0031C7
RTS: ; 0x0031DA, $C1DA
    PULS  X,PC
    DEC   INITIAL_ENTER_TIMER?
    LDA   #$3C ; Set callback.
    LDX   #$C1DC
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_COLOR_ROTATE: ; 0x0031E7, $C1E7
    LDA   COLOR_PALETTE_RAM_COPY+13
    BNE   CLEAR_COLOR
    LDA   COLOR_PALETTE_RAM_COPY+1 ; Color from slot 1
    BRA   COMMIT_A_T_COLOR
CLEAR_COLOR: ; 0x0031EF, $C1EF
    CLRA
COMMIT_A_T_COLOR: ; 0x0031F0, $C1F0
    STA   COLOR_PALETTE_RAM_COPY+13
    LDA   #$0F
    LDX   #$C1E7
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    CLR   PREV_CHAR_MOVEMENT ; Clear var.
    LDA   WGT_DATA_A_RAM_COPY ; Get input.
    BITA  #$80 ; Test DOWN
    BEQ   DOWN_NOT_PRESSED
    LDA   #$FF ; -1
    BRA   MOVE_CHAR
DOWN_NOT_PRESSED: ; 0x003207, $C207
    LDA   WGT_DATA_B_RAM_COPY ; Get input.
    BITA  #$01 ; Test UP.
    BEQ   UP_NOT_PRESSED
    LDA   #$01 ; +1
    BRA   MOVE_CHAR
UP_NOT_PRESSED: ; 0x003211, $C211
    CLR   PREV_CHAR_MOVEMENT ; Clear addr.
    BRA   SETUP_INITIAL_CHANGE_CALLBACK ; Goto
MOVE_CHAR: ; 0x003216, $C216
    CMPA  PREV_CHAR_MOVEMENT ; If A _ val
    BNE   INITIAL_MOVEMENT_SAME ; !=, goto.
    DEC   R_A17F ; Dec idk
    BNE   SETUP_INITIAL_CHANGE_CALLBACK ; If not 0, goto.
    LDX   #$A000 ; X ptr to initial index.
    LDB   INITIAL_POS_INDEX ; B from addr
    ASLB ; B << 1, *2
    ABX ; X += B
    LDA   X ; A from X
    ADDA  PREV_CHAR_MOVEMENT ; A += reg
    CMPA  #$3F ; If A _ #$3F
    BNE   DONT_ROLL_MAX ; !=, goto.
    LDA   #$5A ; ==, roll to max.
DONT_ROLL_MAX: ; 0x003233, $C233
    CMPA  #$5B ; !=, goto.
    BNE   OUTPUT_INITIAL ; !=, goto. roll to min if ==.
    LDA   #$40 ; ==, roll to min.
OUTPUT_INITIAL: ; 0x003239, $C239
    STA   X ; A (initial val) to ptr
    JSR   A000,A002,A004_TO_SCREEN ; Initials to screen.
    LDA   R_A17E ; A from addr
    LSRA ; >> 1, /2
    ADDA  #$05 ; += 5
    STA   R_A17E ; Store back to.
    STA   R_A17F ; Also store here?
SETUP_INITIAL_CHANGE_CALLBACK: ; 0x00324A, $C24A
    LDA   #$01 ; Callback for initial change.
    LDX   #$C1FD
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
INITIAL_MOVEMENT_SAME: ; 0x003252, $C252
    STA   PREV_CHAR_MOVEMENT
    LDA   #$37
    STA   R_A17E
    LDA   #$03
    STA   R_A17F
    BRA   SETUP_INITIAL_CHANGE_CALLBACK ; Goto
    LDU   $A0FF
SHOW_HIGH_SCORE_TABLES?: ; 0x003263, $C263
    CLR   DRAW_CMD_TEMP? ; Clear drawn last.
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Sort objs.
    JSR   DEFENDER_LOGO_TO_RAM? ; Get logo in buffer.
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    JSR   SAVE_BANK+SET_WATCHDOG_NONFLIPPED ; Set to 1P pos.
    CLR   COLOR_PALETTE_RAM_COPY+1 ; Clear letter color.
    LDX   #$C8F4 ; Schedule showing credits.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    JSR   DISPLAY_PREVIOUS_GAMES_SCORES ; Display scores on the top left and right corners.
    LDU   #$C101 ; PTR to SENTENCE HALL OF FAME
    LDX   #$3854 ; Pos
    JSR   JMP_GOTO_PAST_JSR ; Put to screen.
    .db $C0
    .db $02
    .db $02
    LDU   #$1111
    LDX   #$1E7B ; Pos on screen min.
    LDD   #$5F00 ; Initial line pos.
LOOP_DRAW_LINE: ; 0x003294, $C294
    STU   D,X ; U to X+D
    CMPA  #$41 ; If ==, move.
    BNE   SKIP_MOVE_LINE_TO_LEFT ; Skip move.
    LDA   #$1F
SKIP_MOVE_LINE_TO_LEFT: ; 0x00329C, $C29C
    DECA ; X-1
    BPL   LOOP_DRAW_LINE ; Write to 0.
    LDA   #$2F ; End of text marker for groups.
    STA   R_A007_IRQ_STACK_VAL_2 ; Store to
    STA   A00B_PLANET_GEN_DATA_PTR ; Store to
    STA   A012_PLANET_HEIGHT_CREATING ; Store to.
    LDU   #$C103 ; Ptr to high score text data.
    LDX   #$1886 ; Screen pos?
    STX   R_A181_HIGHSCORE_SCR_POS
    LDX   #$B260 ; Table POS?
    STX   R_A164_HIGHSCORE_DATA_POS
    BSR   SUB_FIGURE+SHOW_SCORE_TEXT
    LDX   #$5986 ; Screen pos?
    STX   R_A181_HIGHSCORE_SCR_POS
    LDX   #$C41D ; Table POS?
    STX   R_A164_HIGHSCORE_DATA_POS
    BSR   SUB_FIGURE+SHOW_SCORE_TEXT
    LDA   #$3F
    STA   COLOR_PALETTE_RAM_COPY+12
    LDY   #$B300 ; Ptr to obj.
    LDD   #$3C18 ; Size
    STD   Y ; To pos.
    LDD   #$B412 ; Ptr
    STD   2,Y ; To fake obj.
    LDD   #$3038 ; Screen POS.
    JSR   GFX_BANK2_CHR_TO_SCREEN ; Put DEFENDER to screen.
    LDX   #$E782 ; Schedule rotating color for text.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDA   #$3C
    STA   INITIAL_ENTER_TIMER? ; Timer for screen.
CALLBACK_WAIT_HIGH_SCORES: ; 0x0032EB, $C2EB
    TST   R_A184 ; Test addr.
    BNE   GO_TO_ATTRACT_DEMO ; If set, goto demo.
    TST   DRAW_CMD_TEMP?
    LBNE  SHOW_HIGH_SCORE_TABLES? ; Keep showing tables.
    DEC   INITIAL_ENTER_TIMER? ; Timer--
    BEQ   GO_TO_ATTRACT_DEMO
    LDA   #$0A ; Callback to display high scores.
    LDX   #$C2EB
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
GO_TO_ATTRACT_DEMO: ; 0x003304, $C304
    BRA   ATTRACT_GAME_DEMO_MAIN
SUB_FIGURE+SHOW_SCORE_TEXT: ; 0x003306, $C306
    LDA   #$31 ; "1" char val.
    STA   R_A006_SCORE_POS_CHAR ; Store pos.
LOOP_SCORES_TO_SCREEN: ; 0x00330A, $C30A
    CLRA ; Clear 
    LDY   #$A00C ; Ptr to loc.
    LDX   R_A164_HIGHSCORE_DATA_POS ; Initial pointer.
LOOP_CREATE_SCORE_STRING: ; 0x003312, $C312
    JSR   LOAD_B@X_BANK0 ; Get SRAM data.
    LEAX  1,X ; X++
    ANDB  #$0F ; Get bits.
    BNE   A++,B+=30 ; If not 0, show digit.
    TSTA ; Test A
    BNE   A++,B+=30 ; Not 0, display.
    LDB   #$40 ; Space val.
    BRA   SKIP_CHAR_WITH_SPACE
A++,B+=30: ; 0x003322, $C322
    INCA ; Flag displayed actual number.
    ADDB  #$30
SKIP_CHAR_WITH_SPACE: ; 0x003325, $C325
    STB   Y+ ; Write string.
    CMPY  #$A012
    BNE   LOOP_CREATE_SCORE_STRING ; Not done.
    JSR   GET_DATA_FROM_SRAM[X]_IN_AB
    STD   HIGHSCORE_INITIALS_ADDR ; Write initials.
    JSR   GET_DATA_FROM_SRAM[X]_IN_A
    STA   HIGHSCORE_INITIALS_ADDR+2 ; 3x
    STX   R_A164_HIGHSCORE_DATA_POS
    LDX   R_A181_HIGHSCORE_SCR_POS ; Text ptr from
    JSR   JMP_GOTO_PAST_JSR ; Put strings to screen.
    .db $C0
    .db $02
    .db $02
    LEAX  10,X ; X += 10
    STX   R_A181_HIGHSCORE_SCR_POS ; X to
    INC   R_A006_SCORE_POS_CHAR ; ++
    LDA   R_A006_SCORE_POS_CHAR ; A from
    CMPA  #$39 ; If A _ val
    BNE   LOOP_SCORES_TO_SCREEN ; !=, loop. 1 to 8 score loop?
    RTS
ATTRACT_GAME_DEMO_MAIN: ; 0x003351, $C351
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Sort lists.
    JSR   ATTRACT_GAME_DEMO_INIT ; Init data.
    LDA   #$D9
    STA   A0BA_PLAYER_GAME_STATE ; Store new state.
    JSR   DISPLAY_PREVIOUS_GAMES_SCORES ; Show last game scores in scanner.
    LDX   #$C8F4 ; Schedule show credits.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    JSR   SCANNER_TO_SCREEN ; Scanner to the screen.
    LDX   #$CC63
    STX   R_A196_ATTRACT_TEXT_CURRENT
    LDX   #$E782 ; Schedule rotating color.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$F464 ; Schedule rotating color 2.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$F43D ; Schedule rotating color 3.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$E9E3 ; Schedule IDK.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$C64F ; Schedule IDK.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get 23B obj onscreen.
    LDD   #$0000 ; Clear
    STD   14,X ; OBJ[14]
    STD   16,X ; OBJ[16]
    LDD   #$1E00 ; World pos?
    STD   10,X ; To OBJ[10]
    LDD   #$DB00 ; Not sure of val.
    STD   12,X ; To OBJ[12]
    LDD   #$F901 ; PTR to BMP?
    STD   2,X ; OBJ[2]
    STX   LIST_$65_ON_SCREEN? ; Object is made to be THE on screen object?
    LDD   #$6666 ; Idk val
    STD   18,X ; OBJ[18]
    STX   R_A189_OBJ_TMP? ; Store obj pointer here.
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get next obj.
    LDD   #$0000 ; Clear
    STD   14,X ; OBJ[14]
    STD   16,X ; OBJ[16]
    LDD   #$0800 ; World pos?
    STD   10,X ; OBJ[10]
    LDD   #$5000 ; Val
    STD   12,X ; OBJ[12]
    LDD   #$F9C1 ; Bitmap IDK
    STD   2,X ; BMP ptr?
    STX   LIST_$65_ON_SCREEN? ; Add to screen list.
    LDD   #$0000
    STD   18,X ; Clear OBJ[18]
    STX   R_A18B_OBJ_PTR_SHIP? ; Store OBJ to
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get another onscreen.
    LDD   #$F985 ; Bitmap IDK
    STD   2,X ; OBJ[2]
    LDD   #$1DA0 ; World pos?
    STD   10,X ; OBJ[10]
    LDD   #$4000 ; IDK
    STD   12,X ; OBJ[12]
    LDD   #$00A0 ; Idk val
    STD   16,X ; OBJ[16]
    LDD   #$0000 ; Idk val
    STD   14,X ; OBJ[14]
    LDD   #$4433 ; Idk val
    STD   18,X ; OBJ[18]
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN?
    STX   R_A18D_OBJ_TMP_3? ; Store obj here.
    LDA   #$E6 ; Schedule code below.
    LDX   #$C412
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDD   #$FF50 ; Vertical movement value?
    LDX   R_A18D_OBJ_TMP_3? ; Object ptr
    STD   16,X
    LDX   R_A189_OBJ_TMP? ; Object ptr.
    STD   16,X
    LDA   #$A0 ; Setup callback below.
    LDX   #$C429
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   #$C5F5
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE ; Schedule future task.
    STX   R_A187_OBJ_TMP_4? ; New obj to. Laser?
    LDA   #$15
    LDX   #$C475
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
ATTRACT_GAME_DEMO_INIT: ; 0x00343C, $C43C
    LDA   #$FF
    STA   A0BA_PLAYER_GAME_STATE ; Set state
    JSR   CHAIN_LIST_$67,NULL_$65_$6B_$6D ; Setup enemies?
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    LDD   #$0000
    STD   R_A020_SCREEN_POS_CHANGE? ; Clear
    STD   R_A022_UNK ; Clear
    JSR   JMP_GOTO_PAST_JSR ; Draw land.
    .db $F4
    .db $FA
    .db $00
    JSR   SETUP_$A026_TO_$A036 ; Setup idk
    LDA   #$DB ; Change state
    STA   A0BA_PLAYER_GAME_STATE
    LDX   #$1030
    STX   SHIP_SCR_POS_XXYY ; Ship pos.
    RTS
OBJ_4_MANIP_IDK: ; 0x003460, $C460
    LDX   R_A187_OBJ_TMP_4? ; OBJ 4 slot.
    LDU   R_A194 ; U from...
    CLRA ; Clear A
LOOP_ADD_256: ; 0x003467, $C467
    STA   U ; Clear U addr.
    LEAU  256,U ; Y += 256
    CMPU  7,X ; If U _ XOBJ[7]
    BLS   LOOP_ADD_256 ; <=, goto.
    JMP   XOBJ_BACK_TO_AVAILABLE_LIST ; Give object 4 back? Blown up?
CALLBACK_ATTRACT_IDK: ; 0x003475, $C475
    BSR   OBJ_4_MANIP_IDK
    LDX   R_A18D_OBJ_TMP_3? ; Obj 3
    JSR   REMOVE_X_FROM_LIST_A065|A06B ; Remove from list...
    JSR   L_002C63 ; IDK
    LDX   R_A18B_OBJ_PTR_SHIP? ; X obj 2, ship?
    LDD   #$0040
    STD   14,X ; OBJ[14], H speed?
    LDD   #$00D4 ; V speed.
    STD   16,X ; OBJ[12], vspeed?
    LDA   #$2D ; Times to run
    STA   R_A18F_HUMANOID_LOOP_COUNTER
    LDX   R_A189_OBJ_TMP? ; Root obj
    LDD   #$0000
    STD   16,X ; Clear Vspeed
CALLBACK_HUMANOID_FALL: ; 0x00349C, $C49C
    LDX   R_A189_OBJ_TMP? ; Load root obj.
    LDD   16,X
    ADDD  #$0008 ; Add gravity for humanoid.
    STD   16,X ; Vspeed.
    DEC   R_A18F_HUMANOID_LOOP_COUNTER
    BEQ   L_0034B5
    LDA   #$02 ; Set up humanoid fall callback.
    LDX   #$C49C
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
L_0034B5: ; 0x0034B5, $C4B5
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get onscreen obj.
    LDD   #$0000
    STD   14,X ; Clear H speed.
    STD   16,X ; V speed
    LDD   #$1DFF ; World pos?
    STD   10,X
    LDD   #$9000 ; Idk
    STD   12,X
    LDD   #$F9E7 ; BMP
    STD   2,X
    STX   LIST_$65_ON_SCREEN? ; Replace.
    LDD   #$0000
    STD   18,X ; Clear idk
    STX   R_A190_OBJ_PTR_INIT_LANDER/SCORE? ; Obj tmp
    LDD   #$0000 ; H speed
    LDU   #$00C0 ; V speed
    LDX   R_A18B_OBJ_PTR_SHIP? ; Get obj
    STD   14,X ; H speed
    STU   16,X ; V speed
    LDX   R_A189_OBJ_TMP? ; Get obj.
    LDD   #$1E80
    STD   10,X ; SCR pos?
    LDD   #$A2E0 ; Idk
    STD   12,X
    STU   16,X ; V speed
    LDA   #$50 ; Schedule code below.
    LDX   #$C500
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_ATTRACT_SHIP_FLYBACK?: ; 0x003500, $C500
    LDX   R_A190_OBJ_PTR_INIT_LANDER/SCORE? ; Obj
    LDD   #$E000 ; Idk val
    STD   12,X
    LDD   #$1C00 ; Idk val
    STD   10,X
    LDX   R_A189_OBJ_TMP? ; Root obj
    LDD   #$0000 ; No speed
    STD   16,X ; V speed
    LDX   R_A18B_OBJ_PTR_SHIP?
    LDD   #$F9CB ; Replace bitmap, flying left?
    STD   2,X
    LDD   #$FFC0 ; H speed
    STD   14,X
    LDD   #$FE80 ; V speed
    STD   16,X
    LDA   #$60 ; Schedule below.
    LDX   #$C531
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_SHIP_HOME?: ; 0x003531, $C531
    LDX   R_A18B_OBJ_PTR_SHIP?
    LDD   #$F9C1 ; Back to other bitmap.
    STD   2,X ; Bitmap change.
    LDD   #$0000
    STD   14,X ; H speed
    STD   16,X ; V speed
    LDX   R_A190_OBJ_PTR_INIT_LANDER/SCORE?
    LDD   4,X ; D from OBJ[4], save.
    JSR   REMOVE_X_FROM_LIST_A065|A06B ; Remove obj entirely.
    JSR   GFX_CLEAR_12X6 ; Clear manually.
    LDU   #$CC7D ; IDK val.
LOOP_ENEMIES: ; 0x00354F, $C54F
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN?
    LDD   12,U ; D from U[12], val F985
    STD   2,X ; To bitmap.
    LDD   36,U ; D from U+36
    STD   18,X ; To OBJ[18]
    LDD   #$1F00 ; idk val
    STD   10,X
    LDD   #$A000 ; IDK val
    STD   12,X
    LDD   #$FF40
    STD   16,X ; V speed
    LDD   #$0000
    STD   14,X ; H speed
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN?
    STU   R_A192_OBJ_PTR_SCRATCH
    STX   R_A18D_OBJ_TMP_3? ; Overwrite
    LDA   #$5F ; Callback
    LDX   #$C585
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   #$C5F5 ; Schedule IDK
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    STX   R_A187_OBJ_TMP_4? ; Store new obj here.
    LDA   #$17
    LDX   #$C598
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Schedule below.
    JSR   OBJ_4_MANIP_IDK ; Idfk what it does.
    LDX   R_A18D_OBJ_TMP_3? ; Load OBJ 3
    JSR   REMOVE_X_FROM_LIST_A065|A06B ; Remove from list.
    JSR   LIST_GET_23B,X.next_FROM_$65_ONSCREEN? ; Get new obj on screen.
    JSR   L_002C63 ; Blow in/out?
    LDU   R_A192_OBJ_PTR_SCRATCH ; Load ptr
    LDD   24,U ; PTR+24
    STD   10,X ; To OBJ[10]
    LDD   U++ ; D from
    STD   12,X ; To OBJ[12]
    LDD   #$0000 ; No speed.
    STD   16,X
    STD   14,X
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN? ; Spawn?
    STU   R_A192_OBJ_PTR_SCRATCH ; Store U back.
    LDA   #$20 ; Schedule below.
    LDX   #$C5CA
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_IDK: ; 0x0035CA, $C5CA
    LDX   R_A196_ATTRACT_TEXT_CURRENT ; Load ptr
    LEAX  2,X ; +=2
    STX   R_A196_ATTRACT_TEXT_CURRENT ; Store back.
    LDA   #$20 ; Schedule below.
    LDX   #$C5DA
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_IDK: ; 0x0035DA, $C5DA
    LDU   R_A192_OBJ_PTR_SCRATCH ; Load ptr
    CMPU  #$CC89 ; U _ val
    LBNE  LOOP_ENEMIES ; !=, loop.
    LDA   #$FF ; Callback to below.
    LDX   #$C5ED
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_SCHEDULE_WILLIAMS_TITLESCREEN: ; 0x0035ED, $C5ED
    LDA   #$FF ; Callback williams title screen intro.
    LDX   #$C677
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   R_A18B_OBJ_PTR_SHIP?
    LDX   4,X
    LEAX  1796,X
    STX   7,U
    STX   9,U
    STX   R_A194
    LDA   #$04
    LDX   7,U
    LDB   #$11
L_00360B: ; 0x00360B, $C60B
    STB   X
    LEAX  256,X
    DECA
    BNE   L_00360B
    LDB   #$99
    STB   X
    STX   7,U
    LDY   $A0A4
    CMPY  #$A15F
    BLO   L_003627
    LDY   #$A142
L_003627: ; 0x003627, $C627
    LDX   9,U
    LDA   #$03
L_00362B: ; 0x00362B, $C62B
    LDB   Y+
    STB   X
    LEAX  256,X
    DECA
    BNE   L_00362B
    STY   $A0A4
    STX   9,U
    LDX   R_A194
    CLR   X
    LEAX  256,X
    STX   R_A194
    LDA   #$01
    LDX   #$C605
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_ALL_TEXT_TO_SCREEN: ; 0x00364F, $C64F
    LDY   #$CC61 ; Ptr to TEXT|POS data.
WRITE_NEW_ONLY: ; 0x003653, $C653
    LDU   14,Y ; Word ptr
    LDX   Y++ ; POS data.
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $02
    .db $02
    STY   R_A198_ATTRACT_NEXT_PTR ; New Y to.
    LDA   #$06 ; Schedule callback below.
    LDX   #$C66B
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDY   R_A198_ATTRACT_NEXT_PTR ; Load ptr pos.
    CMPY  R_A196_ATTRACT_TEXT_CURRENT ; If PTR _ OTHER_PTR
    BNE   WRITE_NEW_ONLY ; !=, write new.
    BRA   CALLBACK_ALL_TEXT_TO_SCREEN ; Write all text when new text.
FIRST_ATTRACT_INTRO_WILLIAMS?: ; 0x003677, $C677
    JSR   PUT_OBJECTS_TO_AVAILABLE_IF_OBJ[5]!=2 ; Clean up?
    CLR   R_A184 ; Clear addr
    LDA   #$FB ; State 1111.1011
    STA   A0BA_PLAYER_GAME_STATE
    JSR   CLEAR_ALL_SCREEN ; Clear screen.
    CLR   SENTENCE_PTR_WORD_ON ; Clear
    LDD   #$FFFF
    STD   TEXT_PTR_UNK ; Set to $FFFF
    LDX   #$E782 ; Schedule color rotation.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$F43D ; Schedule other color rotation.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDA   #$3F ; R = 1/7, G = 7/7, B = 3/3
    STA   COLOR_PALETTE_RAM_COPY+12 ; Set to yellow?
    JMP   SETUP_FIRST_INTRO_DATA ; Goto next line, rofl.
SETUP_FIRST_INTRO_DATA: ; 0x0036A2, $C6A2
    JSR   DEFENDER_LOGO_TO_RAM?
    LDA   #$03
    STA   DRAW_STEPS_COUNT_SEED_VAL ; Seed
    LDX   #$C941 ; Ptr to unk data.
    STX   R_A16B_DRAWING_DATA_PTR? ; Store ptr.
DRAW_LOGO_CALLBACK: ; 0x0036B0, $C6B0
    LDA   DRAW_STEPS_COUNT_SEED_VAL ; Load val
    STA   DRAW_COUNTER_ACTUAL ; Store to
    LDY   R_A16B_DRAWING_DATA_PTR? ; Y from ptr.
DRAW_LOOP: ; 0x0036BA, $C6BA
    LDA   Y+ ; A from Y
    CMPA  #$AA ; If A _ val
    BLS   NOT_CMD_MOVE_OUTPUT ; <=, goto.
    COMA ; Invert otherwise.
    BEQ   DRAW_LOOP ; Was FF, goto.
    DECA ; A--
    BNE   DRAWING_EOF ; Not FE, goto.
    LDD   Y++ ; D from Y
    STD   DRAW_PIXEL_POS_XXYY ; New pos writing.
    CLRA ; Clear A, command consumed.
    BRA   DRAW_PIXEL_NOW
NOT_CMD_MOVE_OUTPUT: ; 0x0036CE, $C6CE
    ASLA ; << 1
    BHS   DONT_DEC_66 ; Shift 0, goto.
    DEC   DRAW_PIXEL_POS_XXYY ; --
DONT_DEC_66: ; 0x0036D4, $C6D4
    ASLA
    BHS   DONT_INC_66
    INC   DRAW_PIXEL_POS_XXYY ; ++
DONT_INC_66: ; 0x0036DA, $C6DA
    ASLA
    BHS   DONT_DEC_67
    DEC   DRAW_PIXEL_POS_XXYY+1 ; --
DONT_DEC_67: ; 0x0036E0, $C6E0
    ASLA
    BHS   DRAW_PIXEL_NOW
    INC   DRAW_PIXEL_POS_XXYY+1 ; ++
DRAW_PIXEL_NOW: ; 0x0036E6, $C6E6
    STA   DRAW_CMD_TEMP? ; Store shifted A
    LDD   DRAW_PIXEL_POS_XXYY ; D from addr
    LSRA ; A >> 1, get if setting low nibble.
    TFR   D>X ; D to X
    LDB   X ; B from X
    BLO   SETTING_LOW_NIBBLE ; If shifted 1, goto.
    ORB   #$F0 ; Set high nibble.
    BRA   SKIP_SET_LOW
SETTING_LOW_NIBBLE: ; 0x0036F7, $C6F7
    ORB   #$0F ; Set low nibble.
SKIP_SET_LOW: ; 0x0036F9, $C6F9
    STB   X ; B to X
    LDA   DRAW_CMD_TEMP? ; A from
    BNE   NOT_CMD_MOVE_OUTPUT
    DEC   DRAW_COUNTER_ACTUAL ; Dec counter.
    BNE   DRAW_LOOP ; Not done.
    STY   R_A16B_DRAWING_DATA_PTR? ; Save Y
    LDA   #$02 ; Schedule callback for logo trace.
    LDX   #$C6B0
    JSR   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
DRAWING_EOF: ; 0x003711, $C711
    STX   R_A168 ; Screen draw pos?
    LDA   #$03
    CMPA  DRAW_STEPS_COUNT_SEED_VAL ; 3 _ addr
    BNE   HAS_BEEN_RESEEDED ; !=, goto.
    LDA   #$0A ; Reseed to redraw faster
    STA   DRAW_STEPS_COUNT_SEED_VAL
    LDX   #$C730 ; Schedule rtn below.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
HAS_BEEN_RESEEDED: ; 0x003728, $C728
    LDX   #$C941
    STX   R_A16B_DRAWING_DATA_PTR? ; Reset data ptr.
    BRA   DRAW_LOGO_CALLBACK ; Keep drawing logo.
    LDX   #$C74C
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDX   #$3258 ; POS
    LDU   #$C0ED ; PTR to SENTENCE ELECTRONICS INC. PRESENTS
    JSR   JMP_GOTO_PAST_JSR ; To screen
    .db $C0
    .db $02
    .db $02
    LDA   #$05 ; Schedule text to screen every 5 ticks.
    LDX   #$C738
    JSR   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Schedule.
    LDA   #$30 ; Schedule below code in 30 ticks...
    LDX   #$C754
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT ; Schedule.
    LDD   #$B3D6 ; Ptr to unk
    STD   R_A16D ; Ptr here
    LDD   #$B412 ; Another?
    STD   R_A16F ; Ptr to
    LDD   #$0000
    STD   R_A020_SCREEN_POS_CHANGE? ; Clear
    LDD   #$0C00 ; Not sure of val.
    STD   R_A171
    LDD   #$B304 ; Yet another pointer idk.
    STD   R_A173
LOOP_MAKE_THINGS: ; 0x003771, $C771
    LDX   R_A173 ; B304 start
    LDY   R_A16D ; B3D6 start
    LDD   #$040C ; D from
    STD   Y ; To
    LDD   R_A16F ; B412 start
    STD   2,Y ; To
    ADDD  #$0060 ; D += #$60
    STD   R_A16F ; Save new D
    STY   2,X ; Y to X[2]
    LDD   R_A171 ; #$0C00 start
    STD   10,X ; Something location?
    ADDD  #$0100 ; D += 100
    STD   R_A171 ; Save new D
    LDD   #$9800 ; Idk val
    STD   12,X ; To OBJ[12]
    JSR   JMP_TO_REPLACES_BMP_AND_DOES_ALOT_SPAWN_IN?
    LEAX  14,X ; X+=14
    STX   R_A173 ; Store to
    LEAY  4,Y ; Y += 4
    STY   R_A16D ; Store to
    CMPY  #$B412 ; 0x3C bytes, 60 bytes, /4 = 15 things.
    BNE   LOOP_MAKE_THINGS
    LDA   #$2E ; Schedule code below.
    LDX   #$C7B7
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   #$B300 ; Ptr to data buffer.
    LDD   #$3C18 ; WWHH to DATA[0/1]
    STD   X ; To X ptr?
    LDD   #$B412 ; Ptr to gfx?
    STD   2,X ; To X[2]
    LDX   #$C848 ; Schedule this.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDA   #$28 ; Setup callback for code below.
    LDX   #$C7D4
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
    LDX   #$F464 ; Schedule palette manip. For main Defender logo?
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDU   R_A168 ; U from
    LDY   #$CC11 ; Data ptr IDK
    LDX   #$3BD0 ; X =
LOOP_NEW_DATA_IN_REGS: ; 0x0037E6, $C7E6
    LDD   Y++ ; D from Y
    STD   R_A164_HIGHSCORE_DATA_POS ; D to addr
    LDA   #$01 ; Seed times.
LOOP_MAKE_B_1: ; 0x0037ED, $C7ED
    CLRB ; Clear B
    BITA  R_A164_HIGHSCORE_DATA_POS ; Test val at addr
    BEQ   DONT_SEED_B ; Not set dont seed
    LDB   #$10 ; B =
DONT_SEED_B: ; 0x0037F5, $C7F5
    BITA  R_A165 ; Test
    BEQ   DONT_OR_B_1
    ORB   #$01
DONT_OR_B_1: ; 0x0037FC, $C7FC
    STB   X+
    ASLA ; A << 1
    BNE   LOOP_MAKE_B_1 ; !0, goto.
    LEAX  248,X ; 8 tall, so add 8 less.
    CMPY  #$CC61 ; End
    BNE   LOOP_NEW_DATA_IN_REGS ; Not end, loop with new bytes.
    LDX   #$A026 ; Ptr to palette.
    LDB   DATA_W_0FE7 ; B from addr, index into palette, 15.
    LDA   B,X ; A from X+B
    COMA ; Invert A
    ANDA  #$07 ; Get bits.
    BNE   ANY_BITS_SET
    LDX   #$8018
    LDD   #$20A0
    STU   D,X ; U to A0B8?
ANY_BITS_SET: ; 0x003820, $C820
    LDA   #$01
    STA   R_A0B7_UNK_ATTRACT_CHECKS ; Set to 1
    LDX   #$C8F4 ; Schedule credits to screen.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE
    LDA   #$3C
    STA   INITIAL_ENTER_TIMER? ; Seed timer.
    TST   R_A184 ; Test addr
    LBNE  ATTRACT_GAME_DEMO_MAIN ; != 0, goto.
    DEC   INITIAL_ENTER_TIMER? ; Dec timer.
    BEQ   JMP_TO_GAME_START ; If 0, goto.
    LDA   #$0A ; Callback to wait.
    LDX   #$C831
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
JMP_TO_GAME_START: ; 0x003845, $C845
    JMP   SHOW_HIGH_SCORE_TABLES?
    LDY   #$B300 ; Graphic?
    LDD   #$3090 ; Pos?
    JSR   GFX_BANK2_CHR_TO_SCREEN ; To screen.
    TST   $9C00 ; Test loc
    BNE   SCHEDULE_AGAIN ; !0, goto.
    TST   $9C40 ; Test addr
    BNE   SCHEDULE_AGAIN ; !-, goto.
    LDX   #$C921 ; Schedule replace drawn williams logo.
    LDA   #$00
    JSR   GET_15B_OBJECT+SCHEDULE ; Do callback.
    JMP   CALLBACK_REMOVE? ; We're done.
SCHEDULE_AGAIN: ; 0x003867, $C867
    LDA   #$01 ; Set up callback again.
    LDX   #$C848
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
DEFENDER_LOGO_TO_RAM?: ; 0x00386F, $C86F
    LDX   #$B412 ; Ptr to RAM data?
    LDY   #$CAA0 ; Ptr to ROM data?
    CLRA
    STA   R_PAIR_LOWER
    STA   R_PAIR_UPPER
LOAD_FROM_Y+IDK: ; 0x00387D, $C87D
    LDA   Y ; A from Y ptr
    LSRA ; A >> 4
    LSRA
    LSRA
    LSRA
    BSR   SUB_DO_ON_A ; Do sub on bits.
    LDA   Y+
    ANDA  #$0F ; Now bottom bits.
    BSR   SUB_DO_ON_A ; Do sub.
    CMPY  #$CC0E ; End
    BNE   LOAD_FROM_Y+IDK ; Not end.
SUB_DO_ON_A: ; 0x003891, $C891
    BITA  #$0C ; Test 0000.1100
    BNE   BOTTOM_NIB_TOP_SET ; If set, goto.
    ADDA  R_PAIR_UPPER ; A += VAL
    ASLA ; A << 2
    ASLA
    STA   R_PAIR_UPPER ; To val.
    RTS
BOTTOM_NIB_TOP_SET: ; 0x00389E, $C89E
    PSHS  A ; Save reg.
    ANDA  #$03 ; Get bottom bits.
    ADDA  R_PAIR_UPPER ; Addr += A
    STA   R_PAIR_UPPER
    PULS  A ; Get value again
    ANDA  #$0C ; Get 0000.1100
    LSRA ; >> 2
    LSRA
    LDU   #$CC0D
    LDB   A,U ; B from U to U+3
    STB   R_IDK_VAL_USED_TO_STORE? ; To addr
    CMPX  #$B9B2
    BLO   SKIP_MINUS_ALOT ; If X <, goto.
    LEAX  -1439,X ; X -=
SKIP_MINUS_ALOT: ; 0x0038BF, $C8BF
    LDA   R_PAIR_LOWER ; Load val
    BEQ   PAIR_LOWER_IS_ZERO
    LDA   X ; A from X
    ANDA  #$F0 ; Get top bits.
    STA   X ; Store back to X
    LDA   R_IDK_VAL_USED_TO_STORE? ; Load from
    ANDA  #$0F ; Get lower bits.
    ORA   X ; Or with X
    STA   X ; Store to X
    LDA   R_IDK_VAL_USED_TO_STORE? ; Get A from
    BRA   X_PLUS_24
PAIR_LOWER_IS_ZERO: ; 0x0038D8, $C8D8
    COM   R_PAIR_LOWER ; 0 to FF
    LDA   R_IDK_VAL_USED_TO_STORE? ; A from
STORE_A_TO_X: ; 0x0038DE, $C8DE
    STA   X ; To X
    DEC   R_PAIR_UPPER ; Dec val
    BMI   CLEAR_UPPER+RTS ; If minus, goto.
X_PLUS_24: ; 0x0038E5, $C8E5
    LEAX  24,X ; X += 24
    DEC   R_PAIR_UPPER ; Dec again
    BPL   STORE_A_TO_X ; If positive, goto.
    CLR   R_PAIR_LOWER ; Clear upper
CLEAR_UPPER+RTS: ; 0x0038F0, $C8F0
    CLR   R_PAIR_UPPER ; Clear lower.
    RTS
SHOW_CREDITS_CALLBACK: ; 0x0038F4, $C8F4
    LDB   VAL_FROM_SRAM_C495-C496 ; B from SRAM
    BEQ   SCHEDULE_SHOW_CREDITS ; If 0, just schedule. Credits for game? Free play?
    CMPB  R_A183_VAL_FROM_SRAM ; CMPB to RAM val
    BLS   PUT_CREDITS_ON_SCREEN ; Load <=, don't store back.
    STB   R_A183_VAL_FROM_SRAM ; Store loaded
    INC   R_A184 ; Inc idk
PUT_CREDITS_ON_SCREEN: ; 0x003903, $C903
    LDU   #$C0E9 ; CREDITS:
    LDX   #$28E5 ; POS
    JSR   JMP_GOTO_PAST_JSR ; To screen.
    .db $C0
    .db $02
    .db $02
    CLRA ; A = 0
    LDX   #$48E5 ; Pos
    JSR   JMP_GOTO_PAST_JSR ; Put AB #'s to screen.
    .db $C0
    .db $0E
    .db $02
SCHEDULE_SHOW_CREDITS: ; 0x003919, $C919
    LDA   #$10 ; Shedule show credits.
    LDX   #$C8F4
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_REDRAW_WILLIAMS_ALOT: ; 0x003921, $C921
    LDA   #$FF
    STA   DRAW_STEPS_COUNT_SEED_VAL ; Lots of draw steps for logo.
    LDA   #$02
    LDX   #$C92E
    JMP   SCHEDULE_BANKED_CALLBACK_IN_CURRENT
CALLBACK_REDRAW_WILLIAMS_MEDIUM: ; 0x00392E, $C92E
    LDA   #$0A
    STA   DRAW_STEPS_COUNT_SEED_VAL ; Seed to lower value now since rewritten.
    JMP   CALLBACK_REMOVE? ; We're done here.
DISPLAY_PREVIOUS_GAMES_SCORES: ; 0x003936, $C936
    LDA   A08C_CURRENT_PLAYER_COUNT
LOOP_SHOW_SCORES: ; 0x003938, $C938
    BEQ   RTS ; Don't show none.
    JSR   PLAYER_PASSED_SCORE_TO_SCREEN
    DECA
    BRA   LOOP_SHOW_SCORES
RTS: ; 0x003940, $C940
    RTS
WILLIAMS_LOGO_DRAWN_DATA?: ; 0x003941, $C941
    .db $FE ; FMT: [1B]
    .db $74 ; FF = Nothing, FE = Load pos for pixel, other values >AA mean EOF.
    .db $40 ; Otherwise nibble bits mean U/D/L/R
    .db $11
    .db $11
    .db $85
    .db $81
    .db $81
    .db $81
    .db $88
    .db $82
    .db $82
    .db $22
    .db $24
    .db $22
    .db $42
    .db $24
    .db $24
    .db $24
    .db $44
    .db $24
    .db $44
    .db $49
    .db $44
    .db $94
    .db $41
    .db $88
    .db $14
    .db $41
    .db $88
    .db $14
    .db $41
    .db $88
    .db $94
    .db $41
    .db $88
    .db $94
    .db $49
    .db $88
    .db $14
    .db $98
    .db $58
    .db $94
    .db $98
    .db $18
    .db $94
    .db $46
    .db $66
    .db $62
    .db $42
    .db $42
    .db $42
    .db $42
    .db $25
    .db $24
    .db $24
    .db $68
    .db $24
    .db $24
    .db $24
    .db $26
    .db $11
    .db $18
    .db $18
    .db $58
    .db $18
    .db $58
    .db $81
    .db $44
    .db $98
    .db $81
    .db $44
    .db $98
    .db $81
    .db $44
    .db $98
    .db $14
    .db $94
    .db $94
    .db $16
    .db $22
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $FE
    .db $81
    .db $4A
    .db $42
    .db $42
    .db $42
    .db $42
    .db $44
    .db $99
    .db $99
    .db $41
    .db $88
    .db $14
    .db $41
    .db $88
    .db $14
    .db $46
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $A4
    .db $22
    .db $42
    .db $4A
    .db $42
    .db $42
    .db $44
    .db $99
    .db $19
    .db $91
    .db $19
    .db $91
    .db $91
    .db $81
    .db $81
    .db $41
    .db $81
    .db $49
    .db $46
    .db $42
    .db $42
    .db $42
    .db $42
    .db $42
    .db $42
    .db $24
    .db $22
    .db $42
    .db $62
    .db $62
    .db $42
    .db $24
    .db $49
    .db $19
    .db $91
    .db $91
    .db $91
    .db $91
    .db $91
    .db $85
    .db $88
    .db $14
    .db $94
    .db $14
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $41
    .db $81
    .db $81
    .db $18
    .db $18
    .db $94
    .db $41
    .db $88
    .db $14
    .db $14
    .db $24
    .db $42
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $44
    .db $98
    .db $18
    .db $18
    .db $18
    .db $58
    .db $89
    .db $44
    .db $18
    .db $85
    .db $14
    .db $24
    .db $14
    .db $24
    .db $A4
    .db $24
    .db $24
    .db $24
    .db $A4
    .db $24
    .db $28
    .db $24
    .db $44
    .db $18
    .db $19
    .db $19
    .db $81
    .db $41
    .db $81
    .db $14
    .db $24
    .db $24
    .db $24
    .db $24
    .db $22
    .db $42
    .db $42
    .db $64
    .db $41
    .db $85
    .db $81
    .db $81
    .db $18
    .db $19
    .db $41
    .db $89
    .db $44
    .db $42
    .db $22
    .db $42
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $44
    .db $18
    .db $14
    .db $98
    .db $11
    .db $81
    .db $81
    .db $41
    .db $89
    .db $44
    .db $42
    .db $22
    .db $42
    .db $24
    .db $24
    .db $24
    .db $24
    .db $24
    .db $44
    .db $18
    .db $94
    .db $41
    .db $88
    .db $89
    .db $44
    .db $49
    .db $88
    .db $14
    .db $41
    .db $88
    .db $14
    .db $14
    .db $24
    .db $24
    .db $24
    .db $26
    .db $62
    .db $66
    .db $26
    .db $24
    .db $18
    .db $91
    .db $91
    .db $19
    .db $18
    .db $14
    .db $18
    .db $14
    .db $14
    .db $24
    .db $14
    .db $2A
    .db $45
    .db $24
    .db $68
    .db $88
    .db $24
    .db $44
    .db $42
    .db $18
    .db $A8
    .db $82
    .db $44
    .db $A8
    .db $22
    .db $20
    .db $FE
    .db $87
    .db $40
    .db $44
    .db $11
    .db $88
    .db $24
    .db $FE
    .db $9A
    .db $3F
    .db $44
    .db $11
    .db $88
    .db $24
    .db $FE
    .db $C1
    .db $3F
    .db $44
    .db $44
    .db $44
    .db $11
    .db $11
    .db $11
    .db $11
    .db $88
    .db $88
    .db $88
    .db $22
    .db $22
    .db $22
    .db $20
    .db $FE
    .db $C3
    .db $45
    .db $22
    .db $22
    .db $44
    .db $11
    .db $81
    .db $50
    .db $FD
DEFENDER_LOGO_DATA?: ; 0x003AA0, $CAA0
    .db $10
    .db $D1
    .db $BD
    .db $29
    .db $C2
    .db $9C
    .db $29
    .db $CB
    .db $EA
    .db $C2
    .db $8C
    .db $29
    .db $C2
    .db $81
    .db $0D
    .db $10
    .db $C2
    .db $8D
    .db $29
    .db $C2
    .db $9C
    .db $29
    .db $CB
    .db $EA
    .db $42
    .db $94
    .db $29
    .db $42
    .db $81
    .db $0C
    .db $3F
    .db $29
    .db $C2
    .db $94
    .db $C2
    .db $9C
    .db $29
    .db $C1
    .db $8D
    .db $A4
    .db $29
    .db $42
    .db $94
    .db $29
    .db $3F
    .db $3E
    .db $29
    .db $42
    .db $A4
    .db $29
    .db $4C
    .db $29
    .db $C1
    .db $8D
    .db $A4
    .db $2A
    .db $42
    .db $94
    .db $29
    .db $3E
    .db $3D
    .db $B6
    .db $B4
    .db $A2
    .db $4A
    .db $17
    .db $CA
    .db $16
    .db $C1
    .db $9C
    .db $B4
    .db $A7
    .db $A4
    .db $B1
    .db $7A
    .db $7A
    .db $3D
    .db $3C
    .db $B6
    .db $B4
    .db $B1
    .db $71
    .db $81
    .db $6B
    .db $16
    .db $C1
    .db $AC
    .db $A4
    .db $B6
    .db $B4
    .db $A2
    .db $4A
    .db $6B
    .db $3C
    .db $2F
    .db $B6
    .db $B4
    .db $29
    .db $62
    .db $85
    .db $C2
    .db $85
    .db $C1
    .db $AC
    .db $A4
    .db $B6
    .db $B4
    .db $28
    .db $62
    .db $A2
    .db $F2
    .db $EB
    .db $61
    .db $84
    .db $29
    .db $62
    .db $8E
    .db $28
    .db $E2
    .db $A4
    .db $B7
    .db $B4
    .db $28
    .db $62
    .db $A2
    .db $E2
    .db $DB
    .db $7B
    .db $42
    .db $96
    .db $28
    .db $4E
    .db $28
    .db $E2
    .db $B4
    .db $B6
    .db $B4
    .db $29
    .db $62
    .db $92
    .db $E2
    .db $CB
    .db $7B
    .db $52
    .db $96
    .db $28
    .db $4E
    .db $28
    .db $EB
    .db $41
    .db $A4
    .db $B7
    .db $B4
    .db $28
    .db $62
    .db $92
    .db $E1
    .db $FB
    .db $7B
    .db $5B
    .db $24
    .db $B1
    .db $6D
    .db $18
    .db $14
    .db $EB
    .db $51
    .db $94
    .db $B7
    .db $B4
    .db $18
    .db $17
    .db $29
    .db $2D
    .db $1E
    .db $B1
    .db $4B
    .db $4B
    .db $25
    .db $B1
    .db $6D
    .db $B1
    .db $5E
    .db $B5
    .db $1A
    .db $4B
    .db $61
    .db $84
    .db $B2
    .db $4B
    .db $41
    .db $82
    .db $C1
    .db $DB
    .db $14
    .db $B5
    .db $18
    .db $17
    .db $18
    .db $16
    .db $D1
    .db $81
    .db $4E
    .db $B6
    .db $19
    .db $4B
    .db $61
    .db $84
    .db $18
    .db $24
    .db $B4
    .db $18
    .db $1F
    .db $1C
    .db $38
    .db $53
    .db $84
    .db $B1
    .db $6E
    .db $2B
    .db $CB
    .db $61
    .db $94
    .db $38
    .db $42
    .db $B4
    .db $18
    .db $41
    .db $81
    .db $EF
    .db $39
    .db $43
    .db $85
    .db $B1
    .db $6E
    .db $2B
    .db $CB
    .db $71
    .db $84
    .db $38
    .db $43
    .db $84
    .db $B6
    .db $18
    .db $1C
    .db $E3
    .db $95
    .db $38
    .db $41
    .db $81
    .db $6D
    .db $38
    .db $CB
    .db $C6
    .db $19
    .db $42
    .db $B5
    .db $38
    .db $4B
    .db $61
    .db $8F
    .db $D3
    .db $95
    .db $38
    .db $5B
    .db $51
    .db $F3
    .db $8C
    .db $BD
    .db $61
    .db $84
    .db $2A
    .db $63
    .db $85
    .db $B6
    .db $18
    .db $ED
    .db $38
    .db $53
    .db $94
    .db $18
    .db $51
    .db $F3
    .db $8C
    .db $BD
    .db $7B
    .db $42
    .db $91
    .db $42
    .db $B5
    .db $18
    .db $7B
    .db $DC
    .db $21
    .db $51
    .db $F3
    .db $4C
    .db $7E
    .db $30
    .db $6C
    .db $C2
    .db $14
    .db $2C
    .db $34
    .db $C7
    .db $E1
    .db $07
    .db $C1
    .db $35
    .db $CC
    .db $21
    .db $42
    .db $C3
    .db $4C
    .db $7F
    .db $10
    .db $6C
    .db $13
    .db $5C
    .db $C1
    .db $35
    .db $C1
    .db $52
    .db $C3
    .db $4C
    .db $7F
    .db $15
    .db $C2
    .db $7D
    .db $34
    .db $C1
    .db $5C
    .db $17
    .db $CC
    .db $36
    .db $C3
    .db $5C
    .db $14
    .db $2D
    .db $34
    .db $C7
    .db $1C
    .db $14
    .db $C2
    .db $6E
    .db $34
    .db $D1
    .db $4E
    .db $15
    .db $CC
    .db $36
    .db $C3
    .db $5C
    .db $14
    .db $2D
    .db $34
    .db $C7
    .db $1C
    .db $14
    .db $C2
    .db $51
    .db $C2
    .db $7D
    .db $14
    .db $F1
DATA_PTR_3: ; 0x003C0D, $CC0D
    .db $4C
    .db $22
    .db $CC
    .db $00 ; Data end.
DATA_IDK: ; 0x003C11, $CC11
    .db $3E
    .db $41
    .db $41
    .db $22
    .db $00
    .db $3E
    .db $41
    .db $41
    .db $3E
    .db $00
    .db $7F
    .db $09
    .db $09
    .db $06
    .db $00
    .db $03
    .db $04
    .db $78
    .db $04
    .db $03
    .db $00
    .db $7F
    .db $09
    .db $19
    .db $66
    .db $00
    .db $41
    .db $7F
    .db $41
    .db $00
    .db $3E
    .db $41
    .db $49
    .db $3A
    .db $00
    .db $7F
    .db $08
    .db $08
    .db $7F
    .db $00
    .db $01
    .db $01
    .db $7F
    .db $01
    .db $01
    .db $00
    .db $1C
    .db $22
    .db $5D
    .db $63
    .db $55
    .db $22
    .db $1C
    .db $22
    .db $7F
    .db $4B
    .db $45
    .db $22
    .db $1C
    .db $00
    .db $00
    .db $00
    .db $42
    .db $7F
    .db $40
    .db $00
    .db $26
    .db $49
    .db $49
    .db $3E
    .db $00
    .db $36
    .db $49
    .db $49
    .db $36
    .db $00
    .db $3E
    .db $41
    .db $41
    .db $3E
DATA_TABLE_TEXT_POS: ; 0x003C61, $CC61
    .db $43 ; fmt: [XX,YY]
    .db $30
DATA_TABLE_IDK: ; 0x003C63, $CC63
    .db $1C
    .db $70
    .db $3C
    .db $70
    .db $5F
    .db $70
    .db $1C
    .db $A8
    .db $40
    .db $A8
    .db $5C
    .db $A8 ; END OF DATA
DATA_TABLE_TEXT_PTRS: ; 0x003C6F, $CC6F
    .db $C0 ; fmt: [ptr]
    .db $EB ; SENTENCE SCANNER
    .db $C0 ; SENTENCE LANDER 100
    .db $DD
    .db $C0 ; SENTENCE MUTANT 150
    .db $DF
    .db $C0 ; SENTENCE BAITER 200
    .db $E7
    .db $C0 ; SENTENCE BOMBER 250
    .db $E3
    .db $C0 ; SENTENCE  POD 1000
    .db $E1
    .db $C0 ; SENTENCE SWARMER 150
    .db $E5 ; END OF DATA
    .db $60
    .db $00
    .db $60
    .db $00
    .db $62
    .db $00
    .db $98
    .db $00
    .db $98
    .db $00
    .db $9A
    .db $00
    .db $F9
    .db $85
    .db $F8
    .db $CE
    .db $F9
    .db $A3
    .db $F9
    .db $29
    .db $F8
    .db $F7
    .db $F9
    .db $7B
    .db $09
    .db $00
    .db $11
    .db $00
    .db $19
    .db $80
    .db $09
    .db $60
    .db $11
    .db $60
    .db $19
    .db $E0
    .db $44
    .db $33
    .db $CC
    .db $33
    .db $33
    .db $33
    .db $88
    .db $88
    .db $CC
    .db $CC
    .db $24
    .db $24
L_003CAD: ; 0x003CAD, $CCAD
    LDU   #$0000
    LDB   #$08
    LDX   #$B05D
L_003CB5: ; 0x003CB5, $CCB5
    STU   [X]
    STU   [2,X]
    STU   [4,X]
    STU   [6,X]
    ABX
    CMPX  R_A097
    BLO   L_003CB5
    LDX   [R_A097]
    BEQ   L_003CD3
    STU   X
    CLR   2,X
    STU   -256,X
L_003CD3: ; 0x003CD3, $CCD3
    LDD   R_A020_SCREEN_POS_CHANGE?
    SUBD  #$6D40
    STD   A073_SCRATCH_LOOP_WORD?
    LSRA
    LSRA
    LDU   #$CD69
    LDB   #$03
    MUL
    LEAU  D,U
    LDA   A0BA_PLAYER_GAME_STATE
    BITA  #$02
    BNE   L_003D0C
    LDA   #$30
    LDY   #$B125
L_003CF0: ; 0x003CF0, $CCF0
    LDX   #$0000
    STX   [Y]
    PULU  B,X
    STD   Y
    STX   [Y++]
    INCA
    LDX   #$0000
    STX   [Y]
    PULU  B,X
    STD   Y
    STX   [Y++]
    INCA
    CMPA  #$70
    BNE   L_003CF0
L_003D0C: ; 0x003D0C, $CD0C
    LDX   #$4C09
    LDD   #$9090
    STD   X
    STD   29,X
    LDX   #$5309
    LDD   #$0909
    STD   X
    STD   29,X
    LDX   #$A065
    LDU   #$B05D
    BSR   L_003D64
    LDX   #$A06B
    BSR   L_003D64
    STU   R_A097
    LDD   SHIP_SCR_POS_XXYY
    LSRA
    LSRA
    LSRA
    LSRA
    LSRB
    LSRB
    LSRB
    ADDD  #$4B07
    STD   U
    LDX   U
    LDD   #$9099
    STD   X
    STA   2,X
    LDA   #$09
    STA   -255,X
    RTS
L_003D4F: ; 0x003D4F, $CD4F
    LDD   10,X
    SUBD  A073_SCRATCH_LOOP_WORD?
    LSRA
    LSRA
    LDB   12,X
    LSRB
    LSRB
    LSRB
    ADDD  #$3007
    STD   U
    LDD   18,X
    STD   [U++]
L_003D64: ; 0x003D64, $CD64
    LDX   X
    BNE   L_003D4F
    RTS
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $80
    .db $00
    .db $00
    .db $30
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $96
    .db $00
    .db $00
    .db $00
    .db $00
    .db $FE
    .db $C3
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D6
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $39
    .db $00
    .db $06
    .db $66
    .db $66
    .db $88
    .db $68
    .db $66
    .db $66
    .db $66
    .db $88
    .db $88
    .db $88
    .db $00
    .db $60
    .db $63
    .db $30
    .db $63
    .db $00
    .db $06
    .db $26
    .db $68
    .db $28
    .db $60
    .db $66
    .db $66
    .db $86
    .db $00
    .db $00
    .db $66
    .db $66
    .db $00
    .db $00
    .db $ED
    .db $66
    .db $00
    .db $00
    .db $00
    .db $63
    .db $90
    .db $09
    .db $90
    .db $99
    .db $99
    .db $99
    .db $90
    .db $CC
    .db $90
    .db $11
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $10
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $10
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $11
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $FF
    .db $F0
    .db $FF
    .db $00
    .db $FF
    .db $00
    .db $F0
    .db $00
    .db $F0
    .db $F0
    .db $F0
    .db $00
    .db $EE
    .db $E0
    .db $E0
    .db $E0
    .db $EE
    .db $00
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $00
    .db $DD
    .db $D0
    .db $D0
    .db $D0
    .db $DD
    .db $00
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $00
    .db $0F
    .db $0F
    .db $0F
    .db $00
    .db $0F
    .db $00
    .db $FF
    .db $00
    .db $FF
    .db $0F
    .db $FF
    .db $00
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $00
    .db $EE
    .db $0E
    .db $0E
    .db $0E
    .db $EE
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $DD
    .db $0D
    .db $0D
    .db $0D
    .db $DD
    .db $00
    .db $1C
    .db $0D
    .db $7F
    .db $E7
    .db $70
    .db $00
    .db $0F
    .db $71
    .db $71
    .db $07
    .db $DC
    .db $77
    .db $7C
    .db $0D
    .db $71
    .db $C7
    .db $77
    .db $DE
    .db $07
    .db $71
    .db $17
    .db $17
    .db $DE
    .db $F7
    .db $71
    .db $17
    .db $71
    .db $7C
    .db $DE
    .db $F0
    .db $07
    .db $77
    .db $C7
    .db $71
    .db $17
    .db $70
    .db $70
    .db $7C
    .db $D7
    .db $77
    .db $77
    .db $70
    .db $01
    .db $CD
    .db $FF
    .db $D7
    .db $70
    .db $F0
    .db $00
    .db $00
    .db $00

;Bank 2
	.org $C000

    .db $C5 ; Used in 0x400 area.
    .db $FB
JMP_SENTENCE_TO_SCREEN: ; 0x004002, $C002
    JMP   TEXT_RTN_PTRS=$FFB3/$CAED ; The left value is IDK, right is a callback?
JMP_SENTENCE_CLEARED_FROM_SCREEN: ; 0x004005, $C005
    JMP   TEXT_RTN_PTRS=$FFB6/$CAED ; Callback sentences.
JMP_UNK_TO_SCREEN: ; 0x004008, $C008
    JMP   TEST_RTN_PTRS=$FFB3/$CB5F
JMP_UNK_CLEARED_FROM_SCREEN: ; 0x00400B, $C00B
    JMP   TEXT_RTN_PTRS=$FFB6/$CB5F
JMP_TO_VAL_IN_AB_TO_SCREEN: ; 0x00400E, $C00E
    JMP   TEXT_RTN_PTRS=$FFB3/$CC0F ; To screen, callback char to screen.
JMP_TO_VAL_IN_AB_CLEARED_FROM_SCREEN: ; 0x004011, $C011
    JMP   TEXT_RTN_PTRS=$FFB6/$CC0F ; Cleared from screen.
JMP_UNK_TO_SCREEN: ; 0x004014, $C014
    JMP   TEXT_RTN_PTRS=$FFB3/$CC39
JMP_UNK_CLEARED_FROM_SCREEN: ; 0x004017, $C017
    JMP   TEXT_RTN_PTRS=$FFB6/$CC39
JMP_SPECIAL_TO_SCREEN: ; 0x00401A, $C01A
    JMP   TEXT_RTN_SPECIAL_PTR=$FFB6
JMP_SPECIAL_CLEARED_FROM_SCREEN: ; 0x00401D, $C01D
    JMP   TEXT_RTN_SPECIAL_PTR=$FFB3
JMP_UNKNOWN_TEXT/GFX_RTN: ; 0x004020, $C020
    JMP   TEXT_SENTENCE_RTN_PTR=$C0D9
JMP_UNKNOWN_TEXT/GFX_RTN_2: ; 0x004023, $C023
    JMP   TEXT_SENTENCE_RTN_PTR=$C0BB
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $5B
    .db $FF
    .db $C0
    .db $BD
    .db $C0
    .db $BF
    .db $C0
    .db $C1
    .db $00
    .db $00
    .db $C0
    .db $C1
    .db $00
    .db $00
    .db $C0
    .db $C3
    .db $00
    .db $00
    .db $C0
    .db $C5
    .db $00
    .db $00
    .db $C0
    .db $C5
    .db $00
    .db $00
    .db $C0
    .db $C7
    .db $00
    .db $00
    .db $C0
    .db $C3
    .db $00
    .db $00
    .db $C0
    .db $C9
    .db $00
    .db $00
    .db $C0
    .db $CB
    .db $C0
    .db $CD
    .db $C0
    .db $CF
    .db $00
    .db $00
    .db $C0
    .db $BD
    .db $C0
    .db $D1
    .db $C0
    .db $D3
    .db $C0
    .db $D5
    .db $C0
    .db $DB
    .db $00
    .db $00
GLB_SENTENCES_START: ; 0x004069, $C069
    .db $C1 ; SENTENCE INITIAL TESTS INDICATE
    .db $07
    .db $C1 ; SENTENCE UNIT OK
    .db $0D
    .db $C1 ; SENTENCE ROM
    .db $11
    .db $C1 ; SENTENCE RAM
    .db $13
    .db $C1 ; SENTENCE ROM FAILURE
    .db $15
    .db $C1 ; SENTENCE RAM FAILURE
    .db $19
    .db $C1 ; SENTENCE GAME OVER
    .db $1D
    .db $C1 ; SENTENCE ALL ROMS OK
    .db $21
    .db $C1 ; SENTENCE RAM TEST
    .db $27
    .db $C1 ; SENTENCE NO RAM ERRORS DETECTED
    .db $2B
    .db $C1 ; SENTENCE CMOS RAM FAILURE
    .db $33
    .db $C1 ; SENTENCE CMOS RAM OK
    .db $4D
    .db $C1 ; SENTENCE MULTIPLE RAM FAILURE
    .db $53
    .db $C1 ; SENTENCE COLOR RAM TEST
    .db $6D
    .db $C1 ; SENTENCE AUDIO TEST
    .db $88
    .db $C1 ; SENTENCE SWITCH TEST
    .db $92
    .db $C1 ; SENTENCE MONITOR TEST
    .db $96
    .db $C1 ; SENTENCE AUTO UP
    .db $9C
    .db $C1 ; SENTENCE ADVANCE
    .db $A0
    .db $C1 ; SENTENCE RIGHT COIN
    .db $A2
    .db $C1 ; SENTENCE HIGHSCORE RESET
    .db $A6
    .db $C1 ; SENTENCE LEFT COIN
    .db $A8
    .db $C1 ; SENTENCE CENTER COIN
    .db $AC
    .db $C1 ; SENTENCE INVALID SWITCH
    .db $B0
    .db $C1 ; SENTENCE INVALID SWITCH
    .db $B2
    .db $C1 ; SENTENCE FIRE
    .db $B4
    .db $C1 ; SENTENCE THRUST
    .db $B6
    .db $C1 ; SENTENCE SMART BOMB
    .db $B8
    .db $C1 ; SENTENCE HYPERSPACE
    .db $BC
    .db $C1 ; SENTENCE TWO PLAYERS
    .db $BE
    .db $C1 ; SENTENCE ONE PLAYER
    .db $C2
    .db $C1 ; SENTENCE REVERSE
    .db $C6
    .db $C1 ; SENTENCE DOWN
    .db $C8
    .db $C1 ; SENTENCE UP
    .db $CA
    .db $C1 ; SENTENCE INVALID SWITCH (ALL BLANK BELOW TOO)
    .db $CC
    .db $C1
    .db $CE
    .db $C1
    .db $D0
    .db $C1
    .db $D2
    .db $C1
    .db $D4
    .db $C1
    .db $D6
    .db $C1
    .db $D8
    .db $C1 ; SENTENCE PRESS ADVANCE WITH SWITCH SET FOR [CMD]:
    .db $DA
    .db $C1 ; SENTENCE AUTO FOR AUDIT, GAME ADJUSTMENT
    .db $EA
    .db $C1 ; SENTENCE MANUAL FOR ROM TEST
    .db $F8
    .db $C2 ; SENTENCE AUTO FOR RAM TEST
    .db $00
    .db $C2 ; SENTENCE AUTO TO EXIT TEST
    .db $08
    .db $C2 ; SENTENCE AUTO FOR CMOS RAM TEST
    .db $10
    .db $C2 ; SENTENCE AUTO FOR COLOR RAM TEST
    .db $1A
    .db $C2 ; SENTENCE AUTO FOR AUDIO TEST
    .db $24
    .db $C2 ; SENTENCE AUTO FOR SWITCH TEST
    .db $2C
    .db $C2 ; SENTENCE MANUAL TO TEST INDIVIDUAL SOUNDS
    .db $34
    .db $C2 ; SENTENCE AUTO FOR MONITOR TEST PATTERNS
    .db $3E
    .db $C2 ; SENTENCE MANUAL TO STEP THRU PATTERNS
    .db $48
    .db $C2 ; SENTENCE AUTO FOR GAME OVER
    .db $52
    .db $C2 ; SENTENCE MANUAL TO STEP THRU ADJUSTMENT
    .db $5A
    .db $C2 ; SENTENCE WILLIAMS DEFENDER
    .db $64
    .db $C2 ; SENTENCE PRESS ADVANCE TO STEP THRU TEST
    .db $68
    .db $C2 ; SENTENCE PRESS HIGHSCORE RESET TO MAKE CHANGE
    .db $74
    .db $C2 ; SENTENCE LANDER 100
    .db $7E
    .db $C2 ; SENTENCE MUTANT 150
    .db $85
    .db $C2 ; SENTENCE " POD" 1000
    .db $8C
    .db $C2 ; SENTENCE BOMBER 250
    .db $93
    .db $C2 ; SENTENCE SWARMER 150
    .db $9A
    .db $C2 ; SENTENCE BAITER 200
    .db $A1
    .db $C2 ; SENTENCE CREDITS:
    .db $A8
    .db $C2 ; SENTENCE SCANNER
    .db $AA
    .db $C2 ; SENTENCE ELECTRONICS INC. PRESENTS
    .db $AC
    .db $C2 ; SENTENCE PLAYER ONE
    .db $B4
    .db $C2 ; SENTENCE PLAYER TWO
    .db $B8
    .db $C2 ; SENTENCE BONUS X
    .db $BC
    .db $C2 ; SENTENCE PRESS ONE PLAYER START
    .db $BE
    .db $C2 ; SENTENCE PRESS ONE OR TWO PLAYER START
    .db $C6
    .db $C2 ; SENTENCE ATTACK WAVE
    .db $D2
    .db $C2 ; SENTENCE COMPLETED
    .db $D6
    .db $C2 ; SENTENCE YOU HAVE QUALIFIED FOR...
    .db $D8
    .db $C3 ; SENTENCE PTR TO A000, A002, A004
    .db $01
    .db $C3 ; SENTENCE HALL OF FAME
    .db $0B
    .db $C3 ; SENTENCE PTR TO A006, A008, A00C
    .db $21 ; WORD POINTERS AFTER THIS.
    .db $C3 ; ADJUSTMENT
    .db $2B
    .db $C4 ; INITIAL
    .db $64
    .db $C5 ; TESTS
    .db $8D
    .db $C4 ; INDICATE
    .db $50
    .db $C5 ; UNIT
    .db $BB
    .db $C4 ; OK
    .db $D1
    .db $C5 ; ROM
    .db $2D
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; ROM
    .db $2D
    .db $C4 ; FAILURE
    .db $04
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $C4 ; GAME
    .db $15
    .db $C4 ; OVER
    .db $E0
    .db $C3 ; ALL
    .db $3E
    .db $C5 ; ROMS
    .db $31
    .db $C4 ; OK
    .db $D1
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C4 ; NO
    .db $CA
    .db $C5 ; RAM
    .db $1B
    .db $C3 ; ERRORS
    .db $F8
    .db $C3 ; DETECTED
    .db $C6
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $06
    .db $28
    .db $A0
    .db $C5 ; TEST
    .db $81
    .db $C4 ; MUST
    .db $AD
    .db $C3 ; BE
    .db $66
    .db $C3 ; ENTERED
    .db $F0
    .db $07
    .db $C5 ; WITH
    .db $DA
    .db $C3 ; COIN
    .db $98
    .db $C3 ; DOOR
    .db $CF
    .db $C4 ; OPEN
    .db $D8
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; OK
    .db $D1
    .db $C4 ; MULTIPLE
    .db $A4
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $03
    .db $FE
    .db $C3 ; ,
    .db $81
    .db $04
    .db $10
    .db $02
    .db $F8
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C3 ; CAN
    .db $7D
    .db $C4 ; NOT
    .db $CD
    .db $C3 ; BE
    .db $66
    .db $C5 ; TESTED
    .db $86
    .db $C3 ; COLOR
    .db $9D
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $04
    .db $30
    .db $02
    .db $E8
    .db $C5 ; VERTICAL
    .db $C3
    .db $C3 ; COLOR
    .db $9D
    .db $C3 ; BARS
    .db $61
    .db $C4 ; INDICATE
    .db $50
    .db $07
    .db $03
    .db $FC
    .db $C3 ; COLOR
    .db $9D
    .db $C5 ; RAM
    .db $1B
    .db $C4 ; FAILURE
    .db $04
    .db $C3 ; AUDIO
    .db $49
    .db $C5 ; TEST
    .db $81
    .db $07
    .db $07
    .db $03
    .db $04
    .db $C5 ; SOUND
    .db $54
    .db $C5 ; SWITCH
    .db $7A
    .db $C5 ; TEST
    .db $81
    .db $C4 ; MONITOR
    .db $9C
    .db $C5 ; TEST
    .db $81
    .db $C4 ; PATTERNS
    .db $E5
    .db $C3 ; AUTO
    .db $55
    .db $C5 ; UP
    .db $C0
    .db $C3 ; ADVANCE
    .db $36
    .db $C5 ; RIGHT
    .db $27
    .db $C3 ; COIN
    .db $98
    .db $C4 ; HIGHSCORE RESET
    .db $35
    .db $C4 ; LEFT
    .db $8B
    .db $C3 ; COIN
    .db $98
    .db $C3 ; CENTER
    .db $85
    .db $C3 ; COIN
    .db $98
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; FIRE
    .db $0C
    .db $C5 ; THRUST
    .db $9C
    .db $C5 ; SMART
    .db $4E
    .db $C3 ; BOMB
    .db $69
    .db $C4 ; HYPERSPACE
    .db $45
    .db $C5 ; TWO
    .db $B7
    .db $C4 ; PLAYERS
    .db $F5
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; REVERSE
    .db $1F
    .db $C3 ; DOWN
    .db $D4
    .db $C5 ; UP
    .db $C0
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C4 ; INVALID SWITCH
    .db $75
    .db $C5 ; PRESS
    .db $0B
    .db $C3 ; ADVANCE
    .db $36
    .db $C5 ; WITH
    .db $DA
    .db $C5 ; SWITCH
    .db $7A
    .db $C5 ; SET
    .db $45
    .db $C4 ; FOR
    .db $11
    .db $03
    .db $FE
    .db $C3 ; :
    .db $83
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; AUDIT
    .db $4F
    .db $03
    .db $FE
    .db $C3 ; ,
    .db $81
    .db $C4 ; GAME
    .db $15
    .db $C3 ; ADJUSTMENT
    .db $2B
    .db $C4 ; MANUAL
    .db $95
    .db $C4 ; FOR
    .db $11
    .db $C5 ; ROM
    .db $2D
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C5 ; TO
    .db $AD
    .db $C3 ; EXIT
    .db $FF
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; CMOS
    .db $93
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; COLOR
    .db $9D
    .db $C5 ; RAM
    .db $1B
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C3 ; AUDIO
    .db $49
    .db $C5 ; TEST
    .db $81
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C5 ; SWITCH
    .db $7A
    .db $C5 ; TEST
    .db $81
    .db $C4 ; MANUAL
    .db $95
    .db $C5 ; TO
    .db $AD
    .db $C5 ; TEST
    .db $81
    .db $C4 ; INDIVIDUAL
    .db $59
    .db $C5 ; SOUNDS
    .db $5A
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C4 ; MONITOR
    .db $9C
    .db $C5 ; TEST
    .db $81
    .db $C4 ; PATTERNS
    .db $E5
    .db $C4 ; MANUAL
    .db $95
    .db $C5 ; TO
    .db $AD
    .db $C5 ; STEP
    .db $67
    .db $C5 ; THRU
    .db $97
    .db $C4 ; PATTERNS
    .db $E5
    .db $C3 ; AUTO
    .db $55
    .db $C4 ; FOR
    .db $11
    .db $C4 ; GAME
    .db $15
    .db $C4 ; OVER
    .db $E0
    .db $C4 ; MANUAL
    .db $95
    .db $C5 ; TO
    .db $AD
    .db $C5 ; STEP
    .db $67
    .db $C5 ; THRU
    .db $97
    .db $C3 ; ADJUSTMENT
    .db $2B
    .db $C5 ; WILLIAMS
    .db $D1
    .db $C3 ; DEFENDER
    .db $BD
    .db $C5 ; PRESS
    .db $0B
    .db $C3 ; ADVANCE
    .db $36
    .db $C5 ; TO
    .db $AD
    .db $C5 ; STEP
    .db $67
    .db $C5 ; THRU
    .db $97
    .db $C5 ; TEST
    .db $81
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; HIGHSCORE RESET
    .db $35
    .db $C5 ; TO
    .db $AD
    .db $C4 ; MAKE
    .db $90
    .db $C3 ; CHANGE
    .db $8C
    .db $C4 ; LANDER
    .db $84
    .db $07
    .db $03
    .db $06
    .db $C4 ; 150
    .db $B9
    .db $C4 ; MUTANT
    .db $B2
    .db $07
    .db $03
    .db $06
    .db $C4 ; 150
    .db $B9
    .db $C4 ; " POD"
    .db $FD
    .db $07
    .db $03
    .db $00
    .db $C4 ; 1000
    .db $C5
    .db $C3 ; BOMBER
    .db $6E
    .db $07
    .db $03
    .db $06
    .db $C4 ; 250
    .db $C1
    .db $C5 ; SWARMER
    .db $72
    .db $07
    .db $03
    .db $08
    .db $C4 ; 150
    .db $B9
    .db $C3 ; BAITER
    .db $5A
    .db $07
    .db $03
    .db $06
    .db $C4 ; 200
    .db $BD
    .db $C3 ; CREDITS:
    .db $B4
    .db $C5 ; SCANNER
    .db $36
    .db $C3 ; ELECTRONICS INC.
    .db $D9
    .db $07
    .db $07
    .db $03
    .db $0C
    .db $C5 ; PRESENTS
    .db $02
    .db $C4 ; PLAYER
    .db $EE
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; TWO
    .db $B7
    .db $C3 ; BONUS X
    .db $75
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; START
    .db $61
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; ONE
    .db $D4
    .db $C4 ; OR
    .db $DD
    .db $C5 ; TWO
    .db $B7
    .db $C4 ; PLAYER
    .db $EE
    .db $C5 ; START
    .db $61
    .db $C3 ; ATTACK
    .db $42
    .db $C5 ; WAVE
    .db $CC
    .db $C3 ; COMPLETED
    .db $A3
    .db $C5 ; YOU
    .db $DF
    .db $C4 ; HAVE
    .db $30
    .db $C5 ; QUALIFIED
    .db $11
    .db $C4 ; FOR
    .db $11
    .db $07
    .db $C5 ; THE
    .db $93
    .db $C3 ; DEFENDER
    .db $BD
    .db $C4 ; HALL OF FAME
    .db $23
    .db $07
    .db $07
    .db $C5 ; SELECT
    .db $3E
    .db $C4 ; INITIALS
    .db $6C
    .db $C5 ; WITH
    .db $DA
    .db $C5 ; UP
    .db $C0
    .db $C3 ; DOWN
    .db $D4
    .db $C5 ; STICK
    .db $6C
    .db $07
    .db $07
    .db $C5 ; PRESS
    .db $0B
    .db $C4 ; FIRE
    .db $0C
    .db $C5 ; TO
    .db $AD
    .db $C3 ; ENTER
    .db $EA
    .db $C4 ; INITIAL
    .db $64
    .db $A0 ; PTR to $A000
    .db $00
    .db $02
    .db $08
    .db $A0 ; PTR to $A002
    .db $02
    .db $02
    .db $10
    .db $A0 ; PTR to $A004
    .db $04
    .db $C4 ; HALL OF FAME
    .db $23
    .db $06
    .db $22
    .db $68
    .db $C5 ; TODAYS
    .db $B0
    .db $02
    .db $3E
    .db $C3 ; ALL
    .db $3E
    .db $C5 ; TIME
    .db $A8
    .db $07
    .db $03
    .db $FC
    .db $C4 ; GREATEST
    .db $1A
    .db $02
    .db $3D
    .db $C4 ; GREATEST
    .db $1A
    .db $A0 ; PTR to $A006
    .db $06
    .db $02
    .db $05
    .db $A0 ; PTR to $A008
    .db $08
    .db $02
    .db $13
    .db $A0 ; PTR to $A00C
    .db $0C
    .db $41 ; ADJUSTMENT
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $4D
    .db $45
    .db $4E
    .db $54
    .db $2F
    .db $41 ; ADVANCE
    .db $44
    .db $56
    .db $41
    .db $4E
    .db $43
    .db $45
    .db $2F
    .db $41 ; ALL
    .db $4C
    .db $4C
    .db $2F
    .db $41 ; ATTACK
    .db $54
    .db $54
    .db $41
    .db $43
    .db $4B
    .db $2F
    .db $41 ; AUDIO
    .db $55
    .db $44
    .db $49
    .db $4F
    .db $2F
    .db $41 ; AUDIT
    .db $55
    .db $44
    .db $49
    .db $54
    .db $2F
    .db $41 ; AUTO
    .db $55
    .db $54
    .db $4F
    .db $2F
    .db $42 ; BAITER
    .db $41
    .db $49
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $42 ; BARS
    .db $41
    .db $52
    .db $53
    .db $2F
    .db $42 ; BE
    .db $45
    .db $2F
    .db $42 ; BOMB
    .db $4F
    .db $4D
    .db $42
    .db $2F
    .db $42 ; BOMBER
    .db $4F
    .db $4D
    .db $42
    .db $45
    .db $52
    .db $2F
    .db $42 ; BONUS X
    .db $4F
    .db $4E
    .db $55
    .db $53
    .db $20
    .db $58
    .db $2F
    .db $43 ; CAN
    .db $41
    .db $4E
    .db $2F
    .db $2C ; ,
    .db $2F
    .db $3A ; :
    .db $2F
    .db $43 ; Center
    .db $45
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $43 ; Change
    .db $48
    .db $41
    .db $4E
    .db $47
    .db $45
    .db $2F
    .db $43 ; CMOS
    .db $4D
    .db $4F
    .db $53
    .db $2F
    .db $43 ; Coin
    .db $4F
    .db $49
    .db $4E
    .db $2F
    .db $43 ; Color
    .db $4F
    .db $4C
    .db $4F
    .db $52
    .db $2F
    .db $43 ; Completed
    .db $4F
    .db $4D
    .db $50
    .db $4C
    .db $45
    .db $54
    .db $45
    .db $44
    .db $2F
    .db $43 ; Credit
    .db $52
    .db $45
    .db $44
    .db $49
    .db $54
    .db $2F
    .db $43 ; Credits:
    .db $52
    .db $45
    .db $44
    .db $49
    .db $54
    .db $53
    .db $3A
    .db $2F
    .db $44 ; Defender
    .db $45
    .db $46
    .db $45
    .db $4E
    .db $44
    .db $45
    .db $52
    .db $2F
    .db $44 ; Detected
    .db $45
    .db $54
    .db $45
    .db $43
    .db $54
    .db $45
    .db $44
    .db $2F
    .db $44 ; Door
    .db $4F
    .db $4F
    .db $52
    .db $2F
    .db $44 ; Down
    .db $4F
    .db $57
    .db $4E
    .db $2F
    .db $45 ; Electronics Inc.
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $52
    .db $4F
    .db $4E
    .db $49
    .db $43
    .db $53
    .db $20
    .db $49
    .db $4E
    .db $43
    .db $2E
    .db $2F
    .db $45 ; Enter
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $45 ; Entered
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $45
    .db $44
    .db $2F
    .db $45 ; Errors
    .db $52
    .db $52
    .db $4F
    .db $52
    .db $53
    .db $2F
    .db $45 ; Exit
    .db $58
    .db $49
    .db $54
    .db $2F
    .db $46 ; Failure
    .db $41
    .db $49
    .db $4C
    .db $55
    .db $52
    .db $45
    .db $2F
    .db $46 ; Fire
    .db $49
    .db $52
    .db $45
    .db $2F
    .db $46 ; For
    .db $4F
    .db $52
    .db $2F
    .db $47 ; Game
    .db $41
    .db $4D
    .db $45
    .db $2F
    .db $47 ; Greatest
    .db $52
    .db $45
    .db $41
    .db $54
    .db $45
    .db $53
    .db $54
    .db $2F
    .db $48 ; Hall of Fame
    .db $41
    .db $4C
    .db $4C
    .db $20
    .db $4F
    .db $46
    .db $20
    .db $46
    .db $41
    .db $4D
    .db $45
    .db $2F
    .db $48 ; Have
    .db $41
    .db $56
    .db $45
    .db $2F
    .db $48 ; Highscore Reset
    .db $49
    .db $47
    .db $48
    .db $53
    .db $43
    .db $4F
    .db $52
    .db $45
    .db $20
    .db $52
    .db $45
    .db $53
    .db $45
    .db $54
    .db $2F
    .db $48 ; Hyperspace
    .db $59
    .db $50
    .db $45
    .db $52
    .db $53
    .db $50
    .db $41
    .db $43
    .db $45
    .db $2F
    .db $49 ; Indicate
    .db $4E
    .db $44
    .db $49
    .db $43
    .db $41
    .db $54
    .db $45
    .db $2F
    .db $49 ; Individual
    .db $4E
    .db $44
    .db $49
    .db $56
    .db $49
    .db $44
    .db $55
    .db $41
    .db $4C
    .db $2F
    .db $49 ; Initial
    .db $4E
    .db $49
    .db $54
    .db $49
    .db $41
    .db $4C
    .db $2F
    .db $49 ; Initials
    .db $4E
    .db $49
    .db $54
    .db $49
    .db $41
    .db $4C
    .db $53
    .db $2F
    .db $49 ; Invalid Switch
    .db $4E
    .db $56
    .db $41
    .db $4C
    .db $49
    .db $44
    .db $20
    .db $53
    .db $57
    .db $49
    .db $54
    .db $43
    .db $48
    .db $2F
    .db $4C ; Lander
    .db $41
    .db $4E
    .db $44
    .db $45
    .db $52
    .db $2F
    .db $4C ; Left
    .db $45
    .db $46
    .db $54
    .db $2F
    .db $4D ; Make
    .db $41
    .db $4B
    .db $45
    .db $2F
    .db $4D ; Manual
    .db $41
    .db $4E
    .db $55
    .db $41
    .db $4C
    .db $2F
    .db $4D ; Monitor
    .db $4F
    .db $4E
    .db $49
    .db $54
    .db $4F
    .db $52
    .db $2F
    .db $4D ; Multiple
    .db $55
    .db $4C
    .db $54
    .db $49
    .db $50
    .db $4C
    .db $45
    .db $2F
    .db $4D ; Must
    .db $55
    .db $53
    .db $54
    .db $2F
    .db $4D ; Mutant
    .db $55
    .db $54
    .db $41
    .db $4E
    .db $54
    .db $2F
    .db $31 ; 150
    .db $35
    .db $30
    .db $2F
    .db $32 ; 200
    .db $30
    .db $30
    .db $2F
    .db $32 ; 250
    .db $35
    .db $30
    .db $2F
    .db $31 ; 1000
    .db $30
    .db $30
    .db $30
    .db $2F
    .db $4E ; No
    .db $4F
    .db $2F
    .db $4E ; Not
    .db $4F
    .db $54
    .db $2F
    .db $4F ; OK
    .db $4B
    .db $2F
    .db $4F ; One
    .db $4E
    .db $45
    .db $2F
    .db $4F ; Open
    .db $50
    .db $45
    .db $4E
    .db $2F
    .db $4F ; Or
    .db $52
    .db $2F
    .db $4F ; Over
    .db $56
    .db $45
    .db $52
    .db $2F
    .db $50 ; Patterns
    .db $41
    .db $54
    .db $54
    .db $45
    .db $52
    .db $4E
    .db $53
    .db $2F
    .db $50 ; Player
    .db $4C
    .db $41
    .db $59
    .db $45
    .db $52
    .db $2F
    .db $50 ; Players
    .db $4C
    .db $41
    .db $59
    .db $45
    .db $52
    .db $53
    .db $2F
    .db $20 ; " POD"
    .db $50
    .db $4F
    .db $44
    .db $2F
    .db $50 ; Presents
    .db $52
    .db $45
    .db $53
    .db $45
    .db $4E
    .db $54
    .db $53
    .db $2F
    .db $50 ; Press
    .db $52
    .db $45
    .db $53
    .db $53
    .db $2F
    .db $51 ; Qualified
    .db $55
    .db $41
    .db $4C
    .db $49
    .db $46
    .db $49
    .db $45
    .db $44
    .db $2F
    .db $52 ; RAM
    .db $41
    .db $4D
    .db $2F
    .db $52 ; Reverse
    .db $45
    .db $56
    .db $45
    .db $52
    .db $53
    .db $45
    .db $2F
    .db $52 ; Right
    .db $49
    .db $47
    .db $48
    .db $54
    .db $2F
    .db $52 ; ROM
    .db $4F
    .db $4D
    .db $2F
    .db $52 ; ROMS
    .db $4F
    .db $4D
    .db $53
    .db $2F
    .db $53 ; Scanner
    .db $43
    .db $41
    .db $4E
    .db $4E
    .db $45
    .db $52
    .db $2F
    .db $53 ; Select
    .db $45
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $2F
    .db $53 ; Set
    .db $45
    .db $54
    .db $2F
    .db $53 ; Slam
    .db $4C
    .db $41
    .db $4D
    .db $2F
    .db $53 ; Smart
    .db $4D
    .db $41
    .db $52
    .db $54
    .db $2F
    .db $53 ; Sound
    .db $4F
    .db $55
    .db $4E
    .db $44
    .db $2F
    .db $53 ; Sounds
    .db $4F
    .db $55
    .db $4E
    .db $44
    .db $53
    .db $2F
    .db $53 ; Start
    .db $54
    .db $41
    .db $52
    .db $54
    .db $2F
    .db $53 ; Step
    .db $54
    .db $45
    .db $50
    .db $2F
    .db $53 ; Stick
    .db $54
    .db $49
    .db $43
    .db $4B
    .db $2F
    .db $53 ; Swarmer
    .db $57
    .db $41
    .db $52
    .db $4D
    .db $45
    .db $52
    .db $2F
    .db $53 ; Switch
    .db $57
    .db $49
    .db $54
    .db $43
    .db $48
    .db $2F
    .db $54 ; Test
    .db $45
    .db $53
    .db $54
    .db $2F
    .db $54 ; Tested
    .db $45
    .db $53
    .db $54
    .db $45
    .db $44
    .db $2F
    .db $54 ; Tests
    .db $45
    .db $53
    .db $54
    .db $53
    .db $2F
    .db $54 ; The
    .db $48
    .db $45
    .db $2F
    .db $54 ; Thru
    .db $48
    .db $52
    .db $55
    .db $2F
    .db $54 ; Thrust
    .db $48
    .db $52
    .db $55
    .db $53
    .db $54
    .db $2F
    .db $54 ; Tilt
    .db $49
    .db $4C
    .db $54
    .db $2F
    .db $54 ; Time
    .db $49
    .db $4D
    .db $45
    .db $2F
    .db $54 ; To
    .db $4F
    .db $2F
    .db $54 ; Todays
    .db $4F
    .db $44
    .db $41
    .db $59
    .db $53
    .db $2F
    .db $54 ; Two
    .db $57
    .db $4F
    .db $2F
    .db $55 ; Unit
    .db $4E
    .db $49
    .db $54
    .db $2F
    .db $55 ; Up
    .db $50
    .db $2F
    .db $56 ; Vertical
    .db $45
    .db $52
    .db $54
    .db $49
    .db $43
    .db $41
    .db $4C
    .db $2F
    .db $57 ; Wave
    .db $41
    .db $56
    .db $45
    .db $2F
    .db $57 ; Williams
    .db $49
    .db $4C
    .db $4C
    .db $49
    .db $41
    .db $4D
    .db $53
    .db $2F
    .db $57 ; With
    .db $49
    .db $54
    .db $48
    .db $2F
    .db $59 ; You
    .db $4F
    .db $55
    .db $2F
TEXT_GRAPHICS_INFO: ; 0x0045E3, $C5E3
    .db $01 ; FORMAT:[X/2,Y,PTR_TO_BITMAP]?
    .db $08
    .db $C6 ; PTR 0
    .db $97
    .db $01
    .db $08
    .db $C6 ; PTR 1
    .db $AF
    .db $01
    .db $08
    .db $C6 ; PTR 2
    .db $B7
    .db $03
    .db $08
    .db $C7 ; PTR 3
    .db $BF
    .db $01
    .db $08
    .db $C6 ; PTR 4
    .db $BF
    .db $03
    .db $08
    .db $C7 ; PTR 5
    .db $BF
    .db $03
    .db $08
    .db $C6 ; PTR 6
    .db $C7
    .db $03
    .db $08
    .db $C6 ; PTR 7
    .db $DF
    .db $03
    .db $08
    .db $C6 ; PTR 8
    .db $F7
    .db $03
    .db $08
    .db $C7 ; PTR 9
    .db $0F
    .db $03
    .db $08
    .db $C7 ; PTR 10
    .db $27
    .db $03
    .db $08
    .db $C7 ; PTR 11
    .db $3F
    .db $03
    .db $08
    .db $C7 ; PTR 12
    .db $57
    .db $03
    .db $08
    .db $C7 ; PTR 13
    .db $6F
    .db $03
    .db $08
    .db $C7 ; PTR 14
    .db $87
    .db $03
    .db $08
    .db $C7 ; PTR 15
    .db $9F
    .db $01
    .db $08
    .db $C7 ; PTR 16
    .db $B7
    .db $03
    .db $08
    .db $C7 ; PTR 17
    .db $BF
    .db $03
    .db $08
    .db $C6 ; PTR 18
    .db $97
    .db $03
    .db $08
    .db $C7 ; PTR 19
    .db $D7
    .db $03
    .db $08
    .db $C7 ; PTR 20
    .db $EF
    .db $03
    .db $08
    .db $C8 ; PTR 21
    .db $07
    .db $03
    .db $08
    .db $C8 ; PTR 22
    .db $1F
    .db $03
    .db $08
    .db $C8 ; PTR 23
    .db $37
    .db $03
    .db $08
    .db $C8 ; PTR 24
    .db $4F
    .db $03
    .db $08
    .db $C8 ; PTR 25
    .db $67
    .db $03
    .db $08
    .db $C8 ; PTR 26
    .db $7F
    .db $02
    .db $08
    .db $C8 ; PTR 27
    .db $97
    .db $03
    .db $08
    .db $C8 ; PTR 28
    .db $A7
    .db $03
    .db $08
    .db $C8 ; PTR 29
    .db $BF
    .db $03
    .db $08
    .db $C8 ; PTR 30
    .db $D7
    .db $04
    .db $08
    .db $C8 ; PTR 31
    .db $EF
    .db $03
    .db $08
    .db $C9 ; PTR 32
    .db $0F
    .db $03
    .db $08
    .db $C9 ; PTR 33
    .db $27
    .db $03
    .db $08
    .db $C9 ; PTR 34
    .db $3F
    .db $03
    .db $08
    .db $C9 ; PTR 35
    .db $57
    .db $03
    .db $08
    .db $C9 ; PTR 36
    .db $6F
    .db $03
    .db $08
    .db $C9 ; PTR 37
    .db $87
    .db $03
    .db $08
    .db $C9 ; PTR 38
    .db $9F
    .db $03
    .db $08
    .db $C9 ; PTR 39
    .db $B7
    .db $03
    .db $08
    .db $C9 ; PTR 40
    .db $CF
    .db $04
    .db $08
    .db $C9 ; PTR 41
    .db $E7
    .db $03
    .db $08
    .db $CA ; PTR 42
    .db $07
    .db $03
    .db $08
    .db $CA ; PTR 43
    .db $1F
    .db $03
    .db $08
    .db $CA ; PTR 44
    .db $37
    .db $00 ; TEXT_BITMAP_0,18
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_1
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $00 ; TEXT_BITMAP_2
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $10
    .db $00 ; TEXT_BITMAP_4
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_6
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $00 ; TEXT_BITMAP_7
    .db $00
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_8
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $01
    .db $10
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_9
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $00 ; TEXT_BITMAP_10
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $10
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_11
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_12
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_13
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $01
    .db $11
    .db $10
    .db $10
    .db $00
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_14
    .db $01
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $10
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_15
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $00 ; TEXT_BITMAP_16
    .db $00
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_3,5,17
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_19
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_20
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_21
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_22
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $10
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $10
    .db $00
    .db $01 ; TEXT_BITMAP_23
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $10
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_24
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $00
    .db $00
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_25
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_26
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $01
    .db $01
    .db $01
    .db $11
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_27
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $00 ; TEXT_BITMAP_28
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_29
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $11
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $10
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_30
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_31
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_32
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_33
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_34
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_35
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $01
    .db $11
    .db $11
    .db $10
    .db $01 ; TEXT_BITMAP_36
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $01
    .db $01
    .db $11
    .db $10
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_37
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $11
    .db $10
    .db $10
    .db $11
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $11 ; TEXT_BITMAP_38
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $11
    .db $00
    .db $11
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_39
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $01 ; TEXT_BITMAP_40
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $10
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_41
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $01
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_42
    .db $01
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $10
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $10
    .db $00
    .db $10
    .db $01
    .db $01
    .db $00
    .db $01 ; TEXT_BITMAP_43
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $10
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $01
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; TEXT_BITMAP_44
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $00
    .db $01
    .db $10
    .db $00
    .db $00
    .db $11
    .db $00
    .db $11
    .db $10
    .db $00
    .db $00
    .db $00
    .db $00
    .db $11
    .db $00
    .db $84
    .db $FF
TEXT_SENTENCE_RTN_PTR=$C0D9: ; 0x004A51, $CA51
    PSHS  U,Y,X ; Save...
    LDU   #$C0D9 ; Sentences ptr start.
    BRA   DO_TEXT_SOMETHING
TEXT_SENTENCE_RTN_PTR=$C0BB: ; 0x004A58, $CA58
    PSHS  U,Y,X ; Save...
    LDU   #$C0BB ; More sentences ptr
DO_TEXT_SOMETHING: ; 0x004A5D, $CA5D
    LDX   #$18CE ; Screen position.
    JSR   TEXT_RTN_PTRS=$FFB3/$CAED ; Something to screen.
    LDU   Y++ ; ptr from Y
    BEQ   LOADED_NULL ; If was null, taken.
    LDX   #$10DA ; Screen location.
    JSR   TEXT_RTN_PTRS=$FFB3/$CAED ; Something to screen.
LOADED_NULL: ; 0x004A6D, $CA6D
    LDU   Y++ ; Get U from Y again.
    BEQ   LOADED_NULL_2 ; If was null, taken.
    LDX   #$10E4 ; Position.
    JSR   TEXT_RTN_PTRS=$FFB3/$CAED ; Something to screen.
LOADED_NULL_2: ; 0x004A77, $CA77
    PULS  X,Y,U,PC ; Restore+RTS
TEXT_RTN_SPECIAL_PTR=$FFB6: ; 0x004A79, $CA79
    PSHS  U,Y,X,B,A,CC ; Save state
    LDY   #$FFB6 ; Ptr to unk rtn
    BRA   TEXT_RTN_UNK_MAIN
TEXT_RTN_SPECIAL_PTR=$FFB3: ; 0x004A81, $CA81
    PSHS  U,Y,X,B,A,CC ; Save state
    LDY   #$FFB3 ; PTR to JMP to GFX_TO_SCREEN
TEXT_RTN_UNK_MAIN: ; 0x004A87, $CA87
    LDD   #$CAED ; PTR to SKIP_SENTENCE_INIT
    STY   TEXT_PTR_TO_CODE_JSR ; Store JSR PTR
    STD   TEXT_PTR_TO_CODE_JMP ; Store JMP PTR
    STX   SENTENCE_CURR_SCR_LOC_XXYY ; Store SCR_LOC
    STX   SENTENCE_CURR_SCR_LOC_CR_XXYY? ; Store SCR_LOC_CR
    LDX   #$010A ; Spacing value.
    STX   TEXT_DATA_SPACING_XXYY?
    CLR   SENTENCE_FLAG_58 ; Clear flag.
    LDU   5,S ; Get value up stack.
    STU   SENTENCE_PTR_TO_WORD ; Is ptr to word.
    LEAU  32,U ; Clean up 32 bytes of stack???
    STU   SENTENCE_END_PTR ; Store the stack as the end ptr?
    STU   SENTENCE_PTR_WORD_ON ; And the word on?
    BRA   SKIP_SENTENCE_INIT ; Goto code
TEXT_RTN_PTRS=$FFB3/$CAED: ; 0x004AA7, $CAA7
    PSHS  U,Y,X,B,A,CC ; Save
    LDY   #$FFB3 ; JSR ptr, JMP to TEXT_CHAR_TO_SCREEN
    LDD   #$CAED ; JMP ptr, SKIP_SENTENCE_INIT
    BRA   SENTENCE_TO_SCREEN
TEXT_RTN_PTRS=$FFB6/$CAED: ; 0x004AB2, $CAB2
    PSHS  U,Y,X,B,A,CC
    LDY   #$FFB6 ; PTR to JMP unk
    LDD   #$CAED
    BRA   SENTENCE_TO_SCREEN
TEST_RTN_PTRS=$FFB3/$CB5F: ; 0x004ABD, $CABD
    PSHS  U,Y,X,B,A,CC
    LDY   #$FFB3 ; PTR to JMP unk
    LDD   #$CB5F ; PTR to 4B5F, Pulls state, clears a CC bit, RTS's.
    BRA   SENTENCE_TO_SCREEN
TEXT_RTN_PTRS=$FFB6/$CB5F: ; 0x004AC8, $CAC8
    PSHS  U,Y,X,B,A,CC ; Save stuff
    LDY   #$FFB6
    LDD   #$CB5F
SENTENCE_TO_SCREEN: ; 0x004AD1, $CAD1
    STY   TEXT_PTR_TO_CODE_JSR ; Store ptr JSR'd to.
    STD   TEXT_PTR_TO_CODE_JMP ; Store ptr to JMP.
    TST   SENTENCE_PTR_WORD_ON ; Test if top byte not null
    BNE   SKIP_SENTENCE_INIT ; If is set, don't init.
    STX   SENTENCE_CURR_SCR_LOC_XXYY ; Screen location current
    STX   SENTENCE_CURR_SCR_LOC_CR_XXYY? ; Screen location when carriage returned (CR)
    LDX   #$010A ; Not sure of val. Add per char?
    STX   TEXT_DATA_SPACING_XXYY? ; Store
    CLR   SENTENCE_FLAG_58 ; Clear
    LDX   2,U ; Get end of sentence.
    STX   SENTENCE_END_PTR ; End of sentence.
    LDX   U ; Load X with beginning of sentence.
    BRA   MORE_THINGS_TO_DO ; Do things.
SKIP_SENTENCE_INIT: ; 0x004AED, $CAED
    TST   SENTENCE_FLAG_58 ; Test
    BNE   FLAG_58_SET
    LDX   SENTENCE_PTR_TO_WORD ; Get word ptr
    LDB   X+ ; Load
    CMPB  #$2F ; #$2F='\0' here.
    BNE   NOT_END_OF_STRING ; Not end, put to screen.
    LDB   #$20 ; Space in ascii, probs just flag value tho.
    STB   SENTENCE_FLAG_58 ; Not sure why stored.
    BRA   NOT_END_OF_STRING ; Always space at end.
FLAG_58_SET: ; 0x004AFF, $CAFF
    CLR   SENTENCE_FLAG_58 ; clear
    LDX   SENTENCE_PTR_WORD_ON
DO_MORE_AFTER_CMD: ; 0x004B03, $CB03
    CMPX  SENTENCE_END_PTR ; Compare to end?
    BNE   MORE_THINGS_TO_DO
TOP_GT|E_8: ; 0x004B07, $CB07
    CLR   SENTENCE_PTR_WORD_ON ; Clear setup check loc.
    PULS  CC,A,B,X,Y,U ; Restore
    ORCC  #$01 ; Set CC.c
    RTS ; leave.
MORE_THINGS_TO_DO: ; 0x004B0E, $CB0E
    LDU   X++ ; Loads sentence word ptr.
    BMI   DATA_IS_NOT_CMD ; If top bit set. In ROM test?
    LEAX  -1,X ; Not PTR, command, minus 1 because CMD is byte.
    TFR   U>D ; Save U to D
    CMPA  #$08 ; Top byte
    BHI   TOP_GT|E_8 ; Leaves
    ASLA ; Make index to ptr
    LDY   #$CB64 ; ptr
    JSR   [A,Y] ; Run code.
    BRA   DO_MORE_AFTER_CMD
DATA_IS_NOT_CMD: ; 0x004B23, $CB23
    STX   SENTENCE_PTR_WORD_ON ; Store index into sentence, aka word
    STU   SENTENCE_PTR_TO_WORD ; Store word ptr
    BRA   SKIP_SENTENCE_INIT ; Goto
NOT_END_OF_STRING: ; 0x004B29, $CB29
    STX   SENTENCE_PTR_TO_WORD ; Store index into word.
    SUBB  #$20 ; B-=20
    CMPB  #$01 ; CMP 0x20-0x21
    BLS   TEXT_CASE_USE_B ; If <=21
    CMPB  #$0B
    BLS   TEXT_CASE_USE_3 ; Misc ascii. Control chars?
    SUBB  #$0A ; B-=0x2A
    CMPB  #$10 ; CMP 0x2A to 0x3A
    BLS   TEXT_CASE_USE_B ; if <=
    CMPB  #$14 ; CMP 0x3B to 0x3E
    BLS   TEXT_CASE_USE_3 ; if <=
    SUBB  #$04 ; B-=2E
    CMPB  #$2C ; CMP 0x2E to 5A
    BLS   TEXT_CASE_USE_B
TEXT_CASE_USE_3: ; 0x004B45, $CB45
    LDB   #$03 ; Turns to 0xC
TEXT_CASE_USE_B: ; 0x004B47, $CB47
    ASLB ; Multiply by 4
    ASLB
    LDX   #$C5E3 ; TEXT_POINTER_START
    ABX ; Add to X
    TFR   X>Y ; Put to Y
    LDD   SENTENCE_CURR_SCR_LOC_XXYY ; Load screen location
    LDX   TEXT_PTR_TO_CODE_JSR ; Load ptr to code
    JSR   X ; JSR to ptr
    ADDA  Y ; Add to A@Y
    ADDA  TEXT_DATA_SPACING_XXYY? ; Add to A from mem. Minimum movement?
    STA   SENTENCE_CURR_SCR_LOC_XXYY ; Store high byte. Horizontal pos?
    LDX   TEXT_PTR_TO_CODE_JMP ; Load...
    JMP   X ; JMP to loc.
    PULS  CC,A,B,X,Y,U ; PTR'd code. Pull state.
    ANDCC #$FE ; Clear CC.C
    RTS ; RTS
TEXT_FUNCTION_POINTERS: ; 0x004B64, $CB64
    .db $CB ; FORMAT: [ptr], points to code after table. Text functions.
    .db $76
    .db $CB
    .db $7B
    .db $CB
    .db $80
    .db $CB
    .db $87
    .db $CB
    .db $8E
    .db $CB
    .db $95
    .db $CB
    .db $9C
    .db $CB
    .db $A3
    .db $CB
    .db $AC
TEXT_FUNC_CHANGE_SPACING_X: ; 0x004B76, $CB76
    LDA   X+ ; These functions called by table above front str/text routine
    STA   TEXT_DATA_SPACING_XXYY?
    RTS
TEXT_FUNC_CHANGE_SPACING_Y: ; 0x004B7B, $CB7B
    LDB   X+
    STB   TEXT_DATA_SPACING_XXYY?+1
    RTS
TEXT_FUNC_CR.X+DATA_TO_POSX: ; 0x004B80, $CB80
    LDA   SENTENCE_CURR_SCR_LOC_CR_XXYY?
    ADDA  X+
    STA   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_POS.X+=DATA: ; 0x004B87, $CB87
    LDA   SENTENCE_CURR_SCR_LOC_XXYY
    ADDA  X+
    STA   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_CR.Y+DATA_TO_POSY: ; 0x004B8E, $CB8E
    LDB   SENTENCE_CURR_SCR_LOC_CR_XXYY?+1
    ADDB  X+
    STB   SENTENCE_CURR_SCR_LOC_XXYY+1
    RTS
TEXT_FUNC_POS.Y+=DATA: ; 0x004B95, $CB95
    LDB   SENTENCE_CURR_SCR_LOC_XXYY+1
    ADDB  X+
    STB   SENTENCE_CURR_SCR_LOC_XXYY+1
    RTS
TEXT_FUNC_DATA_TO_CR+POS: ; 0x004B9C, $CB9C
    LDD   X++
    STD   SENTENCE_CURR_SCR_LOC_CR_XXYY?
    STD   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_CR: ; 0x004BA3, $CBA3
    LDA   SENTENCE_CURR_SCR_LOC_CR_XXYY?
    LDB   SENTENCE_CURR_SCR_LOC_XXYY+1
    ADDB  TEXT_DATA_SPACING_XXYY?+1
    STD   SENTENCE_CURR_SCR_LOC_XXYY
    RTS
TEXT_FUNC_JSR_ADD_JMP_IDK: ; 0x004BAC, $CBAC
    LDY   X++ ; Y from X
    STX   SENTENCE_PTR_WORD_ON ; Store stream ptr.
    LDX   TEXT_PTR_TO_CODE_JSR ; X from var.
    JSR   X ; JSR to code...
    ADDA  Y ; A+=@Y
    ADDA  TEXT_DATA_SPACING_XXYY? ; Add spacing, too.
    STA   SENTENCE_CURR_SCR_LOC_XXYY ; Store to POS.X
    LEAS  2,S ; Clean up stack from JSR here.
    LDX   TEXT_PTR_TO_CODE_JMP ; Load from
    JMP   X ; Goto
TEXT_RTN_PTRS=$FFB3/$CC0F: ; 0x004BC1, $CBC1
    PSHS  U,Y,X,B,A,CC ; Save state.
    LDY   #$FFB3 ; JMP to TEXT_CHAR_TO_SCREEN
    LDU   #$CC0F ; PTR to AND #$F0 below
    BRA   TEXT_RTN_UNK_BASE
TEXT_RTN_PTRS=$FFB6/$CC0F: ; 0x004BCC, $CBCC
    PSHS  U,Y,X,B,A,CC ; Save state.
    LDY   #$FFB6 ; PTR to JMP to unknown code.
    LDU   #$CC0F ; PTR to CMPA #$F0 below.
    BRA   TEXT_RTN_UNK_BASE
TEXT_RTN_PTRS=$FFB3/$CC39: ; 0x004BD7, $CBD7
    PSHS  U,Y,X,B,A,CC ; Save state
    LDY   #$FFB3 ; JMP to TEXT_CHAR_TO_SCREEN
    LDU   #$CC39 ; PTR to restore and RTS
    BRA   TEXT_RTN_UNK_BASE
TEXT_RTN_PTRS=$FFB6/$CC39: ; 0x004BE2, $CBE2
    PSHS  U,Y,X,B,A,CC
    LDY   #$FFB6 ; PTR to JMP to unknown code.
    LDU   #$CC39 ; PTR to restore and RTS
TEXT_RTN_UNK_BASE: ; 0x004BEB, $CBEB
    STY   TEXT_PTR_TO_CODE_JSR ; Store to JSR
    STU   TEXT_PTR_TO_CODE_JMP ; Store to JMP.
    LDU   TEXT_PTR_UNK
    CMPU  #$FFFF ; Is..
    BNE   TEXT_PTR_NOT_FFFF ; != to FF, go here.
    STX   SENTENCE_CURR_SCR_LOC_XXYY ; Put stream to location, temp.
    STD   TEXT_PTR_UNK ; Put D to PTR?
    BNE   BIT_STUFF_IDK ; Get jumped in the middle of maybe?
    LDD   #$0FFF ; Just do it once?
    BRA   STD_UNK
BIT_STUFF_IDK: ; 0x004C03, $CC03
    BITA  #$F0 ; Test top bits.
    BNE   STD_UNK ; If any bits set, taken.
    BSR   MANIPULATE_D ; D << 4, D|= 0x000F
    BRA   BIT_STUFF_IDK
STD_UNK: ; 0x004C0B, $CC0B
    STD   TEXT_PTR_UNK ; Store D
TEXT_PTR_NOT_FFFF: ; 0x004C0D, $CC0D
    LDD   TEXT_PTR_UNK ; Load D
    ANDA  #$F0 ; Test top bits.
    CMPA  #$F0
    BNE   NOT_0xF0 ; Not 0xF0
    PULS  CC,A,B,X,Y,U ; Pull state
    LDX   SENTENCE_CURR_SCR_LOC_XXYY ; Get stream from temp.
    ORCC  #$01 ; CC.C = 1
    RTS ; Leave
NOT_0xF0: ; 0x004C1C, $CC1C
    LSRA ; A>>2...
    LSRA
    LDX   #$C5FB ; PTR to...
    LEAY  A,X ; Y from X+A
    LDD   SENTENCE_CURR_SCR_LOC_XXYY ; Load pos
    LDX   TEXT_PTR_TO_CODE_JSR ; Load JSR
    JSR   X ; Do JSR
    ADDA  Y ; Add A@Y
    ADDA  TEXT_DATA_SPACING_XXYY? ; Add to spacing X
    STA   SENTENCE_CURR_SCR_LOC_XXYY ; Store to POS.X
    LDD   TEXT_PTR_UNK ; Get unk
    BSR   MANIPULATE_D ; Manipulate
    STD   TEXT_PTR_UNK ; Store
    LDX   TEXT_PTR_TO_CODE_JMP ; Get code to jump to.
    JMP   X ; Jump to var.
    PULS  CC,A,B,X,Y,U ; Pull saved
    ANDCC #$FE ; Clear CC.C
    RTS ; RTS
MANIPULATE_D: ; 0x004C3E, $CC3E
    ASLB ; D << 4, bringing in 0's.
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    ORB   #$0F ; D |= 0x000F, setting all shifted to 0's.
    RTS ; Leave
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $05
    .db $38
    .db $4E
    .db $CE
    .db $96
    .db $09
    .db $AC
    .db $42
    .db $90
    .db $16
    .db $52
    .db $A8
    .db $F2
    .db $12
    .db $96
    .db $6A
    .db $08
    .db $C0
    .db $DE
    .db $CA
    .db $A5
    .db $54
    .db $1B
    .db $88
    .db $2D
    .db $59
    .db $A3
    .db $96
    .db $41
    .db $DC
    .db $EF
    .db $A3
    .db $27
    .db $03
    .db $B6
    .db $1C
    .db $EF
    .db $5E
    .db $FF
    .db $D7
    .db $B0
    .db $56
    .db $A4
    .db $76
    .db $C3
    .db $A0
    .db $90
    .db $9B
    .db $D9
    .db $08
    .db $D3
    .db $04
    .db $CB
    .db $99
    .db $C8
    .db $70
    .db $43
    .db $94
    .db $33
    .db $7B
    .db $6B
    .db $8D
    .db $B2
    .db $F8
    .db $00
    .db $0C
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $0C
    .db $00
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $00
    .db $C0
    .db $CC
    .db $CC
    .db $CC
    .db $CC
    .db $C0
    .db $00
    .db $A0
    .db $0A
    .db $A0
    .db $A0
    .db $00
    .db $A0
    .db $0A
    .db $00
    .db $0A
    .db $0A
    .db $A0
    .db $0A
    .db $0A
    .db $AA
    .db $0A
    .db $00
    .db $A0
    .db $00
    .db $00
    .db $0A
    .db $00
    .db $A0
    .db $AA
    .db $A0
    .db $00
    .db $02
    .db $23
    .db $02
    .db $20
    .db $22
    .db $23
    .db $22
    .db $00
    .db $00
    .db $20
    .db $00
    .db $00
    .db $00
    .db $02
    .db $00
    .db $02
    .db $22
    .db $32
    .db $22
    .db $00
    .db $20
    .db $32
    .db $20
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $04
    .db $34
    .db $30
    .db $30
    .db $34
    .db $30
    .db $00
    .db $00
    .db $44
    .db $44
    .db $33
    .db $33
    .db $34
    .db $30
    .db $30
    .db $30
    .db $00
    .db $30
    .db $03
    .db $03
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $33
    .db $33
    .db $03
    .db $03
    .db $30
    .db $00
    .db $44
    .db $44
    .db $03
    .db $03
    .db $43
    .db $03
    .db $03
    .db $03
    .db $40
    .db $43
    .db $30
    .db $30
    .db $43
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $04
    .db $34
    .db $03
    .db $03
    .db $34
    .db $30
    .db $00
    .db $00
    .db $44
    .db $44
    .db $30
    .db $30
    .db $34
    .db $30
    .db $30
    .db $30
    .db $00
    .db $30
    .db $33
    .db $33
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $30
    .db $30
    .db $03
    .db $03
    .db $30
    .db $00
    .db $44
    .db $44
    .db $33
    .db $33
    .db $43
    .db $03
    .db $03
    .db $03
    .db $40
    .db $43
    .db $03
    .db $03
    .db $43
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $00
    .db $03
    .db $03
    .db $00
    .db $00
    .db $03
    .db $30
    .db $00
    .db $33
    .db $33
    .db $33
    .db $33
    .db $30
    .db $00
    .db $00
    .db $00
    .db $33
    .db $03
    .db $03
    .db $33
    .db $30
    .db $30
    .db $30
    .db $00
    .db $30
    .db $33
    .db $33
    .db $30
    .db $30
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $33
    .db $33
    .db $03
    .db $03
    .db $30
    .db $00
    .db $00
    .db $33
    .db $30
    .db $30
    .db $03
    .db $03
    .db $03
    .db $03
    .db $00
    .db $33
    .db $33
    .db $33
    .db $33
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $30
    .db $00
    .db $00
    .db $30
    .db $03
    .db $00
    .db $03
    .db $34
    .db $03
    .db $33
    .db $70
    .db $40
    .db $33
    .db $33
    .db $07
    .db $44
    .db $33
    .db $33
    .db $00
    .db $04
    .db $33
    .db $30
    .db $73
    .db $40
    .db $33
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $37
    .db $44
    .db $33
    .db $33
    .db $00
    .db $04
    .db $33
    .db $33
    .db $70
    .db $40
    .db $33
    .db $33
    .db $07
    .db $44
    .db $33
    .db $00
    .db $30
    .db $03
    .db $30
    .db $00
    .db $03
    .db $30
    .db $03
    .db $33
    .db $00
    .db $44
    .db $33
    .db $33
    .db $70
    .db $04
    .db $33
    .db $33
    .db $07
    .db $40
    .db $33
    .db $30
    .db $03
    .db $44
    .db $33
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $30
    .db $04
    .db $33
    .db $33
    .db $07
    .db $40
    .db $33
    .db $33
    .db $00
    .db $44
    .db $33
    .db $33
    .db $70
    .db $04
    .db $33
    .db $00
    .db $30
    .db $43
    .db $30
    .db $00
    .db $03
    .db $34
    .db $03
    .db $33
    .db $07
    .db $04
    .db $33
    .db $33
    .db $00
    .db $40
    .db $33
    .db $33
    .db $70
    .db $44
    .db $33
    .db $30
    .db $03
    .db $04
    .db $33
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $03
    .db $30
    .db $40
    .db $33
    .db $33
    .db $70
    .db $44
    .db $33
    .db $33
    .db $07
    .db $04
    .db $33
    .db $33
    .db $00
    .db $40
    .db $33
    .db $00
    .db $30
    .db $43
    .db $30
    .db $00
    .db $06
    .db $26
    .db $06
    .db $26
    .db $00
    .db $66
    .db $66
    .db $66
    .db $88
    .db $88
    .db $88
    .db $00
    .db $60
    .db $66
    .db $66
    .db $88
    .db $86
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $93
    .db $00
    .db $00
    .db $00
    .db $6D
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $EF
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $69
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $02
    .db $00
    .db $02
    .db $00
    .db $06
    .db $66
    .db $66
    .db $28
    .db $68
    .db $08
    .db $60
    .db $66
    .db $66
    .db $86
    .db $88
    .db $88
    .db $00
    .db $00
    .db $60
    .db $66
    .db $86
    .db $69
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $30
    .db $00
    .db $00
    .db $00
    .db $DE
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $F0
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $93
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $39
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0F
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $ED
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $03
    .db $00
    .db $00
    .db $06
    .db $66
    .db $68
    .db $96
    .db $06
    .db $66
    .db $66
    .db $68
    .db $88
    .db $88
    .db $60
    .db $66
    .db $66
    .db $83
    .db $86
    .db $80
    .db $00
    .db $00
    .db $30
    .db $00
    .db $30
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $96
    .db $00
    .db $00
    .db $00
    .db $00
    .db $FE
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $D6
    .db $66
    .db $00
    .db $00
    .db $00
    .db $00
    .db $66
    .db $66
    .db $39
    .db $00
    .db $06
    .db $66
    .db $66
    .db $88
    .db $68
    .db $66
    .db $66
    .db $66
    .db $88
    .db $88
    .db $88
    .db $00
    .db $60
    .db $63
    .db $30
    .db $63
    .db $00
    .db $06
    .db $26
    .db $68
    .db $28
    .db $60
    .db $66
    .db $66
    .db $86
    .db $00
    .db $00
    .db $66
    .db $66
    .db $00
    .db $00
    .db $ED
    .db $66
    .db $00
    .db $00
    .db $00
    .db $63
    .db $90
    .db $09
    .db $90
    .db $99
    .db $99
    .db $99
    .db $90
    .db $CC
    .db $90
    .db $11
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $10
    .db $00
    .db $11
    .db $10
    .db $11
    .db $00
    .db $11
    .db $00
    .db $10
    .db $00
    .db $10
    .db $10
    .db $10
    .db $00
    .db $11
    .db $10
    .db $10
    .db $10
    .db $11
    .db $00
    .db $10
    .db $10
    .db $10
    .db $10
    .db $10
    .db $00
    .db $01
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $00
    .db $01
    .db $00
    .db $11
    .db $00
    .db $11
    .db $01
    .db $11
    .db $00
    .db $01
    .db $01
    .db $01
    .db $01
    .db $01
    .db $00
    .db $11
    .db $01
    .db $01
    .db $01
    .db $11
    .db $00
    .db $FF
    .db $F0
    .db $FF
    .db $00
    .db $FF
    .db $00
    .db $F0
    .db $00
    .db $F0
    .db $F0
    .db $F0
    .db $00
    .db $EE
    .db $E0
    .db $E0
    .db $E0
    .db $EE
    .db $00
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $E0
    .db $00
    .db $DD
    .db $D0
    .db $D0
    .db $D0
    .db $DD
    .db $00
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $D0
    .db $00
    .db $0F
    .db $0F
    .db $0F
    .db $00
    .db $0F
    .db $00
    .db $FF
    .db $00
    .db $FF
    .db $0F
    .db $FF
    .db $00
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $0E
    .db $00
    .db $EE
    .db $0E
    .db $0E
    .db $0E
    .db $EE
    .db $00
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $0D
    .db $00
    .db $DD
    .db $0D
    .db $0D
    .db $0D
    .db $DD
    .db $00
    .db $1C
    .db $0D
    .db $7F
    .db $E7
    .db $70
    .db $00
    .db $0F
    .db $71
    .db $71
    .db $07
    .db $DC
    .db $77
    .db $7C
    .db $0D
    .db $71
    .db $C7
    .db $77
    .db $DE
    .db $07
    .db $71
    .db $17
    .db $17
    .db $DE
    .db $F7
    .db $71
    .db $17
    .db $71
    .db $7C
    .db $DE
    .db $F0
    .db $07
    .db $77
    .db $C7
    .db $71
    .db $17
    .db $70
    .db $70
    .db $7C
    .db $D7
    .db $77
    .db $77
    .db $70
    .db $01
    .db $CD
    .db $FF
    .db $D7
    .db $70
    .db $F0
    .db $00
    .db $00
    .db $00

;Bank 3
	.org $C000

JMP_BOOTUP_UNIT_OK: ; 0x005000, $C000
    JMP   BOOTUP_UNIT_OK
JMP_BOOTUP_RAM_FAILURE: ; 0x005003, $C003
    JMP   BOOTUP_RAM_FAILURE
JMP_BOOTUP_ROM_FAILURE: ; 0x005006, $C006
    JMP   BOOTUP_ROM_FAILURE
JMP_SRAM_CHECK_UNK: ; 0x005009, $C009
    JMP   SRAM_CHECK_UNK
JMP_BOOKKEEP_UPDATE_+A: ; 0x00500C, $C00C
    JMP   BOOKKEEP_UPDATE_+A
JMP_BOOKKEEP_UPDATE_+1: ; 0x00500F, $C00F
    JMP   BOOKKEEP_UPDATE_+1
JMP_BOOKKEEP_1_+1: ; 0x005012, $C012
    JMP   BOOKKEEP_1_+1
JMP_BOOKKEEP_3_+1: ; 0x005015, $C015
    JMP   BOOKKEEP_3_+1
JMP_BOOKKEEP_2_+1: ; 0x005018, $C018
    JMP   BOOKKEEP_2_+1
JMP_INIT_SRAM_C41D: ; 0x00501B, $C01B
    JMP   INIT_SRAM_$C41D_WITH_$5ECF
JMP MOVE_@X_TO_SRAM@Y: ; 0x00501E, $C01E
    JMP   MOVE_@X_TO_SRAM@Y
JMP_SETTINGS_MENU?: ; 0x005021, $C021
    JMP   SETTINGS_MENU?
JMP_CLEAR_ENTIRE+SETTINGS: ; 0x005024, $C024
    JMP   CLEAR_ENTIRE+SETTINGS
JMP_FAILED_W/_AUTO_NOT_PRESSED: ; 0x005027, $C027
    JMP   FAILED_WITH_AUTO_NOT_PRESSED
JMP_RUG_MISMATCH: ; 0x00502A, $C02A
    JMP   RUG_MISMATCH_JMP
JMP_RUG_LEAVE_ADMIN_MENU?: ; 0x00502D, $C02D
    JMP   RUG_MENU_LEAVE?
JUMP_RUG_MATCH_UNK: ; 0x005030, $C030
    JMP   RUG_MATCH_UNK
JMP_TO_HIGHSCORES_TO_RAM: ; 0x005033, $C033
    JMP   INIT_HIGHSCORES_TO_RAM
JMP_STORE_B@X_BANK0: ; 0x005036, $C036
    JMP   JMP_STORE_B@X_BANK0
JMP_LOAD_B@X_BANK0: ; 0x005039, $C039
    JMP   LOAD_B@X_BANK0
GOTO_C002_B2: ; 0x00503C, $C03C
    JSR   JMP_GOTO_PAST_JSR ; TEXT_RTN
    .db $C0 ; $C002, bank 2
    .db $02
    .db $02
    RTS
GOTO_C005_B5: ; 0x005043, $C043
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $05
    .db $02
    RTS
GOTO_C00E_B2: ; 0x00504A, $C04A
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $0E
    .db $02
    RTS
GOTO_C011_B2: ; 0x005051, $C051
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $11
    .db $02
    RTS
GOTO_C01A_B2: ; 0x005058, $C058
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $1A
    .db $02
    RTS
GOTO_C01D_B2: ; 0x00505F, $C05F
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $1D
    .db $02
    RTS
GOTO_C020_B2: ; 0x005066, $C066
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $20
    .db $02
    RTS
GOTO_C023_B2: ; 0x00506D, $C06D
    JSR   JMP_GOTO_PAST_JSR
    .db $C0
    .db $23
    .db $02
    RTS
    ADCB  $A0FF
BOOTUP_UNIT_OK: ; 0x005076, $C076
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$7A ; R3/7,G6/7,B2/3
    JSR   SET_COLOR_$C001
    LDU   #$C069 ; PTR to SENTENCE INITIAL TESTS INDICATE
    LDX   #$2870 ; POS XXYY
    JSR   GOTO_C002_B2 ; Put to screen.
    LDU   #$C06B ; PTR to SENTENCE UNIT OK
    LDX   #$4090 ; POS
    JSR   GOTO_C002_B2 ; Put to screen
    LDB   #$0F ; All LED's lighted?
    JSR   ROM_LED_BLINK_STARTUP?
    LDY   #$0BB8 ; Loops to read switches for admin menu.
    JMP   AUTO+ADV_CHECK ; RTS's back into main bootup code to JMP to game code.
BOOTUP_RAM_FAILURE: ; 0x00509C, $C09C
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$57 ; R2/7,G5/7,B3/3
    JSR   SET_COLOR_$C001
    LDU   #$C069 ; PTR to SENTENCE INITIAL TESTS INDICATE
    LDX   #$2870 ; POS
    JSR   GOTO_C002_B2
    LDU   #$C073 ; PTR to SENTENCE RAM FAILURE
    LDX   #$3890 ; POS
    JSR   GOTO_C002_B2
    BRA   BOOTUP_FAILURE_WAIT
BOOTUP_ROM_FAILURE: ; 0x0050B8, $C0B8
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$57 ; R2/7,G5/7,B3/3
    JSR   SET_COLOR_$C001
    LDU   #$C069 ; PTR, SENTENCE INITIAL TESTS INDICATE
    LDX   #$2860
    JSR   GOTO_C002_B2
    LDU   #$C071 ; PTR, SENTENCE ROM FAILURE
    LDX   #$3880 ; POS
    JSR   GOTO_C002_B2
    TFR   DP>A
    CMPA  #$9E ; Value if DP was 0.
    BEQ   BOOTUP_FAILURE_WAIT
    LDU   #$C073 ; PTR to SENTENCE RAM FAILURE
    LDX   #$38A0 ; POS
    JSR   GOTO_C002_B2 ; Put to screen
BOOTUP_FAILURE_WAIT: ; 0x0050E1, $C0E1
    LDY   #$0BB8 ; Timer?
LOOP_FAIL_ADV/AUTO_READ: ; 0x0050E5, $C0E5
    JSR   ADV+AUTO_CUMULATIVE ; Get switches.
    LDX   #$CC00 ; Get ROM PIA.
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$02 ; Test ADV switch.
    BEQ   ADV_NOT_PRESSED ; If ADV isn't pressed, loop to wait.
    LSRB ; AUTO switch to CC.c
    BLO   RTS ; If auto is pressed, leaves...
    BRA   FAILED_WITH_AUTO_NOT_PRESSED ; If not pressed, goes here.
ADV_NOT_PRESSED: ; 0x0050F7, $C0F7
    LEAY  -1,Y
    BNE   LOOP_FAIL_ADV/AUTO_READ
RTS: ; 0x0050FB, $C0FB
    RTS
SRAM_CHECK_UNK: ; 0x0050FC, $C0FC
    ANDCC #$EF ; Clear IRQ mask.
    LDX   #$C47F ; PTR to SRAM
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data.
    CMPB  #$5A ; See if set.
    BNE   GOTO_SETTINGS_MENU ; Go if mismatch.
    LDX   #$C400
    JSR   JMP_LOAD_B@X_BANK0 ; Saves bank?
    ANDB  #$0F
    BNE   C400_NOT_0 ; Some bits set.
    RTS ; RTS if bits set.
C400_NOT_0: ; 0x005113, $C113
    CLRB
    JSR   JMP_STORE_B@X_BANK0 ; Clear location.
    LDX   #$C47D
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data here
    CLRA ; Clear
    LEAX  -2,X ; Fix location.
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Clear location.
    CMPB  #$15 ; Previous value.
    BNE   PREV_NOT_0x15
CLEAR_ENTIRE+SETTINGS: ; 0x005127, $C127
    ANDCC #$7F ; Clear ENTIRE flag.
    BRA   FAILED_WITH_AUTO_NOT_PRESSED
PREV_NOT_0x15: ; 0x00512B, $C12B
    CMPB  #$25
    BNE   PREV_NOT_0x25
    JMP   INIT_SRAM_$C41D_WITH_$5ECF
PREV_NOT_0x25: ; 0x005132, $C132
    CMPB  #$35
    BNE   PREV_NOT_35
    JMP   L_005BBF
PREV_NOT_35: ; 0x005139, $C139
    CMPB  #$45
    BEQ   GOTO_SETTINGS_MENU
    RTS ; Leave otherwise.
GOTO_SETTINGS_MENU: ; 0x00513E, $C13E
    LEAS  2,S ; Clean stack because we will not RTS.
    JSR   INIT_SRAM
    JMP   SETTINGS_MENU? ; Settings menu?
FAILED_WITH_AUTO_NOT_PRESSED: ; 0x005146, $C146
    ORCC  #$10 ; Mask interrupts.
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF ; Do...
    JSR   JMP_ROM_CHECK_START ; Do...
    PSHS  U ; Save U
    LDU   DATA_W_$F86E
    LEAU  24,U ; Off $2886
    STU   $A043 ; Store to..
    PULS  U ; Restore U
    CMPU  $A043 ; Compare them.
    BEQ   STACKS_THE_SAME ; Taken if same.
    STU   $A05B ; Not same, do...
    LDB   #$08
    JSR   ROM_BOARD_LED_DISPLAY_B ; Show
    LDB   #$57 ; R=2/7,G=5/7,B=3/3
    JSR   SET_COLOR_$C001 ; Color
    LDU   #$C071 ; PTR
    LDX   #$3860 ; POS
    JSR   GOTO_C002_B2 ; DISP
    LDY   #$C035 ; PTR
    JSR   GOTO_C023_B2 ; DISP
    LDD   #$4266 ; IDK
    STD   $A04A ; Store
L_005180: ; 0x005180, $C180
    LDX   $A04A ; Load
    LEAX  10,X ; Add 10
    STX   $A04A ; Store
    LDU   #$C06D ; PTR?
    JSR   GOTO_C002_B2 ; Disp?
    LDU   DATA_W_$F86E ; Get
    STU   $A043 ; Put
    LDU   $A05B ; Load
    LDD   $A05B
    SUBD  $A043 ; Get difference.
    LSRB ; Get bottom bit.
    BLO   BOTTOM_BIT_SET ; Don't add if bottom set.
    LEAU  1,U
BOTTOM_BIT_SET: ; 0x00519C, $C19C
    INCB ; INC PTR bottom?
    STB   $A03A ; Store...
    JSR   A+=16_PER_EACH_B_0xF0>>8_VALUE ; Make pos?
    LDX   SENTENCE_CURR_SCR_LOC_XXYY
    JSR   GOTO_C00E_B2 ; Text IDK
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog+switches.
    JSR   JMP_CORRECT_CHECKSUM ; Idk why
    STU   $A05B ; Store U...?
    LDU   DATA_W_$F86E ; Get ptr...
    LEAU  24,U ; Ad 24
    CMPU  $A05B ; Compare to...
    BNE   L_005180 ; Not +24
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag...
    BNE   $49_NOT_SET ; If not set..
    LDB   $A03A ; If set, load val...
    JSR   ROM_BOARD_LED_DISPLAY_B ; Display on ROM board.
    LDY   #$C039 ; PTR?
    JSR   GOTO_C023_B2 ; Disp?
    BRA   L_0051EE ; Go always
STACKS_THE_SAME: ; 0x0051CF, $C1CF
    TFR   CC>B
    TSTB
    BPL   L_005212
    LDB   #$7A
    JSR   SET_COLOR_$C001
    LDU   #$C077
    LDX   #$3880
    JSR   GOTO_C002_B2
    LDY   #$C039
    JSR   GOTO_C023_B2
    LDB   #$08
    JSR   ROM_LED_BLINK_STARTUP?
L_0051EE: ; 0x0051EE, $C1EE
    JSR   L_005A39
$49_NOT_SET: ; 0x0051F1, $C1F1
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    CLRB
    JSR   ROM_BOARD_LED_DISPLAY_B
    JSR   SET_COLOR_RED_PALETTE_0x01
    LDU   #$C079
    LDX   #$4080
    JSR   GOTO_C002_B2
    LDY   #$C03D
    JSR   GOTO_C023_B2
    LDY   #$1388
    JSR   AUTO+ADV_CHECK
L_005212: ; 0x005212, $C212
    JSR   ADV+AUTO_CUMULATIVE
    TST   UNK_$49_SYS_MENU_FLAG?
    LBNE  Y_IS_#$000A
    TST   UNK_$47
    BNE   L_005212
    LDX   #$C000
    LDB   #$C0
L_005224: ; 0x005224, $C224
    JSR   JMP_STORE_B@X_BANK0
    LDA   #$B5
    MUL
    EXG   A-B
    LEAX  1,X
    CMPX  #$C010
    BNE   L_005224
    LDD   #$0000
    LDY   #$000A
    JMP   JMP_RUG_SETUP
RUG_MISMATCH_JMP: ; 0x00523D, $C23D
    TFR   Y>D
    EORB  -X
    EORA  -X
    STD   $A041
    STX   $A043
    JSR   CLEAR_COLOR_PALETTE
    JSR   JMP_CLEAR_ALL_SCREEN
    JSR   SETUP_52+49+48+36+59
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDB   #$04
    JSR   ROM_BOARD_LED_DISPLAY_B
    LDB   #$57
    JSR   SET_COLOR_$C001
    LDU   #$C073 ; PTR TO SENTENCE RAM FAILURE
    LDX   #$3870 ; Pos XXYY
    JSR   GOTO_C002_B2 ; To screen
    LDY   #$C041 ; Idk ptr to
    JSR   GOTO_C023_B2
    LDD   $A041
    TSTA
    BNE   L_005274
    TFR   B>A
L_005274: ; 0x005274, $C274
    CLRB
L_005275: ; 0x005275, $C275
    INCB
    LSRA
    BHS   L_005275
    STB   $A03A
    LDD   $A043
L_00527D: ; 0x00527D, $C27D
    SUBA  #$03
    BHS   L_00527D
    ADDA  #$04
    STA   $A03B
    LDU   #$C06F
    LDX   #$4290
    JSR   GOTO_C002_B2
    LDB   $A03B
    ASLB
    ASLB
    ASLB
    ASLB
    ADDB  $A03A
    CLRA
    LDX   SENTENCE_CURR_SCR_LOC_XXYY
    JSR   GOTO_C00E_B2
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   Y_IS_#$000A
    LDA   $A03B
    LDB   #$10
L_0052A7: ; 0x0052A7, $C2A7
    LSRB
    DECA
    BNE   L_0052A7
    JSR   ROM_BOARD_LED_DISPLAY_B
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   Y_IS_#$000A
    LDB   $A03A
    JSR   ROM_BOARD_LED_DISPLAY_B
    LDY   #$C045
    JSR   GOTO_C023_B2
    BRA   L_0052EF
RUG_MENU_LEAVE?: ; 0x0052C3, $C2C3
    JSR   CLEAR_COLOR_PALETTE
    JSR   JMP_CLEAR_ALL_SCREEN
    JSR   SETUP_52+49+48+36+59
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    CMPY  #$000A
    BEQ   Y_IS_#$000A
    LDB   #$7A ; R3/7,B6/7,G2/3
    JSR   SET_COLOR_$C001
    LDU   #$C07B
    LDX   #$2880
    JSR   GOTO_C002_B2
    LDY   #$C045
    JSR   GOTO_C023_B2
    LDB   #$04
    JSR   ROM_LED_BLINK_STARTUP?
L_0052EF: ; 0x0052EF, $C2EF
    JSR   L_005A39
Y_IS_#$000A: ; 0x0052F2, $C2F2
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    TFR   DP>A
    CMPA  #$A2
    BNE   L_005318
    LDB   #$02
    JSR   ROM_BOARD_LED_DISPLAY_B
    LDB   #$57
    JSR   SET_COLOR_$C001
    LDU   #$C081
    LDX   #$2880
    JSR   GOTO_C002_B2
    LDY   #$C049
    JSR   GOTO_C023_B2
    JMP   L_0053BB
L_005318: ; 0x005318, $C318
    ADDA  #$03
    CLRB
    STD   $A041
    LDU   $A041
    LDX   #$C400
L_005322: ; 0x005322, $C322
    JSR   JMP_LOAD_B@X_BANK0
    STB   U+
    LEAX  1,X
    CMPX  #$C500
    BNE   L_005322
    LDD   #$0010
    STB   $A03A
    CLRA
L_005334: ; 0x005334, $C334
    LDX   #$C400
    LDB   $A03A
L_005339: ; 0x005339, $C339
    JSR   JMP_STORE_B@X_BANK0
    LEAX  1,X
    INCB
    CMPB  $A03A
    BNE   L_005339
    LDX   #$C400
    INCA
L_005347: ; 0x005347, $C347
    JSR   JMP_LOAD_B@X_BANK0
    STB   $A03B
    LEAX  1,X
    JSR   JMP_LOAD_B@X_BANK0
    SUBB  $A03B
    DECB
    ANDB  #$0F
    BNE   L_005366
    INCA
    BNE   L_005347
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_005366
    DEC   $A03A
    BNE   L_005334
L_005366: ; 0x005366, $C366
    LDU   $A041
    LDX   #$C400
L_00536B: ; 0x00536B, $C36B
    LDB   U+
    JSR   JMP_STORE_B@X_BANK0
    LEAX  1,X
    CMPX  #$C500
    BNE   L_00536B
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_0053BE
    LDA   $A03A
    BEQ   L_0053A1
    LDB   #$02
    JSR   ROM_BOARD_LED_DISPLAY_B
    LDB   #$57
    JSR   SET_COLOR_$C001
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDU   #$C07D
    LDX   #$3080
    JSR   GOTO_C002_B2
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDY   #$C049
    JSR   GOTO_C023_B2
    BRA   L_0053BB
L_0053A1: ; 0x0053A1, $C3A1
    LDB   #$7A
    JSR   SET_COLOR_$C001
    LDU   #$C07F
    LDX   #$3880
    JSR   GOTO_C002_B2
    LDY   #$C049
    JSR   GOTO_C023_B2
    LDB   #$02
    JSR   ROM_LED_BLINK_STARTUP?
L_0053BB: ; 0x0053BB, $C3BB
    JSR   L_005A39
L_0053BE: ; 0x0053BE, $C3BE
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    LDB   #$01
    JSR   ROM_BOARD_LED_DISPLAY_B
    JSR   SET_COLOR_RED_PALETTE_0x01
    LDU   #$C083
    LDX   #$3880
    JSR   GOTO_C002_B2
    LDY   #$C04D
    JSR   GOTO_C023_B2
    LDY   #$1388
    JSR   AUTO+ADV_CHECK
    JSR   L_005B67
    LDY   #$07D0
L_0053E7: ; 0x0053E7, $C3E7
    LDU   #$C9D8
L_0053EA: ; 0x0053EA, $C3EA
    LDB   U+
    LDX   #$C000
L_0053EF: ; 0x0053EF, $C3EF
    JSR   JMP_STORE_B@X_BANK0
    LEAX  1,X
    CMPX  #$C010
    BNE   L_0053EF
    JSR   AUTO+ADV_CHECK
    CMPU  #$C9E0
    BNE   L_0053EA
    TST   UNK_$49_SYS_MENU_FLAG?
    BEQ   L_0053E7
RUG_MATCH_UNK: ; 0x005406, $C406
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    CLRB
    STB   $A041 ; Clear
    STB   $A042 ; Set
    JSR   ROM_BOARD_LED_DISPLAY_B
    JSR   SET_COLOR_RED_PALETTE_0x01 ; Red?
    LDU   #$C085 ; Str?
    LDX   #$4078 ; Screen loc?
    JSR   GOTO_C002_B2 ; Text?
    LDY   #$C055
    JSR   GOTO_C023_B2 ; Text?
    LDY   #$0001 ; Set
L_005428: ; 0x005428, $C428
    LDU   #$C9F0 ; Load
    CLRA ; Clear
LOOP_ERROR?: ; 0x00542C, $C42C
    LDX   #$CC00
    JSR   JMP_LOAD_B@X_BANK0 ; Get ROM PIA
    BITB  #$01 ; Test auto/manual
    BNE   AUTO/MANUAL PRESSED
    BITB  #$02 ; Test advance switch
    BNE   ADVANCED_PRESSED
    JSR   ADV+AUTO_CUMULATIVE
    BRA   LOOP_ERROR?
AUTO/MANUAL PRESSED: ; 0x00543F, $C43F
    JSR   AUTO+ADV_CHECK
L_005442: ; 0x005442, $C442
    INCA
    CMPA  U
    BNE   L_00544B
    LEAU  1,U
    BRA   L_005442
L_00544B: ; 0x00544B, $C44B
    STA   $A03A
    EORA  #$3F
ADVANCED_PRESSED: ; 0x00544F, $C44F
    LDB   #$13
    JSR   OUTPUT_SOUND?
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_005486
    LDB   $A03A
    JSR   OUTPUT_SOUND?
    LDY   #$03E8
    LDD   $A041
    LDX   #$5A8C
    JSR   GOTO_C011_B2
    LDB   $A03A
    JSR   A+=16_PER_EACH_B_0xF0>>8_VALUE
    CLRA
    STD   $A041
    LDX   #$5A8C
    JSR   GOTO_C00E_B2
    LDA   $A03A
    CMPA  #$1F
    BNE   LOOP_ERROR?
    TFR   CC>B
    TSTB
    LBPL  L_005585
    BRA   L_005428
L_005486: ; 0x005486, $C486
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    JSR   SET_COLOR_RED_PALETTE_0x01
    LDU   #$C087
    LDX   #$3820
    JSR   GOTO_C002_B2
    LDY   #$C059
    JSR   GOTO_C023_B2
    TFR   DP>A
    LDB   #$62
    STD   $A041
    ADDB  #$26
    TFR   D>X
    LDA   #$FF
L_0054A8: ; 0x0054A8, $C4A8
    STA   -X
    CMPX  $A041
    BNE   L_0054A8
    CLR   IRQS_COUNTER
    CLR   $A05E
    CLR   LIST_?B_CALLBACKS?
    CLR   $A060
    CLR   LIST_15B_OBJECTS_AVAILABLE
L_0054B8: ; 0x0054B8, $C4B8
    LDA   #$01
    STA   $A03C
    LDX   #$CC00
    LDU   $A041
    LEAU  -5,U
    CLRA
L_0054C4: ; 0x0054C4, $C4C4
    JSR   JMP_LOAD_B@X_BANK0
    CMPX  #$CC06
    BNE   L_0054CE
    ANDB  #$7F
L_0054CE: ; 0x0054CE, $C4CE
    CMPA  #$18
    BNE   L_0054D4
    ANDB  #$CF
L_0054D4: ; 0x0054D4, $C4D4
    STB   $A03A
    EORB  U+
    BNE   L_005512
    ADDA  #$08
L_0054DC: ; 0x0054DC, $C4DC
    LEAX  2,X
    CMPX  #$CC02
    BEQ   L_0054DC
    CMPX  #$CC08
    BNE   L_0054C4
    CMPA  #$28
    BEQ   L_005501
    LEAX  -2,X
    JSR   JMP_LOAD_B@X_BANK0
    TSTB
    BPL   L_005501
    LDB   #$34
    LEAX  1,X
    JSR   JMP_STORE_B@X_BANK0
    LEAX  -3,X
    INC   $A03C
    BRA   L_0054C4
L_005501: ; 0x005501, $C501
    LDB   #$3C
    LDX   #$CC07
    JSR   JMP_STORE_B@X_BANK0
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    TST   UNK_$49_SYS_MENU_FLAG?
    BEQ   L_0054B8
    BRA   L_005585
L_005512: ; 0x005512, $C512
    STB   $A03B
    LDB   #$01
L_005516: ; 0x005516, $C516
    BITB  $A03B
    BNE   L_00551E
    INCA
    ASLB
    BRA   L_005516
L_00551E: ; 0x00551E, $C51E
    LDX   $A041
    BITB  $A03A
    BNE   L_005538
    EORB  -U
    STB   U
L_005528: ; 0x005528, $C528
    CMPA  X+
    BNE   L_005528
    COM   -X
    BSR   L_00556C
    LDD   #$3808
    JSR   L_002FB9
    BRA   L_005501
L_005538: ; 0x005538, $C538
    EORB  -U
    STB   U
    LDB   #$08
    JSR   OUTPUT_SOUND?
L_005541: ; 0x005541, $C541
    TST   X+
    BPL   L_005541
    STA   -X
    PSHS  A
    BSR   L_00556C
    JSR   GOTO_C002_B2
    PULS  A
    CMPA  #$08
    BLO   L_005501
    LSRA
    CMPA  #$06
    BEQ   L_005501
    LDX   #$CC06
    JSR   JMP_LOAD_B@X_BANK0
    TSTB
    BPL   L_005501
    LDX   SENTENCE_CURR_SCR_LOC_XXYY
    CLRA
    LDB   $A03C
    JSR   GOTO_C00E_B2
    BRA   L_005501
L_00556C: ; 0x00556C, $C56C
    LDU   #$C08B
    CMPA  #$18
    BLO   L_005575
    SUBA  #$10
L_005575: ; 0x005575, $C575
    ASLA
    LEAU  A,U
    TFR   X>D
    SUBD  $A041
    LDA   #$0A
    MUL
    ADDD  #$3830
    TFR   D>X
    RTS
L_005585: ; 0x005585, $C585
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    JSR   SET_COLOR_RED_PALETTE_0x01
    LDU   #$C089
    LDX   #$2880
    JSR   GOTO_C002_B2
    LDY   #$C05D
    JSR   GOTO_C023_B2
    LDX   #$CC00
L_00559E: ; 0x00559E, $C59E
    LDU   #$C9F4
L_0055A1: ; 0x0055A1, $C5A1
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$01
    BEQ   L_0055BC
    LDY   #$1388
    JSR   AUTO+ADV_CHECK
    TST   UNK_$49_SYS_MENU_FLAG?
    LBNE  SETTINGS_MENU?
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$01
    BNE   L_0055C5
L_0055BC: ; 0x0055BC, $C5BC
    JSR   WAIT_ADV_NONPRESS_THEN_PRESS
    TST   UNK_$49_SYS_MENU_FLAG?
    LBNE  SETTINGS_MENU?
L_0055C5: ; 0x0055C5, $C5C5
    PSHS  U,Y,X
    JSR   [U]
    PULS  X,Y,U
    LEAU  2,U
    CMPU  #$C9FE
    BNE   L_0055A1
    LDY   #$1388
    JSR   AUTO+ADV_CHECK
    TFR   CC>B
    TSTB
    LBPL  FAILED_WITH_AUTO_NOT_PRESSED
    BRA   L_00559E
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    JSR   JMP_CLEAR_ALL_SCREEN
    JSR   CLEAR_COLOR_PALETTE
    LDX   #$C001
    LDB   #$FF
    JSR   JMP_STORE_B@X_BANK0
    LDX   #$C002
    LDB   #$C0
    JSR   JMP_STORE_B@X_BANK0
    LDX   #$C003
    LDB   #$38
    JSR   JMP_STORE_B@X_BANK0
    LDX   #$C004
    LDB   #$07
    JSR   JMP_STORE_B@X_BANK0
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDY   #$C6F7
    LDD   #$0101
L_005616: ; 0x005616, $C616
    LDX   Y
L_005618: ; 0x005618, $C618
    STD   X++
    CMPX  2,Y
    BNE   L_005618
    LEAY  4,Y
    CMPY  #$C71F
    BNE   L_005616
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDA   #$11
    LDY   #$C6D7
L_00562F: ; 0x00562F, $C62F
    LDX   Y
    STX   $A045
L_005633: ; 0x005633, $C633
    STA   X
    INC   $A045
    LDX   $A045
    CMPX  2,Y
    BNE   L_005633
    LEAY  4,Y
    CMPY  #$C6F7
    BNE   L_00562F
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDY   #$C71F
L_00564C: ; 0x00564C, $C64C
    LDX   Y
    STX   $A045
    LDA   4,Y
L_005652: ; 0x005652, $C652
    STA   X
    INC   $A045
    LDX   $A045
    CMPX  2,Y
    BNE   L_005652
    LEAY  5,Y
    CMPY  #$C75B
    BNE   L_00564C
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDY   #$C75B
L_00566B: ; 0x00566B, $C66B
    LDX   Y
    LDA   4,Y
L_00566F: ; 0x00566F, $C66F
    STA   X+
    CMPX  2,Y
    BNE   L_00566F
    LEAY  5,Y
    CMPY  #$C76F
    BNE   L_00566B
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDA   #$21
    STA   $467E
    LDA   #$20
    STA   $967E
    LDX   #$4E0A
L_00568D: ; 0x00568D, $C68D
    LDA   X
    ANDA  #$F0
    ORA   #$02
    STA   X+
    CMPX  #$4E6D
    BNE   L_00568D
    LDX   #$4E90
L_00569D: ; 0x00569D, $C69D
    LDA   X
    ANDA  #$F0
    ORA   #$02
    STA   X+
    CMPX  #$4EF3
    BNE   L_00569D
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDX   #$0E18
    STX   $A045
L_0056B2: ; 0x0056B2, $C6B2
    LDX   $A045
    LDA   X
    ANDA  #$F0
    ORA   #$01
    STA   X
    LDB   $A046
    ADDB  #$22
    BLO   L_0056C6
    STB   $A046
    BRA   L_0056B2
L_0056C6: ; 0x0056C6, $C6C6
    LDB   #$18
    STB   $A046
    LDB   $A045
    ADDB  #$10
    STB   $A045
    CMPB  #$9E
    BNE   L_0056B2
    JMP   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    .db $07
    .db $07
    .db $97
    .db $07
    .db $07
    .db $29
    .db $97
    .db $29
    .db $07
    .db $4B
    .db $97
    .db $4B
    .db $07
    .db $6D
    .db $97
    .db $6D
    .db $07
    .db $8F
    .db $97
    .db $8F
    .db $07
    .db $B1
    .db $97
    .db $B1
    .db $07
    .db $D3
    .db $97
    .db $D3
    .db $07
    .db $F5
    .db $97
    .db $F5
    .db $06
    .db $07
    .db $06
    .db $F5
    .db $16
    .db $07
    .db $16
    .db $F5
    .db $26
    .db $07
    .db $26
    .db $F5
    .db $36
    .db $07
    .db $36
    .db $F5
    .db $46
    .db $07
    .db $46
    .db $F5
    .db $56
    .db $07
    .db $56
    .db $F5
    .db $66
    .db $07
    .db $66
    .db $F5
    .db $76
    .db $07
    .db $76
    .db $F5
    .db $86
    .db $07
    .db $86
    .db $F5
    .db $96
    .db $07
    .db $96
    .db $F5
    .db $48
    .db $05
    .db $55
    .db $05
    .db $44
    .db $48
    .db $06
    .db $55
    .db $06
    .db $44
    .db $48
    .db $07
    .db $55
    .db $07
    .db $00
    .db $48
    .db $08
    .db $55
    .db $08
    .db $33
    .db $48
    .db $09
    .db $55
    .db $09
    .db $33
    .db $48
    .db $F3
    .db $55
    .db $F3
    .db $33
    .db $48
    .db $F4
    .db $55
    .db $F4
    .db $33
    .db $48
    .db $F5
    .db $55
    .db $F5
    .db $00
    .db $48
    .db $F6
    .db $55
    .db $F6
    .db $44
    .db $48
    .db $F7
    .db $55
    .db $F7
    .db $44
    .db $07
    .db $7E
    .db $46
    .db $7E
    .db $22
    .db $57
    .db $7E
    .db $96
    .db $7E
    .db $22
    .db $05
    .db $6F
    .db $05
    .db $8E
    .db $04
    .db $06
    .db $6F
    .db $06
    .db $8E
    .db $30
    .db $96
    .db $6F
    .db $96
    .db $8E
    .db $00
    .db $97
    .db $6F
    .db $97
    .db $8E
    .db $34
    .db $BD
    .db $FF
    .db $BC
    .db $C6
    .db $05
L_005774: ; 0x005774, $C774
    LDX   #$C000
    BSR   L_00577C
    LDX   #$C00C
L_00577C: ; 0x00577C, $C77C
    JMP   JMP_STORE_B@X_BANK0
    LDB   #$28
    BRA   L_005774
    LDB   #$80
    BRA   L_005774
    LDY   #$C9FE
    JSR   UPLOAD_PALETTE_@Y
    JMP   L_005B3B
SET_COLOR_RED_PALETTE_0x01: ; 0x005791, $C791
    LDB   #$A5 ; R=5/7,G=1/7,B=1/3
SET_COLOR_$C001: ; 0x005793, $C793
    LDX   #$C001
    JMP   JMP_STORE_B@X_BANK0
SETTINGS_MENU?: ; 0x005799, $C799
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    JSR   CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF
    BSR   SET_COLOR_RED_PALETTE_0x01
    LDU   #$C0D7 ; PTR to SENTENCE WILLIAMS DEFENDER
    LDX   #$2820 ; POS
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    JSR   GOTO_C002_B2
    LDY   #$C061
    JSR   GOTO_C023_B2
    LDY   #$05DC ; Timer?
    JSR   AUTO+ADV_CHECK
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_00581F
    CLR   $A03C
    LDA   #$01
    STA   $A03B
    LEAS  -32,S
    JSR   JMP_CLEAR_ALL_SCREEN
    LDU   #$C0D7 ; PTR to SENTENCE WILLIAMS DEFENDER
    LDX   #$2820 ; POS
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    JSR   GOTO_C002_B2
    CLR   $A03A
    LDY   #$C065
    JSR   GOTO_C020_B2
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    LDA   #$20
    TFR   A>B
    DECB
    LEAX  S
L_0057EA: ; 0x0057EA, $C7EA
    STA   X+
    DECB
    BNE   L_0057EA
    LDA   #$2F
    STA   X+
    LEAX  S
L_0057F5: ; 0x0057F5, $C7F5
    JSR   ADV+AUTO_CUMULATIVE
    LDX   #$CC00
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$02
    BEQ   L_005825
    BITB  #$01
    BNE   L_005812
    INC   $A03B
    DEC   $A03C
    BPL   L_005825
    LDB   #$1B
    STB   $A03C
    BRA   L_005825
L_005812: ; 0x005812, $C812
    INC   $A03C
    INC   $A03B
    LDA   #$1C
    CMPA  $A03C
    BNE   L_005825
    LEAS  32,S
L_00581F: ; 0x00581F, $C81F
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    JMP   JMP_TO_RUG_PASS_SRAM_CHECK
L_005825: ; 0x005825, $C825
    JSR   L_00597A
    TST   $A03B
    BEQ   L_0057F5
    LDB   $A03C
    CMPB  #$09
    BNE   L_005857
    LDX   #$C487
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B
    TSTB
    BEQ   L_005857
    CMPB  #$08
    BHI   L_005844
    JSR   L_005B99
    BRA   L_005857
L_005844: ; 0x005844, $C844
    LDX   #$C487
    PSHS  X
    LDB   #$01
    JSR   JMP_STORE_B_TO_SRAM[X]
    JSR   L_005B99
    CLRB
    PULS  X
    JSR   JMP_STORE_B_TO_SRAM[X]
L_005857: ; 0x005857, $C857
    BSR   L_005891
    LDA   $A03A
    CMPA  #$06
    BEQ   L_00586D
    TSTA
    BNE   L_005866
    LDA   #$64
    BRA   L_005868
L_005866: ; 0x005866, $C866
    LDA   #$06
L_005868: ; 0x005868, $C868
    STA   $A03A
    INCA
    LDB   #$FF
L_00586D: ; 0x00586D, $C86D
    JSR   ADV+AUTO_CUMULATIVE
    DECA
    BEQ   L_00588C
    LDX   #$CC00
    PSHS  B
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$0A
    BNE   L_005883
    ANDCC #$FE
    BRA   L_005885
L_005883: ; 0x005883, $C883
    ORCC  #$01
L_005885: ; 0x005885, $C885
    PULS  B
    RORB
    BNE   L_00586D
    CLR   $A03A
L_00588C: ; 0x00588C, $C88C
    CLR   $A03B
    JMP   L_0057F5
L_005891: ; 0x005891, $C891
    LEAY  2,S
    LDX   #$1080
    JSR   GOTO_C01A_B2
    JSR   L_00591F
    LDA   $A03C
    INCA
    JSR   L_005902
    JSR   L_005910
    STD   X
    LDB   $A03C
    ASLB
    ASLB
    LDX   #$CCD6
    ABX
    LDY   X
    LDU   2,X
    LEAX  14,S
L_0058B6: ; 0x0058B6, $C8B6
    LDA   Y+
    CMPA  #$2F
    BEQ   L_0058C0
    STA   X+
    BRA   L_0058B6
L_0058C0: ; 0x0058C0, $C8C0
    TFR   U>D
    LEAU  2,S
    LDX   #$C400
    ABX
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B
    PSHS  B,A
    LDB   $A03C
    INCB
    CMPB  #$07
    BHI   L_0058E7
L_0058D4: ; 0x0058D4, $C8D4
    PULS  A,B
    TFR   B>A
    JSR   L_005910
    STD   7,U
    JSR   JMP_GET_DATA_FROM_SRAM[X]
L_0058E0: ; 0x0058E0, $C8E0
    JSR   L_005910
    STD   9,U
    BRA   L_0058FA
L_0058E7: ; 0x0058E7, $C8E7
    CMPB  #$08
    BNE   L_0058F4
    LDD   #$3030
    STD   9,U
    LEAU  -2,U
    BRA   L_0058D4
L_0058F4: ; 0x0058F4, $C8F4
    PULS  A,B
    TFR   B>A
    BRA   L_0058E0
L_0058FA: ; 0x0058FA, $C8FA
    LDX   #$1080
    LEAY  2,S
    JMP   GOTO_C01D_B2
L_005902: ; 0x005902, $C902
    PSHS  B
    TFR   A>B
    LDA   #$99
L_005908: ; 0x005908, $C908
    ADDA  #$01
    DAA
    DECB
    BPL   L_005908
    PULS  B,PC
L_005910: ; 0x005910, $C910
    TFR   A>B
    ANDA  #$F0
    LSRA
    LSRA
    LSRA
    LSRA
    ADDA  #$30
    ANDB  #$0F
    ADDB  #$30
    RTS
L_00591F: ; 0x00591F, $C91F
    LDA   #$20
    TFR   A>B
    DECB
    LEAX  4,S
L_005926: ; 0x005926, $C926
    STA   X+
    DECB
    BNE   L_005926
    LDA   #$2F
    STA   X+
    LEAX  4,S
    RTS
L_005932: ; 0x005932, $C932
    CMPX  #$C481
    BNE   L_005951
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_AB
    LEAX  -4,X
    EXG   A-B
    ADDA  #$10
    DAA
    BHS   L_00594A
    EXG   A-B
    ADDA  #$01
L_005947: ; 0x005947, $C947
    DAA
    EXG   A-B
L_00594A: ; 0x00594A, $C94A
    EXG   A-B
    INC   $A03B
    JMP   JMP_STORE_D_TO_SRAM[X]
L_005951: ; 0x005951, $C951
    JSR   JMP_GET_DATA_FROM_SRAM[X]
    ADDA  #$01
L_005956: ; 0x005956, $C956
    DAA
    LEAX  -2,X
    INC   $A03B
    JMP   JMP_STORE_A_TO_SRAM_@X_BANKED
L_00595E: ; 0x00595E, $C95E
    CMPX  #$C481
    BNE   L_005973
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_AB
    LEAX  -4,X
    EXG   A-B
    ADDA  #$90
    DAA
    EXG   A-B
    ADCA  #$99
    BRA   L_005947
L_005973: ; 0x005973, $C973
    JSR   JMP_GET_DATA_FROM_SRAM[X]
    ADDA  #$99
    BRA   L_005956
L_00597A: ; 0x00597A, $C97A
    LDB   $A03C
    INCB
    CMPB  #$07
    BHI   L_005982
L_005981: ; 0x005981, $C981
    RTS
L_005982: ; 0x005982, $C982
    CMPB  #$09
    BLS   L_005997
    CMPB  #$10
    BHI   L_005997
    CMPB  #$0A
    BEQ   L_005997
    LDX   #$C487
    JSR   JMP_GET_DATA_FROM_SRAM[X]
    TSTA
    BNE   L_005981
L_005997: ; 0x005997, $C997
    DECB
    ASLB
    ASLB
    LDX   #$CCD6
    ABX
    LDB   3,X
    LDX   #$C400
    ABX
    PSHS  X
L_0059A6: ; 0x0059A6, $C9A6
    JSR   ADV+AUTO_CUMULATIVE
    LDX   #$CC00
    JSR   JMP_LOAD_B@X_BANK0
    BITB  #$02
    BEQ   L_0059B5
    PULS  X,PC
L_0059B5: ; 0x0059B5, $C9B5
    BITB  #$08
    BNE   L_0059BD
    CLR   $A03A
    BRA   L_0059A6
L_0059BD: ; 0x0059BD, $C9BD
    PULS  X
    CMPX  #$C47D
    BNE   L_0059D0
    PSHS  X,B
    LDX   #$C400
    LDB   #$01
    JSR   JMP_STORE_B@X_BANK0
    PULS  B,X
L_0059D0: ; 0x0059D0, $C9D0
    LSRB
    LBLO  L_005932
    JMP   L_00595E
    .db $02
    .db $03
    .db $04
    .db $10
    .db $18
    .db $20
    .db $40
    .db $80
    .db $00
    .db $FF
    .db $11
    .db $EE
    .db $22
    .db $DD
    .db $33
    .db $CC
    .db $44
    .db $BB
    .db $55
    .db $AA
    .db $66
    .db $99
    .db $77
    .db $88
    .db $13
    .db $1B
    .db $1C
    .db $00
    .db $C5
    .db $E3
    .db $C7
    .db $6F
    .db $C7
    .db $7F
    .db $C7
    .db $83
    .db $C7
    .db $87
    .db $05
    .db $05
    .db $28
    .db $28
    .db $80
    .db $80
    .db $00
    .db $00
    .db $AD
    .db $AD
    .db $2D
    .db $2D
    .db $A8
    .db $A8
    .db $85
    .db $85
WAIT_ADV_NONPRESS_THEN_PRESS: ; 0x005A0E, $CA0E
    LDX   #$CC00 ; PIA_ROM_A
    LDY   #$0064 ; Times...
LOOP_IF_PRESSED: ; 0x005A15, $CA15
    JSR   AUTO+ADV_CHECK ; Adv+auto check rtn.
    JSR   JMP_LOAD_B@X_BANK0 ; Get data too...
    BITB  #$02 ; Test adv pressed.
    BNE   LOOP_IF_PRESSED ; Loop if pressed.
LOOP_IF_NONPRESSED: ; 0x005A1F, $CA1F
    JSR   AUTO+ADV_CHECK ; Adv+auto check rtn.
    JSR   JMP_LOAD_B@X_BANK0 ; Get.
    BITB  #$02 ; Test adv pressed.
    BEQ   LOOP_IF_NONPRESSED
    RTS
CLR_SCR+ADV/AUTO+CLEAR_PALETTE+$49_STUFF: ; 0x005A2A, $CA2A
    JSR   JMP_CLEAR_ALL_SCREEN ; Clear screen.
    BSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV ; Watchdog+ADV+AUTO
    JSR   CLEAR_COLOR_PALETTE ; Clear palette
    DEC   UNK_$49_SYS_MENU_FLAG? ; Dec menu flag?
    BPL   RTS ; DEC counter. If it's positive, don't clear?
    CLR   UNK_$49_SYS_MENU_FLAG? ; Clear if neg...idfk.
RTS: ; 0x005A38, $CA38
    RTS ; Leaves.
L_005A39: ; 0x005A39, $CA39
    LDY   #$0001
L_005A3D: ; 0x005A3D, $CA3D
    BSR   AUTO+ADV_CHECK
    TST   UNK_$49_SYS_MENU_FLAG?
    BEQ   L_005A3D
    RTS
AUTO+ADV_CHECK: ; 0x005A44, $CA44
    PSHS  Y,A,CC
READ_SWITCHES: ; 0x005A46, $CA46
    BSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    TST   UNK_$49_SYS_MENU_FLAG? ; Test flag set in above, set if both ADV+AUTO pressed.
    BNE   LEAVE_RTN ; If triggered, leave.
    LDA   #$B2 ; Load delay.
READ_SWITCHES_DELAY.: ; 0x005A4E, $CA4E
    DECA
    BNE   READ_SWITCHES_DELAY.
    LEAY  -1,Y ; One less time.
    BNE   READ_SWITCHES ; If Y not 0, keep going.
LEAVE_RTN: ; 0x005A55, $CA55
    PULS  CC,A,Y,PC ; Leaves
ADV+AUTO_CUMULATIVE: ; 0x005A57, $CA57
    PSHS  Y,B ; Save loop, idk why B.
    LDB   UNK_$49_SYS_MENU_FLAG? ; Save?
    CLR   UNK_$49_SYS_MENU_FLAG? ; Clear
    LDY   #$000A ; Check for button X times.
    BSR   AUTO+ADV_CHECK ; Wait for switches?
    ADDB  UNK_$49_SYS_MENU_FLAG? ; Add trigger count.
    STB   UNK_$49_SYS_MENU_FLAG? ; Store back.
    PULS  B,Y,PC ; RTS
WATCHDOG/TRIGGER_$49_ON_AUTO+ADV: ; 0x005A69, $CA69
    PSHS  X,B,CC ; Save
    LDB   #$38 ; Setup watchdog.
    LDX   #$C3FC ; Ptr to write.
    JSR   JMP_STORE_B@X_BANK0 ; Set watchdog.
    LDX   #$CC00 ; Ptr to read.
    JSR   JMP_LOAD_B@X_BANK0 ; Get ROM PIA-A
    COMB ; Invert, active 0 now. CC.c=1 HERE.
    ANDB  #$03 ; Test auto/adv
    BEQ   BOTH_PRESSED ; Both pressed.
    ANDCC #$FE ; Clear CC.c
BOTH_PRESSED: ; 0x005A80, $CA80
    LDB   UNK_$47 ; Get val
    RORB ; rotate into B
    STB   UNK_$47 ; Store
    BNE   NOT_ZERO ; If not zero, skip clearing $48.
    STB   UNK_$48 ; Clear if also zero.
NOT_ZERO: ; 0x005A89, $CA89
    COMB ; Invert again
    BNE   RTS ; If was zero, RTS.
    LDB   UNK_$48 ; Get val
    BNE   RTS ; If not 0, RTS.
    COMB ; Invert, now 0xFF.
    STB   UNK_$48 ; Store.
    INC   UNK_$49_SYS_MENU_FLAG? ; INC this.
RTS: ; 0x005A95, $CA95
    PULS  CC,B,X,PC ; RTS
UPLOAD_PALETTE_@Y: ; 0x005A97, $CA97
    PSHS  Y,X,B ; Save
    LDX   #$C000 ; PTR
LOOP_UPLOAD_PALETTE: ; 0x005A9C, $CA9C
    LDB   Y+ ; Get daya from Y
    JSR   JMP_STORE_B@X_BANK0 ; Store.
    LEAX  1,X ; X++
    CMPX  #$C010 ; End?
    BNE   LOOP_UPLOAD_PALETTE
    PULS  B,X,Y,PC ; RTS
ROM_BOARD_LED_DISPLAY_B: ; 0x005AAA, $CAAA
    PSHS  X,B ; Save
    LSRB ; Bring 0 in.
    RORB
    RORB
    RORB ; Shift 4x total here.
    BPL   DONT_INC ; If B bit 2 clear originally, not sure why.
    INCB ; +=1 if origin B:2 was set.
DONT_INC: ; 0x005AB3, $CAB3
    RORB
    RORB ; Shift 6x total, this is to display the original bottom bits?
    LDX   #$CC00 ; Store to ROM_PIA_A_DATA
    JSR   JMP_STORE_B@X_BANK0 ; Store LED's.
    ASLB ; Shift in 3 zeros.
    ASLB
    ASLB
    ORB   #$3F ; Set bits to sound board. Silence?
    LDX   #$CC02 ; Store to ROM_PIA_B_DATA
    JSR   JMP_STORE_B@X_BANK0 ; Store LED's.
    PULS  B,X,PC
ROM_LED_BLINK_STARTUP?: ; 0x005AC8, $CAC8
    PSHS  Y,B,A ; Save
    LDA   #$02 ; Loop count?
    LDY   #$01F4 ; Unk val. Timer?
LOOP_LED_BLINK?: ; 0x005AD0, $CAD0
    JSR   ROM_BOARD_LED_DISPLAY_B ; Write B
    JSR   AUTO+ADV_CHECK
    CLRB ; Clear B
    JSR   ROM_BOARD_LED_DISPLAY_B ; Write cleared.
    JSR   AUTO+ADV_CHECK
    LDB   1,S ; Get original B.
    DECA ; Loop counter?
    BNE   LOOP_LED_BLINK? ; Loop blink.
    PULS  A,B,Y ; RTS
SETUP_52+49+48+36+59: ; 0x005AE4, $CAE4
    PSHS  B,A
    CLR   SENTENCE_PTR_WORD_ON
    CLR   UNK_$49_SYS_MENU_FLAG?
    LDA   #$01
    STA   UNK_$48
    LDA   #$03
    STA   CURRENT_BANK
    LDD   #$FFFF
    STD   TEXT_PTR_UNK
    PULS  A,B,PC
CLEAR_COLOR_PALETTE: ; 0x005AF9, $CAF9
    PSHS  X,B ; Save
    CLRB
    LDX   #$C000
CLEAR_PALETTE_LOOP: ; 0x005AFF, $CAFF
    JSR   JMP_STORE_B@X_BANK0 ; Write 0
    LEAX  1,X ; Next
    CMPX  #$C010 ; Bound
    BNE   CLEAR_PALETTE_LOOP ; Loop
    PULS  B,X,PC ; RTS
OUTPUT_SOUND?: ; 0x005B0B, $CB0B
    PSHS  X,B ; Save
    COMB ; Invert
    ANDB  #$3F ; And bits.
    LDX   #$CC02 ; PTR to PIA_ROM_B
    JSR   JMP_STORE_B@X_BANK0 ; Store to
    JSR   ADV+AUTO_CUMULATIVE ; Switch stuff?
    LDB   #$3F ; Load
    JSR   JMP_STORE_B@X_BANK0 ; Store to.
    JSR   ADV+AUTO_CUMULATIVE ; Switch stuff?
    PULS  B,X,PC ; RTS
A+=16_PER_EACH_B_0xF0>>8_VALUE: ; 0x005B23, $CB23
    PSHS  A ; Save A
    TFR   B>A ; B to A
    ANDA  #$0F ; Bottom bits...
    ADDA  #$00 ; Idk why. Sets flags right?
    DAA ; Adjust decimal.
    ANDB  #$F0 ; Top bits, >>4 for loop count.
LOOP_ADD+SUB: ; 0x005B2E, $CB2E
    BEQ   IS_ZERO ; If =0
    ADDA  #$16 ; Add dec to A.
    DAA ; Adjust
    SUBB  #$10 ; Minus 10 on B.
    BRA   LOOP_ADD+SUB ; Loop...
IS_ZERO: ; 0x005B37, $CB37
    TFR   A>B ; A to B.
    PULS  A,PC ; RTS.
L_005B3B: ; 0x005B3B, $CB3B
    PSHS  X,B,A
    LDD   #$0000
    LDX   #$0000
L_005B43: ; 0x005B43, $CB43
    STX   TEXT_PTR_TO_CODE_JSR
    LEAX  3840,X
L_005B49: ; 0x005B49, $CB49
    STD   --X
    CMPX  TEXT_PTR_TO_CODE_JSR
    BNE   L_005B49
    LEAX  2304,X
    TSTA
    BNE   L_005B59
    LDX   #$0F00
L_005B59: ; 0x005B59, $CB59
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_005B65
    ADDD  #$1111
    BHS   L_005B43
L_005B65: ; 0x005B65, $CB65
    PULS  A,B,X,PC
L_005B67: ; 0x005B67, $CB67
    JSR   CLEAR_COLOR_PALETTE
    LDX   #$0000
    LDY   #$C9E0
L_005B71: ; 0x005B71, $CB71
    STX   TEXT_PTR_TO_CODE_JSR
    LEAX  3840,X
    LDA   Y+
    TFR   A>B
L_005B7B: ; 0x005B7B, $CB7B
    STD   --X
    CMPX  TEXT_PTR_TO_CODE_JSR
    BNE   L_005B7B
    LEAX  2304,X
    TSTA
    BNE   L_005B8B
    LDX   #$0F00
L_005B8B: ; 0x005B8B, $CB8B
    JSR   WATCHDOG/TRIGGER_$49_ON_AUTO+ADV
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_005B98
    CMPY  #$C9F0
    BNE   L_005B71
L_005B98: ; 0x005B98, $CB98
    RTS
L_005B99: ; 0x005B99, $CB99
    LDX   #$C487
    JSR   JMP_STORE_B_TO_SRAM[X]
    ASLB
    PSHS  B
    ASLB
    ADDB  S+
    LDX   #$CF10
    ABX
    LDY   #$C489
    LDB   #$06
MOVE_@X_TO_SRAM@Y: ; 0x005BAF, $CBAF
    PSHS  A ; Save
LOOP_INIT_SRAM: ; 0x005BB1, $CBB1
    LDA   X+ ; Get data from ROM pointer.
    EXG   X-Y ; Put SRAM pointer to X
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Put to SRAM
    EXG   X-Y ; Move back to ROM pointer in X
    DECB ; Loop counter
    BNE   LOOP_INIT_SRAM
    PULS  A,PC
L_005BBF: ; 0x005BBF, $CBBF
    LDB   #$0E
    BRA   CLEAR_SRAM_TO_B
CLEAR_ALL_SRAM: ; 0x005BC3, $CBC3
    CLRB ; Loop counter.
CLEAR_SRAM_TO_B: ; 0x005BC4, $CBC4
    LDX   #$C400 ; Start of SRAM
    CLRA ; Clear
LOOP_WRITE_A_TO_SRAM_B_TIMES: ; 0x005BC8, $CBC8
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Write location
    DECB ; loop--
    BNE   LOOP_WRITE_A_TO_SRAM_B_TIMES ; Loop
    RTS ; Leave
INIT_SRAM: ; 0x005BCF, $CBCF
    PSHS  Y,X,B,A ; Save
    BSR   CLEAR_ALL_SRAM ; Clear SRAM
    LDX   #$CECF ; CMOS_RAM_INIT_DATA
    LDY   #$C41D ; Pointer into CMOS RAM
    LDB   #$47 ; Times to loop
    BSR   MOVE_@X_TO_SRAM@Y ; Move data
    PULS  A,B,X,Y,PC ; RTS
BOOKKEEP_UPDATE_+1: ; 0x005BE0, $CBE0
    PSHS  X,B,A ; Save
    LDA   #$01 ; Adding
    BRA   L_005BE8
BOOKKEEP_UPDATE_+A: ; 0x005BE6, $CBE6
    PSHS  X,B,A ; Save
L_005BE8: ; 0x005BE8, $CBE8
    ANDB  #$07 ; And B
    BEQ   RTS_BOOKKEEP ; Invalid if 0?
    ASLB ; <<1
    ASLB ; <<1, *4 total
    LDX   #$C3FD ; SRAM index.
    ABX ; Add B to.
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data in B
    PSHS  B ; Save
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B ; Get data in B
    PSHS  B ; Save
    ADDA  S+ ; Add A to second.
    DAA ; Adjust
    EXG   A-B ; Rotate because no DAB instruction.
    PULS  A ; Pull A
    ADCA  #$00 ; Add carry.
    DAA ; Adjust.
    LEAX  -4,X ; Original X ptr.
    JSR   JMP_STORE_D_TO_SRAM[X] ; Store D to.
RTS_BOOKKEEP: ; 0x005C0B, $CC0B
    PULS  A,B,X,PC
L_005C0D: ; 0x005C0D, $CC0D
    PSHS  X,A
    ADDA  VAL_FROM_SRAM_C495-C496
    DAA
    BHS   L_005C16
    LDA   #$99
L_005C16: ; 0x005C16, $CC16
    STA   VAL_FROM_SRAM_C495-C496
    LDX   #$C47D
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED
    PULS  A,X,PC
BOOKKEEP_3_+1: ; 0x005C20, $CC20
    PSHS  X,B,A
    LDB   #$03
    BRA   BOOKKEEP_B_+1+MORE_UNK
BOOKKEEP_2_+1: ; 0x005C26, $CC26
    PSHS  X,B,A
    LDB   #$02
    BRA   BOOKKEEP_B_+1+MORE_UNK
BOOKKEEP_1_+1: ; 0x005C2C, $CC2C
    PSHS  X,B,A
    LDB   #$01
BOOKKEEP_B_+1+MORE_UNK: ; 0x005C30, $CC30
    JSR   BOOKKEEP_UPDATE_+1
    ASLB
    LDX   #$C487
    ABX
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B
    BSR   L_005C9F
    LDA   $A039
    PSHS  B
    ADDA  S
    STA   $A039
    LDA   $A038
    ADDA  S+
    STA   $A038
    LDX   #$C493
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B
    BSR   L_005C9F
    PSHS  B
    CMPA  S+
    BHS   L_005C5B
    PULS  A,B,X,PC
L_005C5B: ; 0x005C5B, $CC5B
    LDX   #$C48F
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B
    BSR   L_005C9F
    BSR   L_005C89
    PSHS  A
    STB   $A038
    LDX   #$C491
    JSR   JMP_GET_DATA_FROM_SRAM@X_IN_B
    LDA   $A039
    BSR   L_005C9F
    BSR   L_005C89
    TSTA
    BEQ   L_005C7C
    CLR   $A038
    CLR   $A039
L_005C7C: ; 0x005C7C, $CC7C
    ADDA  S+
    DAA
    LDB   #$04
    JSR   BOOKKEEP_UPDATE_+A
    JSR   L_005C0D
    PULS  A,B,X,PC
L_005C89: ; 0x005C89, $CC89
    PSHS  B
    TSTB
    BNE   L_005C91
    CLRA
    PULS  B,PC
L_005C91: ; 0x005C91, $CC91
    EXG   A-B
    LDA   #$99
L_005C95: ; 0x005C95, $CC95
    ADDA  #$01
    DAA
    SUBB  S
    BHS   L_005C95
    ADDB  S+
    RTS
L_005C9F: ; 0x005C9F, $CC9F
    PSHS  A
    EXG   A-B
    CLRB
L_005CA4: ; 0x005CA4, $CCA4
    TSTA
    BNE   L_005CA9
    PULS  A,PC
L_005CA9: ; 0x005CA9, $CCA9
    ADDA  #$99
    DAA
    INCB
    BRA   L_005CA4
INIT_SRAM_$C41D_WITH_$5ECF: ; 0x005CAF, $CCAF
    PSHS  Y,X,B,A
    LDX   #$CECF ; Ptr to data.
    LDY   #$C41D ; Ptr to SRAM
    LDB   #$30 ; Loop count.
    JSR   MOVE_@X_TO_SRAM@Y ; Move data.
    BSR   INIT_HIGHSCORES_TO_RAM ; Wtf is this shit, lol.
    PULS  A,B,X,Y,PC ; RTS
INIT_HIGHSCORES_TO_RAM: ; 0x005CC1, $CCC1
    PSHS  Y,X,B,A ; Save
    LDY   #$CECF ; Ptr to high score table.
    LDX   #$B260 ; PTR to place data will be put.
    LDB   #$30 ; Length
LOOP_WRITE_TO_SRAM: ; 0x005CCC, $CCCC
    LDA   Y+
    JSR   JMP_STORE_A_TO_SRAM_@X_BANKED ; Used to write to normal RAM in 4-bit pieces.
    DECB ; Loop count.
    BNE   LOOP_WRITE_TO_SRAM ; Loop
    PULS  A,B,X,Y,PC ; RTS
    .db $CD
    .db $46
    .db $00
    .db $01
    .db $CD
    .db $51
    .db $00
    .db $05
    .db $CD
    .db $5E
    .db $00
    .db $09
    .db $CD
    .db $6A
    .db $00
    .db $0D
    .db $CD
    .db $75
    .db $00
    .db $11
    .db $CD
    .db $7F
    .db $00
    .db $15
    .db $CD
    .db $8A
    .db $00
    .db $19
    .db $CD
    .db $96
    .db $00
    .db $81
    .db $CD
    .db $A7
    .db $00
    .db $85
    .db $CD
    .db $B7
    .db $00
    .db $87
    .db $CD
    .db $C6
    .db $00
    .db $89
    .db $CD
    .db $D5
    .db $00
    .db $8B
    .db $CD
    .db $E6
    .db $00
    .db $8D
    .db $CD
    .db $F6
    .db $00
    .db $8F
    .db $CE
    .db $07
    .db $00
    .db $91
    .db $CE
    .db $17
    .db $00
    .db $93
    .db $CE
    .db $25
    .db $00
    .db $95
    .db $CE
    .db $2F
    .db $00
    .db $97
    .db $CE
    .db $3D
    .db $00
    .db $99
    .db $CE
    .db $4B
    .db $00
    .db $9B
    .db $CE
    .db $59
    .db $00
    .db $9D
    .db $CE
    .db $67
    .db $00
    .db $9F
    .db $CE
    .db $75
    .db $00
    .db $A1
    .db $CE
    .db $83
    .db $00
    .db $A3
    .db $CE
    .db $91
    .db $00
    .db $A5
    .db $CE
    .db $9F
    .db $00
    .db $A7
    .db $CE
    .db $AD
    .db $00
    .db $A9
    .db $CE
    .db $BC
    .db $00
    .db $7D
    .db $43 ; Coins Left
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $4C
    .db $45
    .db $46
    .db $54
    .db $2F
    .db $43 ; Coins center
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $43
    .db $45
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $2F
    .db $43 ; Coins right
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $52
    .db $49
    .db $47
    .db $48
    .db $54
    .db $2F
    .db $54 ; Total paid
    .db $4F
    .db $54
    .db $41
    .db $4C
    .db $20
    .db $50
    .db $41
    .db $49
    .db $44
    .db $2F
    .db $53 ; Ships won
    .db $48
    .db $49
    .db $50
    .db $53
    .db $20
    .db $57
    .db $4F
    .db $4E
    .db $2F
    .db $54 ; Total time
    .db $4F
    .db $54
    .db $41
    .db $4C
    .db $20
    .db $54
    .db $49
    .db $4D
    .db $45
    .db $2F
    .db $54 ; Total ships
    .db $4F
    .db $54
    .db $41
    .db $4C
    .db $20
    .db $53
    .db $48
    .db $49
    .db $50
    .db $53
    .db $2F
    .db $42 ; Bonus ship level
    .db $4F
    .db $4E
    .db $55
    .db $53
    .db $20
    .db $53
    .db $48
    .db $49
    .db $50
    .db $20
    .db $4C
    .db $45
    .db $56
    .db $45
    .db $4C
    .db $2F
    .db $4E ; Number of ships
    .db $55
    .db $4D
    .db $42
    .db $45
    .db $52
    .db $20
    .db $4F
    .db $46
    .db $20
    .db $53
    .db $48
    .db $49
    .db $50
    .db $53
    .db $2F
    .db $43 ; Coinage select
    .db $4F
    .db $49
    .db $4E
    .db $41
    .db $47
    .db $45
    .db $20
    .db $53
    .db $45
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $2F
    .db $4C ; Left coin mult
    .db $45
    .db $46
    .db $54
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $20
    .db $4D
    .db $55
    .db $4C
    .db $54
    .db $2F
    .db $43 ; Center coin mult
    .db $45
    .db $4E
    .db $54
    .db $45
    .db $52
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $20
    .db $4D
    .db $55
    .db $4C
    .db $54
    .db $2F
    .db $52 ; Right coin mult
    .db $49
    .db $47
    .db $48
    .db $54
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $20
    .db $4D
    .db $55
    .db $4C
    .db $54
    .db $2F
    .db $43 ; Coins for credit
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $46
    .db $4F
    .db $52
    .db $20
    .db $43
    .db $52
    .db $45
    .db $44
    .db $49
    .db $54
    .db $2F
    .db $43 ; Coins for bonus
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $20
    .db $46
    .db $4F
    .db $52
    .db $20
    .db $42
    .db $4F
    .db $4E
    .db $55
    .db $53
    .db $2F
    .db $4D ; Minimum coins
    .db $49
    .db $4E
    .db $49
    .db $4D
    .db $55
    .db $4D
    .db $20
    .db $43
    .db $4F
    .db $49
    .db $4E
    .db $53
    .db $2F
    .db $46 ; Free play
    .db $52
    .db $45
    .db $45
    .db $20
    .db $50
    .db $4C
    .db $41
    .db $59
    .db $2F
    .db $47 ; Game adjust 1
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $31
    .db $2F
    .db $47 ; Game adjust 2
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $32
    .db $2F
    .db $47 ; Game adjust 3
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $33
    .db $2F
    .db $47 ; Game adjust 4
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $34
    .db $2F
    .db $47 ; Game adjust 5
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $35
    .db $2F
    .db $47 ; Game adjust 6
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $36
    .db $2F
    .db $47 ; Game adjust 7
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $37
    .db $2F
    .db $47 ; Game adjust 8
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $38
    .db $2F
    .db $47 ; Game adjust 9
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $39
    .db $2F
    .db $47 ; Game adjust 10
    .db $41
    .db $4D
    .db $45
    .db $20
    .db $41
    .db $44
    .db $4A
    .db $55
    .db $53
    .db $54
    .db $20
    .db $31
    .db $30
    .db $2F
    .db $53 ; Special function
    .db $50
    .db $45
    .db $43
    .db $49
    .db $41
    .db $4C
    .db $20
    .db $46
    .db $55
    .db $4E
    .db $43
    .db $54
    .db $49
    .db $4F
    .db $4E
    .db $2F
    .db $FF
    .db $FF
CMOS_RAM_INIT_DATA: ; 0x005ECF, $CECF
    .db $02 ; High score table initial start. Score, BCD.
    .db $12
    .db $70
    .db $44 ; Initials, DRJ
    .db $52
    .db $4A
    .db $01 ; Score
    .db $83
    .db $15
    .db $53 ; SAM
    .db $41
    .db $4D
    .db $01 ; Score
    .db $59
    .db $20
    .db $4C ; LED
    .db $45
    .db $44
    .db $01 ; Score
    .db $42
    .db $85
    .db $50 ; PGD
    .db $47
    .db $44
    .db $01 ; Score
    .db $25
    .db $20
    .db $43 ; CRB
    .db $52
    .db $42
    .db $01 ; Score
    .db $10
    .db $35
    .db $4D ; MRS
    .db $52
    .db $53
    .db $00 ; Score
    .db $82
    .db $65
    .db $53 ; SSR
    .db $53
    .db $52
    .db $00 ; Score
    .db $60
    .db $10
    .db $54 ; TMH
    .db $4D
    .db $48
    .db $00
    .db $5A
    .db $01
    .db $00
    .db $03
    .db $03
    .db $01
    .db $04
    .db $01
    .db $01
    .db $00
    .db $00
    .db $00
    .db $05
    .db $15
    .db $01
    .db $05
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01 ; END SRAM INIT DATA
    .db $04
    .db $01
    .db $02
    .db $04
    .db $00
    .db $06
    .db $00
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $04
    .db $01
    .db $01
    .db $00
    .db $00
    .db $01
    .db $16
    .db $06
    .db $02
    .db $00
    .db $00
    .db $01
    .db $04
    .db $01
    .db $02
    .db $00
    .db $00
    .db $01
    .db $00
    .db $04
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $02
    .db $01
    .db $00
    .db $00
    .db $01
    .db $00
    .db $02
    .db $02
    .db $00
    .db $00
    .db $43 ; Copyright 1980 - Williams Electronics
    .db $4F
    .db $50
    .db $59
    .db $52
    .db $49
    .db $47
    .db $48
    .db $54
    .db $20
    .db $31
    .db $39
    .db $38
    .db $30
    .db $20
    .db $2D
    .db $20
    .db $57
    .db $49
    .db $4C
    .db $4C
    .db $49
    .db $41
    .db $4D
    .db $53
    .db $20
    .db $45
    .db $4C
    .db $45
    .db $43
    .db $54
    .db $52
    .db $4F
    .db $4E
    .db $49
    .db $43
    .db $53
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $4A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00

;Bank 7
	.org $C000

JMP_TO_DRAW_LAND?: ; 0x006000, $C000
    JMP   DRAW_LAND?
JMP_TO_LAND_MODIFY?: ; 0x006003, $C003
    JMP   IRQ_TASK_LAND_MODIFY?
JMP_TO_GENERATE_LAND_DATA?: ; 0x006006, $C006
    JMP   GENERATE_LAND_DATA?
JMP_TO_CLEAR_LAND_ONSCREEN?: ; 0x006009, $C009
    JMP   CLEAR_LAND_ONSCREEN
    ANDB  #$50
JMP_TO_UNK_RTN: ; 0x00600E, $C00E
    JMP   UNK_RTN
DIFFICULTY_DATA_START_LOC: ; 0x006011, $C011
    .db $C6
    .db $BA
DIFFICULTY_DATA_END_LOC: ; 0x006013, $C013
    .db $C7
    .db $72
DRAW_LAND?: ; 0x006015, $C015
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load
    ANDB  #$E0 ; B=1110.0000
    STD   A017_COMPARED_TO_A017 ; Store to
    ADDD  #$2610 ; Add val
    STD   A015_X_MATCH ; Store to.
    CLR   COUNTDOWN_A00F ; Clear
    LDX   #$C34F ; 1 byte before data area 1
    STX   BANK_7_DATA_PTR? ; Store to
    LDA   #$E0 ; Val
    STA   A011_TIED_WITH_A00D ; To here.
    JSR   AOOF_COUNTDOWN_STUFF ; Countdown.
    LDX   #$0010 ; Load val
LOOP_UNTIL_X=$A015: ; 0x006031, $C031
    CMPX  A015_X_MATCH ; If X _ $A015
    BEQ   X_MATCHES_A015 ; ==, goto.
    LDA   SHITED_DATA_A00D ; Get shifted from here.
    BPL   A00D_POSITIVE
L_006039: ; 0x006039, $C039
    DEC   A011_TIED_WITH_A00D ; Dec byte.
    BRA   SKIP_INC ; Skip inc.
A00D_POSITIVE: ; 0x00603D, $C03D
    INC   A011_TIED_WITH_A00D ; Inc
SKIP_INC: ; 0x00603F, $C03F
    JSR   AOOF_COUNTDOWN_STUFF ; A00F stuff.
    LEAX  32,X ; X+=32
    BRA   LOOP_UNTIL_X=$A015
X_MATCHES_A015: ; 0x006047, $C047
    LDD   BANK_7_DATA_PTR? ; Move
    STD   $A003
    LDA   COUNTDOWN_A00F ; Move
    STA   $A000
    LDA   SHITED_DATA_A00D ; Move
    STA   $A001
    LDA   A011_TIED_WITH_A00D ; Move
    STA   R_A002
    LDX   #$B700 ; Move
    STX   R_A005_IRQ_STACK_VAL_1
    LDX   #$BA90 ; Move
    STX   R_A007_IRQ_STACK_VAL_2
LOOP_A015/A017: ; 0x006061, $C061
    LDD   A015_X_MATCH ; Get val
    SUBD  #$0020 ; Sub
L_006066: ; 0x006066, $C066
    STD   A015_X_MATCH ; Store to
    CMPD  A017_COMPARED_TO_A017 ; Compare to.
    BMI   CLEAR_CURRENT_PLANET ; If D - A017 negative, taken.
L_00606D: ; 0x00606D, $C06D
    JSR   $A012_THING+MORE ; Run sub.
    BRA   LOOP_A015/A017
CLEAR_CURRENT_PLANET: ; 0x006072, $C072
    LDD   $A003 ; Seeds all planet gen vals.
    STD   A00B_PLANET_GEN_DATA_PTR
    LDA   $A000 ; Move
    STA   A010_PLANET_SHIFTS_COUNTDOWN
    LDA   $A001 ; Move
    STA   A00B_PLANET_GEN_SEED
    LDA   R_A002 ; Move
    STA   A012_PLANET_HEIGHT_CREATING
    LDY   #$BE20 ; This clears the planet data.
    LDX   #$0000 ; Clear/NULL
LOOP_CLEAR_PLANET: ; 0x006089, $C089
    STX   Y++ ; Clear
    CMPY  #$BF50 ; Until
    BNE   LOOP_CLEAR_PLANET
    RTS ; Leave
IRQ_TASK_LAND_MODIFY?: ; 0x006092, $C092
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load
    ANDB  #$E0 ; AND...
    SUBD  A015_X_MATCH ; Sub with...
    ASLB ; D << 3
    ROLA
    ASLB
    ROLA
    ASLB
    ROLA
    STA   $A000 ; Store A to.
    BEQ   UNK_RTN_MOD_ALOT ; If == 0, goto.
    BMI   LOOP_INC_A000 ; If A:7 set, goto.
LOOP_A000_TIMES: ; 0x0060A4, $C0A4
    LDD   A015_X_MATCH ; Load
    ADDD  #$0020 ; D+=32
    STD   A015_X_MATCH ; Store back
    JSR   L_0061CD ; Does IDK
    DEC   $A000 ; Dec A000 
    BNE   LOOP_A000_TIMES
    BRA   UNK_RTN_MOD_ALOT
LOOP_INC_A000: ; 0x0060B4, $C0B4
    LDD   A015_X_MATCH ; Load
    SUBD  #$0020 ; Sub
    STD   A015_X_MATCH ; Store back
    JSR   $A012_THING+MORE
    INC   $A000 ; ++
    BNE   LOOP_INC_A000
UNK_RTN_MOD_ALOT: ; 0x0060C2, $C0C2
    LDD   R_A020_SCREEN_POS_CHANGE? ; Load
    ANDB  #$E0 ; B bits..
    STD   A015_X_MATCH ; Store to
    LDX   #$0000 ; Pixel clear.
    LDY   #$BE20 ; Ptr to on-screen planet.
    STS   R_A013_STACK_SAVE_IRQ_RTN_B7 ; Save S
    LDS   R_A005_IRQ_STACK_VAL_1 ; S from here.
    BITB  #$20 ; Test bit
    BNE   SKIP_OTHER_STACK_LOAD ; If set, goto
    LDS   R_A007_IRQ_STACK_VAL_2 ; S from here otherwise.
SKIP_OTHER_STACK_LOAD: ; 0x0060DC, $C0DC
    LDA   #$98 ; Val
LOOP_WRITE_PLANET_DATA_EVERYWHERE: ; 0x0060DE, $C0DE
    STX   [Y] ; Clear screen planet pixel.
    PULS  B,U ; Pull height, addr.
    STD   Y ; Addr on screen to Y
    STU   [Y++] ; Store where Y points.
    DECA
    STX   [Y] ; 2x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 3x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 4x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 5x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 6x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 7x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    STX   [Y] ; 8x
    PULS  B,U
    STD   Y
    STU   [Y++]
    DECA
    BNE   LOOP_WRITE_PLANET_DATA_EVERYWHERE ; If A != 0, goto.
    LDS   R_A013_STACK_SAVE_IRQ_RTN_B7 ; Fix stack
    RTS ; RTS
$A012_THING+MORE: ; 0x00612C, $C12C
    JSR   A00E_STUFF_UNK
    BMI   INC_$12 ; If A is negative, taken.
    DEC   A012_PLANET_HEIGHT_CREATING ; --
    BRA   POST_$12_CHANGE ; Always goto.
INC_$12: ; 0x006135, $C135
    INC   A012_PLANET_HEIGHT_CREATING ; ++
POST_$12_CHANGE: ; 0x006137, $C137
    LDA   #$20 ; Load with val
    BITA  $A016 ; Test bit here.
    BNE   L_006185 ; Bit not set.
    LDX   R_A007_IRQ_STACK_VAL_2 ; Get X from
    JSR   A00F_STUFF
    BMI   L_006164 ; If A returned negative, goto.
    DEC   A011_TIED_WITH_A00D ; --
    LDA   A011_TIED_WITH_A00D ; Get val.
    STA   X ; Store to X
    STA   456,X ; Store to X+456?
    LDD   #$7007 ; Load D
    STD   1,X ; Store to X+1
    STD   457,X ; Store to X+457?
    LEAX  3,X ; X+=3
    CMPX  #$BC58 ; Compare to
    BNE   COMMIT_X_A007,RTS ; If !=, save as it
    LDX   #$BA90 ; Reset
COMMIT_X_A007,RTS: ; 0x006161, $C161
    STX   R_A007_IRQ_STACK_VAL_2 ; Store to.
    RTS
L_006164: ; 0x006164, $C164
    LDA   A011_TIED_WITH_A00D
    STA   X
    STA   456,X
    INCA
    STA   A011_TIED_WITH_A00D
    LDD   #$0770
    STD   1,X
    STD   457,X
    LEAX  3,X
    CMPX  #$BC58
    BNE   COMMIT_X_$A007,RTS
    LDX   #$BA90
COMMIT_X_$A007,RTS: ; 0x006182, $C182
    STX   R_A007_IRQ_STACK_VAL_2
    RTS
L_006185: ; 0x006185, $C185
    LDX   R_A005_IRQ_STACK_VAL_1
    JSR   A00F_STUFF
    BMI   L_0061AC
    DEC   A011_TIED_WITH_A00D
    LDA   A011_TIED_WITH_A00D
    STA   X
    STA   456,X
    LDD   #$7007
    STD   1,X
    STD   457,X
    LEAX  3,X
    CMPX  #$B8C8
    BNE   COMMIT_X_A005,RTS
    LDX   #$B700
COMMIT_X_A005,RTS: ; 0x0061A9, $C1A9
    STX   R_A005_IRQ_STACK_VAL_1
    RTS
L_0061AC: ; 0x0061AC, $C1AC
    LDA   A011_TIED_WITH_A00D
    STA   X
    STA   456,X
    INCA
    STA   A011_TIED_WITH_A00D
    LDD   #$0770
    STD   1,X
    STD   457,X
    LEAX  3,X
    CMPX  #$B8C8
    BNE   COMMIT_X_A005,RTS
    LDX   #$B700
COMMIT_X_A005,RTS: ; 0x0061CA, $C1CA
    STX   R_A005_IRQ_STACK_VAL_1
    RTS
L_0061CD: ; 0x0061CD, $C1CD
    LDA   SHITED_DATA_A00D
    BPL   L_0061D5
    DEC   A011_TIED_WITH_A00D
    BRA   L_0061D7
L_0061D5: ; 0x0061D5, $C1D5
    INC   A011_TIED_WITH_A00D
L_0061D7: ; 0x0061D7, $C1D7
    JSR   AOOF_COUNTDOWN_STUFF
    LDA   #$20
    BITA  $A016
    BEQ   L_006221
    LDX   R_A007_IRQ_STACK_VAL_2
    LEAX  -3,X
    CMPX  #$BA8D
    BNE   L_0061EC
    LDX   #$BC55
L_0061EC: ; 0x0061EC, $C1EC
    STX   R_A007_IRQ_STACK_VAL_2
    LDA   A00B_PLANET_GEN_SEED
    BPL   L_006209
    DEC   A012_PLANET_HEIGHT_CREATING
    LDA   A012_PLANET_HEIGHT_CREATING
    STA   X
    STA   456,X
    LDD   #$0770
    STD   1,X
    STD   457,X
    JSR   SHIFT_PLANET_MOVEMENT
    RTS
L_006209: ; 0x006209, $C209
    LDA   A012_PLANET_HEIGHT_CREATING
    STA   X
    STA   456,X
    INCA
    STA   A012_PLANET_HEIGHT_CREATING
    LDD   #$7007
    STD   1,X
    STD   457,X
    JSR   SHIFT_PLANET_MOVEMENT
    RTS
L_006221: ; 0x006221, $C221
    LDX   R_A005_IRQ_STACK_VAL_1
    LEAX  -3,X
    CMPX  #$B6FD
    BNE   L_00622D
L_00622A: ; 0x00622A, $C22A
    LDX   #$B8C5
L_00622D: ; 0x00622D, $C22D
    STX   R_A005_IRQ_STACK_VAL_1
    LDA   A00B_PLANET_GEN_SEED
    BPL   L_00624A
    DEC   A012_PLANET_HEIGHT_CREATING
    LDA   A012_PLANET_HEIGHT_CREATING
    STA   X
    STA   456,X
    LDD   #$0770
    STD   1,X
    STD   457,X
    JSR   SHIFT_PLANET_MOVEMENT
    RTS
L_00624A: ; 0x00624A, $C24A
    LDA   A012_PLANET_HEIGHT_CREATING
    STA   X
    STA   456,X
    INCA
    STA   A012_PLANET_HEIGHT_CREATING
    LDD   #$7007
    STD   1,X
    STD   457,X
    JSR   SHIFT_PLANET_MOVEMENT
    RTS
GENERATE_LAND_DATA?: ; 0x006262, $C262
    LDX   #$C350 ; Data ptr
    STX   A00B_PLANET_GEN_DATA_PTR ; Store to
    LDA   X ; Load from, base height for planet.
SEED_GEN_FROM_A_MANUAL: ; 0x006269, $C269
    STA   A00B_PLANET_GEN_SEED ; Store to
    LDA   #$07 ; Load
    STA   A010_PLANET_SHIFTS_COUNTDOWN ; Store
    LDA   #$E0 ; Load
    STA   A012_PLANET_HEIGHT_CREATING ; Store
    LDX   #$B300 ; Ptr to buffer.
LOOP_FILL_B300-B6FF: ; 0x006276, $C276
    LDA   A012_PLANET_HEIGHT_CREATING ; Val from
    STA   X+ ; Commit planet data.
    LDA   A00B_PLANET_GEN_SEED ; Load val
    BPL   INC_HEIGHT_1 ; If positive, inc.
    DEC   A012_PLANET_HEIGHT_CREATING ; Dec if negative.
    BRA   SUBRTN ; Forward.
INC_HEIGHT_1: ; 0x006282, $C282
    INC   A012_PLANET_HEIGHT_CREATING
SUBRTN: ; 0x006284, $C284
    JSR   SHIFT_PLANET_MOVEMENT
    LDA   A00B_PLANET_GEN_SEED ; Load to test high bit.
    BPL   INC_HEIGHT_2
    DEC   A012_PLANET_HEIGHT_CREATING
    BRA   SHIFT_NEXT
INC_HEIGHT_2: ; 0x00628F, $C28F
    INC   A012_PLANET_HEIGHT_CREATING
SHIFT_NEXT: ; 0x006291, $C291
    JSR   SHIFT_PLANET_MOVEMENT
    CMPX  #$B700 ; End X
BNE_LOOP_FILL: ; 0x006297, $C297
    BNE   LOOP_FILL_B300-B6FF
    RTS
CLEAR_LAND_ONSCREEN: ; 0x00629A, $C29A
    LDX   #$0000
    LDY   #$BE20 ; Only assuming this is the planet clear because is 304 entries.
LOOP_CLEAR: ; 0x0062A1, $C2A1
    STX   [Y++]
    CMPY  #$BF50
    BNE   LOOP_CLEAR
    RTS
AOOF_COUNTDOWN_STUFF: ; 0x0062AA, $C2AA
    LDA   COUNTDOWN_A00F ; Load
    BEQ   A00F_IS_ZERO ; If 0, goto.
    DEC   COUNTDOWN_A00F ; Sub 1.
    LDA   SHITED_DATA_A00D ; Load D
    ASLA ; Shift
    ADCA  #$00 ; Put bit back too.
    STA   SHITED_DATA_A00D ; Store to.
    RTS
A00F_IS_ZERO: ; 0x0062B8, $C2B8
    LDU   BANK_7_DATA_PTR?
    LEAU  1,U
    CMPU  #$C450
    BNE   L_0062C5
    LDU   #$C350
L_0062C5: ; 0x0062C5, $C2C5
    STU   BANK_7_DATA_PTR?
    LDA   #$07
    STA   COUNTDOWN_A00F
    LDA   U
    STA   SHITED_DATA_A00D
    RTS
SHIFT_PLANET_MOVEMENT: ; 0x0062D0, $C2D0
    LDA   A010_PLANET_SHIFTS_COUNTDOWN ; Load val from
    BEQ   RESEED_TERRAIN_GEN_DATA ; If 0, do this.
    DEC   A010_PLANET_SHIFTS_COUNTDOWN ; Dec available.
    LDA   A00B_PLANET_GEN_SEED ; Load
    ASLA ; Shift
    ADCA  #$00 ; If shifted off one, put back...
    STA   A00B_PLANET_GEN_SEED ; Store back.
    RTS
RESEED_TERRAIN_GEN_DATA: ; 0x0062DE, $C2DE
    LDU   A00B_PLANET_GEN_DATA_PTR ; Load ptr
    LEAU  1,U ; Ptr++
    CMPU  #$C450 ; See if at end.
    BNE   USE_PTR_ASIS ; If not, goto.
    LDU   #$C350 ; Reset
USE_PTR_ASIS: ; 0x0062EB, $C2EB
    STU   A00B_PLANET_GEN_DATA_PTR ; Store back.
    LDA   #$07 ; Load
    STA   A010_PLANET_SHIFTS_COUNTDOWN ; Store
    LDA   U ; Load from ptr
    STA   A00B_PLANET_GEN_SEED ; Reseed
    RTS
A00F_STUFF: ; 0x0062F6, $C2F6
    LDA   COUNTDOWN_A00F ; Load val
    CMPA  #$07 ; If _ 7
    BEQ   TIMER_A00F_REACHED ; ==, goto
    INC   COUNTDOWN_A00F ; ++
    LDA   SHITED_DATA_A00D ; Load val
    LSRA ; Shift off bit.
    BHS   SKIP_ADD_80 ; If shifted off 1, don't add 80.
    ADDA  #$80 ; +=80
SKIP_ADD_80: ; 0x006305, $C305
    STA   SHITED_DATA_A00D ; Store to.
    RTS
TIMER_A00F_REACHED: ; 0x006308, $C308
    LDU   BANK_7_DATA_PTR? ; Load U from
    CMPU  #$C350 ; If U _ val
    BNE   USE_U_ASIS ; !=, goto.
    LDU   #$C450 ; Reset
USE_U_ASIS: ; 0x006313, $C313
    LEAU  -1,U ; U--
    STU   BANK_7_DATA_PTR? ; Store to.
    CLR   COUNTDOWN_A00F ; Clear
    LDA   U ; Load from U
    LSRA ; Shift
    BHS   STORE_A00D ; If shifted off 0, skip add.
    ADDA  #$80 ; +=80
STORE_A00D: ; 0x006320, $C320
    STA   SHITED_DATA_A00D ; Store to.
    RTS ; RTS
A00E_STUFF_UNK: ; 0x006323, $C323
    LDA   A010_PLANET_SHIFTS_COUNTDOWN ; Get val
    CMPA  #$07 ; If A _ 7
    BEQ   U_FROM_A00B,LOW_BOUND_C450 ; ==, goto
    INC   A010_PLANET_SHIFTS_COUNTDOWN ; Inc count
    LDA   A00B_PLANET_GEN_SEED ; Load val
    LSRA ; Shift off bit
    BHS   DONT_ADD_80 ; If shifted 0, goto.
    ADDA  #$80 ; Add #$80
DONT_ADD_80: ; 0x006332, $C332
    STA   A00B_PLANET_GEN_SEED ; Store back
    RTS ; RTS
U_FROM_A00B,LOW_BOUND_C450: ; 0x006335, $C335
    LDU   A00B_PLANET_GEN_DATA_PTR ; Get U from
    CMPU  #$C350 ; If U _ C350
L_00633B: ; 0x00633B, $C33B
    BNE   SKIP_LOADING_U ; !=, goto
    LDU   #$C450 ; Load U
SKIP_LOADING_U: ; 0x006340, $C340
    LEAU  -1,U ; U-=1
    STU   A00B_PLANET_GEN_DATA_PTR ; Store new U
    CLR   A010_PLANET_SHIFTS_COUNTDOWN ; Clear
    LDA   U ; Get data at U
    LSRA ; get bit off.
    BHS   COMMIT_A_RTS ; If shifted 0, don't add 80
    ADDA  #$80 ; +=#$80
COMMIT_A_RTS: ; 0x00634D, $C34D
    STA   A00B_PLANET_GEN_SEED ; Store here.
    RTS ; RTS
PLANET_HEIGHT_DATA: ; 0x006350, $C350
    .db $2A
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AB
    .db $A1
    .db $D5
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $AA
    .db $BF
    .db $FF
    .db $FF
    .db $FF
    .db $C0
    .db $00
    .db $00
    .db $00
    .db $55
    .db $55
    .db $57
    .db $FF
    .db $C0
    .db $01
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $5F
    .db $E0
    .db $15
    .db $55
    .db $55
    .db $57
    .db $FF
    .db $F0
    .db $00
    .db $15
    .db $55
    .db $5F
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $00
    .db $00
    .db $00
    .db $00
    .db $05
    .db $55
    .db $7F
    .db $FF
    .db $E0
    .db $00
    .db $05
    .db $55
    .db $55
    .db $55
    .db $55
    .db $FC
    .db $05
    .db $55
    .db $55
    .db $50
    .db $01
    .db $FF
    .db $FF
    .db $FF
    .db $C0
    .db $00
    .db $0A
    .db $AA
    .db $AA
    .db $AA
    .db $FF
    .db $00
    .db $00
    .db $FF
    .db $FF
    .db $FF
    .db $FF
    .db $F0
    .db $00
    .db $00
    .db $1F
    .db $E0
    .db $00
    .db $55
    .db $55
    .db $55
    .db $40
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $B5
    .db $57
    .db $AA
    .db $AA
    .db $AA
    .db $F5
    .db $7F
    .db $D5
    .db $55
    .db $55
    .db $57
    .db $FF
    .db $80
    .db $07
    .db $E0
    .db $7F
    .db $F1
    .db $55
    .db $7F
    .db $FF
    .db $FF
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0F
    .db $EF
    .db $76
    .db $91
    .db $11
    .db $11
    .db $5E
    .db $DB
    .db $E9
    .db $84
    .db $77
    .db $EC
    .db $C4
    .db $87
    .db $47
    .db $98
    .db $08
    .db $98
    .db $3F
    .db $C3
    .db $CB
    .db $DB
    .db $9F
    .db $C7
    .db $5F
    .db $2F
    .db $C7
    .db $7D
    .db $EF
    .db $BF
    .db $FA
    .db $4C
    .db $57
    .db $2B
    .db $61
    .db $EF
    .db $EF
    .db $FB
    .db $F7
    .db $E8
    .db $00
    .db $20
    .db $40
    .db $00
    .db $14
    .db $04
    .db $04
    .db $3C
    .db $06
    .db $00
    .db $1D
    .db $07
    .db $3C
    .db $E1
    .db $A5
    .db $55
    .db $55
    .db $45
    .db $2A
    .db $AA
    .db $AA
    .db $AA
    .db $A8
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $55
    .db $56
    .db $AA
    .db $AA
    .db $FE
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $EA
    .db $AA
    .db $AA
    .db $A8
    .db $02
    .db $AA
    .db $AA
    .db $AA
    .db $AA
    .db $BF
    .db $BE
    .db $3E
    .db $63
    .db $FF
    .db $E0
    .db $D8
    .db $1C
    .db $18
    .db $2A
    .db $AB
    .db $1E
    .db $77
    .db $7A
    .db $AF
    .db $A8
    .db $40
    .db $70
    .db $7D
    .db $40
    .db $0B
    .db $FB
    .db $FA
    .db $FF
    .db $C1
    .db $53
    .db $54
    .db $75
    .db $70
    .db $03
    .db $00
    .db $00 ; End of data.
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $24
    .db $07
    .db $70
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $24
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $21
    .db $07
    .db $70
    .db $22
    .db $70
    .db $07
    .db $24
    .db $77
    .db $00
    .db $24
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $25
    .db $77
    .db $00
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $07
    .db $70
    .db $23
    .db $07
    .db $70
    .db $22
    .db $07
    .db $70
    .db $21
    .db $77
    .db $00
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
    .db $25
    .db $70
    .db $07
    .db $25
    .db $07
    .db $70
    .db $25
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $20
    .db $07
    .db $70
    .db $1E
    .db $07
    .db $70
    .db $1C
    .db $07
    .db $70
    .db $1D
    .db $70
    .db $07
    .db $1F
    .db $70
    .db $07
    .db $21
    .db $70
    .db $07
    .db $22
    .db $70
    .db $07
    .db $24
    .db $70
    .db $07
    .db $26
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $26
    .db $77
    .db $00
    .db $25
    .db $77
    .db $00
    .db $25
    .db $70
    .db $07
    .db $26
    .db $77
    .db $00
    .db $24
    .db $07
    .db $70
    .db $23
    .db $77
    .db $00
    .db $24
    .db $77
    .db $00
    .db $22
    .db $07
    .db $70
    .db $23
    .db $70
    .db $07
    .db $22
    .db $07
    .db $70
    .db $21
    .db $70
    .db $07
    .db $23
    .db $70
    .db $07
UNK_RTN: ; 0x0065D0, $C5D0
    PULS  A,B
    STD   9,U
    STX   $A000
    LDD   #$0808
    STD   $A004
    LDD   #$1732
    STD   R_A006_SCORE_POS_CHAR
    LDY   #$B300
L_0065E4: ; 0x0065E4, $C5E4
    LDA   $A000
    CLRB
    STD   2,Y
    LDA   $A001
    STD   4,Y
    LDA   R_A005_IRQ_STACK_VAL_1
    LSRA
    EORA  R_A005_IRQ_STACK_VAL_1
    LSRA
    LSRA
    ROR   $A004
    ROR   R_A005_IRQ_STACK_VAL_1
    LDA   $A004
    ANDA  #$01
    SUBA  #$01
    LDB   R_A005_IRQ_STACK_VAL_1
    STD   6,Y
    BPL   L_006606
    COMA
    COMB
L_006606: ; 0x006606, $C606
    PSHS  B,A
    LDA   R_A007_IRQ_STACK_VAL_2
    LSRA
    EORA  R_A007_IRQ_STACK_VAL_2
    LSRA
    LSRA
    ROR   R_A006_SCORE_POS_CHAR
    ROR   R_A007_IRQ_STACK_VAL_2
    LDA   R_A006_SCORE_POS_CHAR
    ANDA  #$03
    SUBA  #$02
    LDB   R_A007_IRQ_STACK_VAL_2
    STD   8,Y
    BPL   L_006621
    COMA
    COMB
L_006621: ; 0x006621, $C621
    LSRA
    RORB
    ADDD  S++
    CMPD  #$016A
    BHS   L_0065E4
    LDX   #$0000
    STX   Y
    LEAY  10,Y
    CMPY  #$B800
    BNE   L_0065E4
    LDX   #$C6AB
    STX   R_A002
    LDA   #$38
    STA   $A001
L_006641: ; 0x006641, $C641
    LDA   #$01
    LDX   #$C649
    JMP   JMP_TO_R_A063_OBJ_SETUP_BANKED_HANDLER?
    LDX   #$0000
    LDY   #$B300
    LDA   [R_A002]
    STA   COLOR_PALETTE_RAM_COPY+11
    BEQ   L_0066A8
L_006658: ; 0x006658, $C658
    LDU   Y
    STX   U
    STX   256,U
    LDD   8,Y
    ADDD  4,Y
    CMPA  #$2A
    BLO   L_006690
    STD   4,Y
    STA   1,Y
    LDD   6,Y
    ADDD  2,Y
    CMPA  #$98
    BHI   L_006690
    STD   2,Y
    STA   Y
    TSTB
    BMI   L_006682
    LDD   #$BBBB
    STD   [Y]
    BRA   L_006690
L_006682: ; 0x006682, $C682
    LDU   Y
    LDD   #$0B0B
    STD   U
    LDD   #$B0B0
    STD   256,U
L_006690: ; 0x006690, $C690
    LEAY  10,Y
    CMPY  #$B800
    BNE   L_006658
    DEC   $A001
    BNE   L_006641
    LDU   R_A002
    LEAU  1,U
    STU   R_A002
    LDA   #$04
    STA   $A001
    BRA   L_006641
L_0066A8: ; 0x0066A8, $C6A8
    JMP   [9,U]
    .db $FF
    .db $7F
    .db $3F
    .db $37
    .db $2F
    .db $27
    .db $1F
    .db $17
    .db $07
    .db $06
    .db $05
    .db $04
    .db $03
    .db $02
    .db $00
    .db $14
    .db $00
    .db $00
    .db $00
    .db $0F
    .db $14
    .db $14
    .db $14
    .db $03
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $04
    .db $05
    .db $06
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $03
    .db $04
    .db $0A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $0A
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $1E
    .db $00
    .db $00
    .db $00
    .db $1E
    .db $19
    .db $14
    .db $10
    .db $05
    .db $00
    .db $00
    .db $00
    .db $05
    .db $05
    .db $05
    .db $05
    .db $60
    .db $00
    .db $03
    .db $02
    .db $16
    .db $1E
    .db $26
    .db $2E
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $FF
    .db $00
    .db $10
    .db $00
    .db $70
    .db $B0
    .db $00
    .db $00
    .db $80
    .db $10
    .db $FC
    .db $FE
    .db $4A
    .db $3A
    .db $2A
    .db $2A
    .db $30
    .db $00
    .db $00
    .db $00
    .db $20
    .db $28
    .db $2C
    .db $30
    .db $02
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $02
    .db $02
    .db $01
    .db $00
    .db $00
    .db $00
    .db $00
    .db $00
    .db $01
    .db $01
    .db $FF
    .db $00
    .db $08
    .db $06
    .db $62
    .db $E0
    .db $02
    .db $12
    .db $60
    .db $00
    .db $08
    .db $04
    .db $0C
    .db $1C
    .db $24
    .db $28
    .db $FF
    .db $08
    .db $FE
    .db $FE
    .db $2A
    .db $22
    .db $1E
    .db $1C
    .db $60
    .db $00
    .db $08
    .db $02
    .db $16
    .db $1E
    .db $20
    .db $22
    .db $28
    .db $0A
    .db $FE
    .db $FF
    .db $19
    .db $19
    .db $19
    .db $19
    .db $3F
    .db $00
    .db $00
    .db $00
    .db $1F
    .db $1F
    .db $1F
    .db $3F
    .db $C0
    .db $18
    .db $F4
    .db $FC
    .db $D4
    .db $C4
    .db $A4
    .db $94
    .db $0A
    .db $03
    .db $FF
    .db $FF
    .db $0F
    .db $0D
    .db $0C
    .db $0A
    .db $C8
    .db $28
    .db $F4
    .db $F8
    .db $F0
    .db $DC
    .db $C8
    .db $C8
    .db $00
    .db $00
L_006774: ; 0x006774, $C774
    .db $00
    .db $00
    .db $00
    .db $00
    .db $03
    .db $8E
    .db $C0
    .db $0C
    JMP   L_006036
    LDB   #$28
    BRA   L_006774
    LDB   #$80
    BRA   L_006774
    LDY   #$C9FE
    JSR   BNE_LOOP_FILL
    JMP   L_00633B
L_006791: ; 0x006791, $C791
    LDB   #$A5
    LDX   #$C001
    JMP   L_006036
    JSR   SEED_GEN_FROM_A_MANUAL
    JSR   L_00622A
    BSR   L_006791
    LDU   #$C0D7
    LDX   #$2820
    JSR   SEED_GEN_FROM_A_MANUAL
    JSR   L_00603C
    LDY   #$C061
    JSR   L_00606D
    LDY   #$05DC
    JSR   L_006244
    TST   UNK_$49_SYS_MENU_FLAG?
    BNE   L_00601F
    CLR   $A03C
    LDA   #$01
    STA   $A03B
    LEAS  -32,S
    JSR   JMP_CLEAR_ALL_SCREEN
    LDU   #$C0D7
    LDX   #$2820
    JSR   SEED_GEN_FROM_A_MANUAL
    JSR   L_00603C
    CLR   $A03A
    LDY   #$C065
    JSR   L_006066
    JSR   SEED_GEN_FROM_A_MANUAL
    LDA   #$20
    TFR   A>B
    DECB
    LEAX  S
L_0067EA: ; 0x0067EA, $C7EA
    STA   X+
    DECB
    BNE   L_0067EA
    LDA   #$17
    STA   X+
    LEAX  S
    JSR   L_006257
    LDX   #$CC00
    JSR   L_006039
    .db $C5
    .db $02
